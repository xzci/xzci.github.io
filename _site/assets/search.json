

[
  
  
    
    
      {
        "title": "format test",
        "excerpt": "format test\n\n01 Knowledge\n\n\n\n\n\n\n",
        "content": "format test\n\n01 Knowledge\n\n\n\n\n\n\n",
        "url": "/notes/2000/01/01/Format-Test/"
      },
    
      {
        "title": "Description of an Alembic",
        "excerpt": "The complete distilling apparatus consists of three parts: the “cucurbit” (Arabic ḳarʿa, Greek βίκος), the still pot containing the liquid to be distilled, which is heated by a flame; the “head” or “cap” (Arabic anbiḳ, Greek ἄμβιξ) which fits over the mouth of the cucurbit to receive the vapors, with an attached downward-sloping “tube” (Greek σωλήν), leading to the “receiver” (Arabic ḳābila, Greek ἄγγος or φιάλη) container.\n\n",
        "content": "The complete distilling apparatus consists of three parts: the “cucurbit” (Arabic ḳarʿa, Greek βίκος), the still pot containing the liquid to be distilled, which is heated by a flame; the “head” or “cap” (Arabic anbiḳ, Greek ἄμβιξ) which fits over the mouth of the cucurbit to receive the vapors, with an attached downward-sloping “tube” (Greek σωλήν), leading to the “receiver” (Arabic ḳābila, Greek ἄγγος or φιάλη) container.\n\n\n\nRetorts have the “cap” and the “cucurbit” made into one. The anbik is also called the raʾs (head) of the cucurbit. The liquid in the cucurbit is heated or boiled; the vapour rises into the anbik, where it cools by contact with the walls and condenses, running down the spout into the receiver. A modern descendant of the alembic is the pot still, used to produce distilled beverages.\n\nOriginally from Alembic - Wikipedia\n",
        "url": "/general/external%20sources/2016/08/27/example-post-one/"
      },
    
      {
        "title": "History of the Alembic",
        "excerpt": "Dioscorides’ ambix (described in his De materia medica) is a helmet-shaped lid for gathering condensed mercury. For Athenaeus (~ 225 C.E.) it is a bottle or flask. For later chemists it denotes various parts of crude distillation devices.\n\n",
        "content": "Dioscorides’ ambix (described in his De materia medica) is a helmet-shaped lid for gathering condensed mercury. For Athenaeus (~ 225 C.E.) it is a bottle or flask. For later chemists it denotes various parts of crude distillation devices.\n\n\n\nAlembic drawings appear in works of Cleopatra the Alchemist, Synesius, and Zosimos of Panopolis. There were alembics with two (dibikos) and three (tribikos) receivers.[4] According to Zosimos of Panopolis, the alembic was invented by Mary the Jewess.[5]\n\nThe anbik is described by Ibn al-Awwam in his Kitab al-Filaha (Book of Agriculture), where he explains how rose-water is distilled. Amongst others, it is mentioned in the Mafatih al-Ulum (Key of Sciences) of Khwarizmi and the Kitab al-Asrar (Book of Secrets) of Al-Razi. Some illustrations occur in the Latin translations of works which are attributed to Geber.[2]\n\nOriginally from Alembic - Wikipedia\n",
        "url": "/history/external%20sources/2016/08/28/example-post-two/"
      },
    
      {
        "title": "Description of a Pot Still",
        "excerpt": "A pot still is a type of still used in distilling spirits such as whisky or brandy. Heat is applied directly to the pot containing the wash (for whisky) or wine (for brandy).\n",
        "content": "A pot still is a type of still used in distilling spirits such as whisky or brandy. Heat is applied directly to the pot containing the wash (for whisky) or wine (for brandy). This is called a batch distillation (as opposed to a continuous distillation).\n\nAt standard atmospheric pressure, alcohol boils at 78 °C (172 °F), while water boils at 100 °C (212 °F). During distillation, the vapour contains more alcohol than the liquid. When the vapours are condensed, the resulting liquid contains a higher concentration of alcohol. In the pot still, the alcohol and water vapour combine with esters and flow from the still through the condensing coil. There they condense into the first distillation liquid, the so-called “low wines”. The low wines have a strength of about 25–35% alcohol by volume, and flow into a second still. It is then distilled a second time to produce the colourless spirit, collected at about 70% alcohol by volume. Colour is added through maturation in an oak aging barrel, and develops over time.\n\nThe modern pot still is a descendant of the alembic, an earlier distillation device.\n",
        "url": "/general/2016/08/29/example-post-three/"
      },
    
      {
        "title": "Summary",
        "excerpt": "I have deleted all my posts and i want to rebuild a new blog, including new tools and new programming languages. \nBy the way, I got an conditional offer from UQ， Hope i can pass all the text. :smile:\n\nTitles\n\nHere will be somethings i want to post.\n\nFinished\n\nHere will be some titles which are finished.\n\n在这里我们首先说一下mac终端执行命令的时候，不会像在windows系统中安装的linux一样支持自动补全，需要自己去调试\n\n步骤如下：\n\n（1）打开终端输入nano .inputrc（这里一定要注意nano后面有一个空格）\n\n（2）在nano编辑器中写上如下命令\n\n   set completion-ignore-case on\n   set show-all-if-ambiguous on\n   TAB: menu-complete\n\n\n（3）按下ctrl+o，回车，重启终端，自动补全按tab键就可以\n",
        "content": "I have deleted all my posts and i want to rebuild a new blog, including new tools and new programming languages. \nBy the way, I got an conditional offer from UQ， Hope i can pass all the text. :smile:\n\nTitles\n\nHere will be somethings i want to post.\n\nFinished\n\nHere will be some titles which are finished.\n\n在这里我们首先说一下mac终端执行命令的时候，不会像在windows系统中安装的linux一样支持自动补全，需要自己去调试\n\n步骤如下：\n\n（1）打开终端输入nano .inputrc（这里一定要注意nano后面有一个空格）\n\n（2）在nano编辑器中写上如下命令\n\n   set completion-ignore-case on\n   set show-all-if-ambiguous on\n   TAB: menu-complete\n\n\n（3）按下ctrl+o，回车，重启终端，自动补全按tab键就可以\n",
        "url": "/summary/2019/06/02/Summary/"
      },
    
      {
        "title": "Thinking in Java",
        "excerpt": "Here is some answers of Thinking in Java, during the time i am studying Java, I find lots of differences and improvements between C++. I try my best to finish all questions behind every chapters, because I think the best way to study a programming language is to code as much as can. And here they are, these questions can be good practices for me to train my coding ability.  last update: 19_06_10\n\nChapter 3\n\nTest 2 &amp; 3\n\n创新一个包含一个float的类，并用这个类来展现别名机制。\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Test test1 = new Test();\n        Test test2 = new Test();\n        System.out.println(\"Init data:\");\n        System.out.println(\"test1.i = \" + test1.i);\n        System.out.println(\"test2.i = \" + test2.i);\n\n        System.out.println(\"use class.value = class.value:\");\n        test1.i = test2.i = 100;\n\n        System.out.println(\"test1.i = \" + test1.i);\n        System.out.println(\"test2.i = \" + test2.i);\n\n        System.out.println(\"use class = class:\");\n        test1 = test2;\n        test1.i = 45;\n\n        System.out.println(\"test1.i = \" + test1.i);\n        System.out.println(\"test2.i = \" + test2.i);\n\n    }\n}\n\nclass Test {\n    float i = 12.0f;\n}\n\n\nTest 4\n\n编写一个计算速度的程序，它所使用的距离和时间都是常量。\n\npublic class Main {\n\n    public static void main(String[] args) {\n        double Speed = 12.1;\n        double time = 60;\n        System.out.println(Speed * time);\n    }\n}\n\n\nTest 5\n\n创建一个名为Dog的类，它包含两个String域，name和says。 在main()方法种，创建两个Dog对象，一个名为Spot（它的叫声为“Ruff！”）另一个名为scruffy（它的叫声为“Wurf！”）然后显示它们的名字和叫声。\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog spot = new Dog(\"spot\", \"Ruff!\");\n        Dog scuffy = new Dog(\"scuffy\",\"Wurf!\");\n\n        System.out.println(\"Name is \" + spot.name + \", says: \" + spot.says);\n        System.out.println(\"Name is \" + scuffy.name + \", says: \" + scuffy.says);\n    }\n}\n\nclass Dog {\n    public\n    String name;\n    public\n    String says;\n\n    Dog(String name, String says)\n    {\n        this.name = name;\n        this.says = says;\n    }\n}\n\n\nTest 6\n\n创建一个新的Dog的索引，并对其赋值为spot对象，测试用==和equals（）来比较所有引用的效果\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog spot = new Dog(\"spot\", \"Ruff!\");\n        Dog spot1 = new Dog();\n        spot1.says = spot.says;\n        spot1.name = spot.name;\n\n        System.out.println(\"use == :  \");\n        System.out.println(spot == spot1);\n        System.out.println(\"use equal\");\n        System.out.println(spot.equals(spot1));\n    }\n}\n\n\nTest 7\n\n编写一个程序模拟扔硬币的结果\n\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Random rand = new Random();\n        int i;\n        int index = 0;\n        while (index != 10) {\n            i = rand.nextInt(2);\n\n            switch (i) {\n                case 1:\n                    System.out.println(\"head\");\n                    break;\n                case 0:\n                    System.out.println(\"tail\");\n                    break;\n                default:\n                    System.out.println(\"wrong random\");\n                    break;\n            }\n            index++;\n        }\n\n    }\n}\n\n\nTest 8\n\n使用 十六进制和八进制来操作long值。\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n       long l = 0xFFFFF;\n       long l1 = 011111;\n\n       System.out.println(Long.toBinaryString(l) + \" \" + l);\n       System.out.println(Long.toBinaryString(l1) + \" \" + l1);\n\n    }\n}\n\n\nTest 9\n\n分别显示float和double使用指数计数法表示的最大值和最小值\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n       System.out.println(\"Max value of float :\" + Float.MAX_VALUE);\n       System.out.println(\"Min value of float :\" + Float.MIN_VALUE);\n       System.out.println(\"Max value of double :\" + Double.MAX_VALUE);\n       System.out.println(\"Min value of double :\" + Double.MIN_VALUE);\n\n    }\n}\n\n\nTest 10\n\n一个具有交替的1和0，最低有效位为0，另一个最低有效位为1，使用位操作的所有方式结合他们\n\npublic class Main {\n\n    public static void main(String[] args) {\n        String s = \"10101010101010\";\n        String s1 = \"101010101010101\";\n        int i = Integer.parseInt(s, 2);\n        int i1 = Integer.parseInt(s1, 2);\n\n        System.out.println(\"^ : \" + (i ^ i1) + \"  \" + Integer.toBinaryString((i ^ i1)));\n        System.out.println(\"| : \" + (i | i1) + \"  \" + Integer.toBinaryString((i | i1)));\n        System.out.println(\"&amp; : \" + (i &amp; i1) + \"  \" + Integer.toBinaryString((i &amp; i1)));\n        System.out.println(\"~ : \" + (~i1) + \"  \" + Integer.toBinaryString(~i1));\n        System.out.println(\"~ : \" + (~i) + \"  \" + Integer.toBinaryString(~i));\n\n\n    }\n}\n\n\nTest 11\n\n最高位有效数字为1的数字开始，向右移位，知道所有二进制位都被移出为止\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n       String s = \"111110111\";\n\n       int i = Integer.parseInt(s, 2);\n\n       while(i != 0)\n       {\n           i &gt;&gt;= 1;\n           System.out.println(i + \" - \" + Integer.toBinaryString(i));\n       }\n    }\n}\n\n\nTest 12\n\n所有位为1的数开始，先左移，然后右移，直到所有都被移出为止\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n       String s = \"111111111\";\n\n       int i = Integer.parseInt(s, 2);\n\n       i &lt;&lt;= 3;\n       System.out.println(i + \" - \" + Integer.toBinaryString(i));\n        \n       while(i != 0)\n       {\n           i &gt;&gt;= 1;\n           System.out.println(i + \" - \" + Integer.toBinaryString(i));\n       }\n    }\n}\n\n\nTest 13\n\n以二进制形式显示char类型的值\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        char a[] = {'a', 'b', 'c', 'd'};\n\n        for (int i : a) {\n            System.out.println((char)i + \" - \" + i + \" - \" + Integer.toBinaryString(i));\n        }\n\n    }\n}\n\n\nChapter 4\n\nTest 1\n\n打印1到100的值\npublic class Main {\n\n    public static void main(String[] args) {\n\n        for(int i = 1; i &lt;= 100; i++)\n        {\n            System.out.print(i + \" \");\n            if((i % 10) == 0)\n            {\n                System.out.println();\n            }\n        }\n\n    }\n}\n\n\nTest 2 &amp; 3\n\n生成25个随机数，判断与下一个数的关系（大于，小于，等于）\n\nThis question should be worth to think about it.\nJava do not let you use some code like this below\nint r;\nfor(...)\nprint(r);\n\nThat will cause an error, r might not be initialized. if you are familiar with C or C++, you maybe thought this code should be ok, but java does not allow it.\nJava ask you to initialize and define any value before you use it.\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Random rand = new Random();\n        int r, temp = 0;\n        r = rand.nextInt(100);\n        System.out.println(\"The begin number is \" + r);\n        temp = r;\n        for (int i = 0; i &lt; 25; i++) {\n            if (i == 0) {\n                ;\n            } else {\n                r = rand.nextInt(100);\n                if (r &gt; temp)\n                    System.out.println(\"No.\" + i + \", this time number is \" + temp +\n                            \", and next time the number is \" + r +\n                            \", and the status is Smaller\");\n                else if (r == temp)\n                    System.out.println(\"No.\" + i + \", this time number is \" + temp +\n                            \", and next time the number is \" + r +\n                            \", and the status is equal\");\n                else\n                    System.out.println(\"No.\" + i + \", this time number is \" + temp +\n                            \", and next time the number is \" + r +\n                            \", and the status is larger\");\n                temp = r;\n\n            }\n\n        }\n        System.out.println(\"No.25, the final number is \" + r);\n    }\n}\n\nTest 4\n\n只用2层for和%找出素数\n\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Chapter4 c = new Chapter4();\n        c.CheckPrimeNumber0ToInput(0);\n    }\n}\n\nclass Chapter4 {\n    //you should type a number which is larger than 0\n    void CheckPrimeNumber0ToInput(int num) {\n        int isPrimeNumber = 0;\n\n        for (int j = 0; j &lt;= num; j++) {\n            if (j == 1 || j == 0)\n                isPrimeNumber = 1;\n            else {\n                for (int i = 2; i &lt; j; i++)\n                    if ((j % i) == 0)\n                        isPrimeNumber++;\n            }\n            if (isPrimeNumber == 0)\n                System.out.println(j + \" is Prime Number\");\n            else\n                System.out.println(j + \" is not Prime Number\");\n            isPrimeNumber = 0;\n        }\n    }\n}\n\n\nTest 5\n略\n\nTest 6\n\n增加两个参数，判断输入是否是在他们之间\n\npublic class Main {\n    static int test(int testval, int target, int begin, int end)\n    {\n        int returnValue = 0;\n        if(testval &gt; target)\n            returnValue = 1;\n        else if (testval &lt; target)\n             returnValue = -1;\n        else\n            returnValue = 0;\n        if(testval &lt;= end &amp;&amp; testval &gt;= begin)\n            System.out.println(\"test value is within the range\");\n        else\n            System.out.println(\"test value is not within the range\");\n\n        return returnValue;\n\n    }\n    public static void main(String[] args) {\n        System.out.println(test(5,10,2,8));\n        System.out.println(test(5,0,1,3));\n    }\n}\n\n\nTest 7\n\n使用break 和return 打到99\n\n// break\npublic class Main {\n    static void test() {\n        for (int i = 1; i &lt;= 100; i++) {\n\n            System.out.print(i + \" \");\n            if ((i % 10) == 0) {\n                System.out.println();\n            }\n            if (i == 99)\n                break;\n        }\n    }\n\n    public static void main(String[] args) {\n        test();\n    }\n}\n\n\n// return\npublic class Main {\n    static void test() {\n        for (int i = 1; i &lt;= 100; i++) {\n\n            System.out.print(i + \" \");\n            if ((i % 10) == 0) {\n                System.out.println();\n            }\n            if (i == 99)\n                return;\n        }\n    }\n\n    public static void main(String[] args) {\n        test();\n    }\n}\n\n\nTest 8\n\n写一个switch 开关，放入for中测试每次的情况，测试有break和没有break的区别\n\n// with break\npublic class Main {\n    \n    public static void main(String[] args) {\n\n        for (int i = 0; i != 3; i++) {\n            switch (i) {\n                case 0:\n                    System.out.println(\"First\");\n                    break;\n                case 1:\n                    System.out.println(\"Second\");\n                    break;\n                case 2:\n                    System.out.println(\"Third\");\n                    break;\n            }\n        }\n    }\n}\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        for (int i = 0; i != 3; i++) {\n            switch (i) {\n                case 0:\n                    System.out.println(\"First\");\n                case 1:\n                    System.out.println(\"Second\");\n                case 2:\n                    System.out.println(\"Third\");\n            }\n        }\n    }\n}\n\n\nTest 9\n\n输出斐波那契数列\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Fibonacci f = new Fibonacci(5);\n    }\n}\n\nclass Fibonacci {\n    Fibonacci(int index) {\n        for (int i = 1; i &lt;= index; i++) {\n            System.out.println(fibonacci(i));\n        }\n    }\n\n    int fibonacci(int i) {\n        if (i == 1 || i == 2)\n            return 1;\n        else\n            return fibonacci((i - 1)) + fibonacci((i - 2));\n    }\n}\n\n\nTest 10\n\n输出4位数的吸血鬼数\n\nIn this question, I made a big mistake, I should use method to replace the codes, because they are nearly same. (method in some way can help you type less code and make it readable).\n\nfor example:\n\n\n  ((ones * 10 + tens) * (hundreds * 10 + thousands) == i)\n\n\nI should add the new methods:\n\nstatic int multiply(int i, int j)\n{\n    return i * 10 + j;\n}\n\nstatic boolean check(int number, int i, int j)\n{\n    return number == (i * j);\n}\nstatic void print(int ones, int tens, int hundreds, int thousands)\n{\n    System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + tens + \" * \" + hundreds + thousands);\n}\n\nand replace my code like this:\n\n// ....\n// In this way, you can make your code look well and readable.\nif(check(i, multiply(ones, tens), multiply(hundreds, thousands)))\n    print(ones, tens, hundreds, thousands);\n// ....\n\nand here is my old answer. pretty messy.\n\npublic class Main {\n\n    public static void main(String[] args) {\n        VampireNumber v = new VampireNumber();\n        v.vampireNumber();\n    }\n}\n\n\nclass VampireNumber {\n    void vampireNumber() {\n        int ones, tens, hundreds, thousands;\n        for (int i = 1000; i &lt; 10000; i++) {\n            \n            ones = i % 10;\n            tens = i / 10 % 10;\n            hundreds = i / 100 % 10;\n            thousands = i / 1000;\n\n            if(ones == 0 &amp;&amp; tens == 0)\n                continue;\n            // 1\n            if ((ones * 10 + tens) * (hundreds * 10 + thousands) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + tens + \" * \" + hundreds + thousands);\n            }\n            // 2\n            else if ((ones * 10 + tens) * (thousands * 10 + hundreds) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + tens + \" * \" + thousands + hundreds);\n            }\n            // 3\n            else if ((ones * 10 + hundreds) * (tens  * 10 + thousands) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + hundreds + \" * \" + tens + thousands);\n            }\n            // 4\n            else if ((ones * 10 + hundreds) * (thousands * 10 + tens) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + hundreds + \" * \" + thousands + tens);\n            }\n            // 5\n            else if ((ones * 10 + thousands) * (tens * 10 + hundreds) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + thousands + \" * \" + tens + hundreds);\n            }\n            // 6\n            else if ((ones * 10 + thousands) * (hundreds * 10 + tens) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + thousands + \" * \" + hundreds + tens );\n            }\n\n            // 21 34\n            else if ((tens * 10 + ones) * (hundreds * 10 + thousands) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + tens + ones + \" * \" + hundreds + thousands);\n            }\n            // 23 41\n            else if ((tens * 10 + hundreds) * (thousands * 10 + ones) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + tens + hundreds + \" * \" + thousands + ones);\n            }\n            // 24 31\n            else if ((tens * 10 + thousands) * (hundreds * 10 + ones) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + tens + thousands + \" * \" + hundreds + ones);\n            }\n\n            // 31 42\n            else if ((hundreds * 10 + ones) * (thousands * 10 + tens) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + hundreds + ones + \" * \" + thousands + tens);\n            }\n            // 32 41\n            else if ((hundreds * 10 + tens) * (thousands * 10 + ones) == i )\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + hundreds + tens + \" * \" + thousands + ones);\n            }\n        }\n    }\n}\n\n\nChapter 5\n\nTest 1\n\n创建类，包含一个string，验证被初始化为了null\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Test t = new Test();\n        if(t.str == null)\n            System.out.println(\"It's null\");\n        else\n            System.out.println(\"It isn't null\");\n    }\n}\n\nclass Test {\n    String str;\n}\n\n\nTest 2\n\n创建类，判断差异，一个string在定义时被初始化，一个通过构造器初始化\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Test t = new Test(\"a value\");\n        System.out.println(\"t.str \" + t.str);\n        System.out.println(\"t.testStr \" + t.testStr);\n\n        Test t1 = new Test();\n        System.out.println(\"t1.str \" + t1.str);\n        System.out.println(\"t1.testStr \" + t1.testStr);\n\n        t1.str = \"131\";\n        t1.testStr = \"13123\";\n        System.out.println(\"t1.str \" + t1.str);\n        System.out.println(\"t1.testStr \" + t1.testStr);\n    }\n}\n\nclass Test {\n    String str = \"get\";\n    String testStr;\n    Test(String testStr)\n    {\n        this.testStr = testStr;\n    }\n    Test()\n    {\n\n    }\n}\n\nTest 3\n\n创建一个默认构造器，打印一行话\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Test t = new Test();\n    }\n}\n\nclass Test {\n    Test() {\n        System.out.println(\"This is a sentence\");\n    }\n}\n\n\nTest 4\n\n为上一个问题添加一个重载的构造器，接受一个字符串参数，把自己的话和新增的话打印出来\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Test t = new Test();\n        Test t1 = new Test(\"again??\");\n    }\n}\n\nclass Test {\n    Test() {\n        System.out.println(\"This is a sentence\");\n    }\n    Test(String str)\n    {\n        System.out.println(\"This is a sentence. \" + str);\n    }\n}\n\n\nTest 5\n创建一个Dog类，有一个重载的bark()方法，打印不同类型的狗吠barking，咆哮 howling\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog myDog = new Dog(1);\n        Dog yourDog = new Dog(\"1\");\n    }\n}\n\nclass Dog {\n    Dog(int i) {\n        System.out.println(\"Barking\");\n    }\n\n    Dog(String str) {\n        System.out.println(\"Howling\");\n    }\n}\n\n\nTest 6\n\n设置2个参数来实现重载，但是顺序不同，判断是否工作\n\nBecause java does not Implicit convert data type, so these codes will all be fine to Java.\nBut if you were writing C++ code, you should pay much attention on these.\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog dog1 = new Dog(1,1);\n        Dog dog2 = new Dog(1,1.0);\n        Dog dog3 = new Dog(1.0,1.0);\n        Dog dog4 = new Dog(1.0f,1.0);\n        Dog dog5 = new Dog(1.0,1.0f);\n        Dog dog6 = new Dog(1,1.0f);\n        Dog dog7 = new Dog(1.0f,1);\n        Dog dog8 = new Dog(1.0,1);\n        Dog dog9 = new Dog(1,1l);\n        Dog dog10 = new Dog(1l,1);\n    }\n}\n\nclass Dog {\n    Dog(int i,float j) {\n        System.out.println(\"int float\");\n    }\n    Dog(double i, double j) {\n        System.out.println(\"double double\");\n    }\n    Dog(int i, int j) {\n        System.out.println(\"int int\");\n    }\n    Dog(int i, double j) {\n        System.out.println(\"int double\");\n    }\n    Dog(float i, int j) {\n        System.out.println(\"float int\");\n    }\n    Dog(double i, int j) {\n        System.out.println(\"double int\");\n    }\n    Dog(int i, long j) {\n        System.out.println(\"int long\");\n    }\n    Dog(long i, int j) {\n        System.out.println(\"long int\");\n    }\n    Dog(float i, double j) {\n        System.out.println(\"float double\");\n    }\n    Dog(double i, float j) {\n        System.out.println(\"double float\");\n    }\n}\n\n\nTest 7\n\n创建一个没有构造器的类，在main中创建对象，验证是否有自动加入了默认构造器\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n\n        System.out.println(\"Work well\");\n    }\n}\n\nclass Dog {\n}\n\n\nTest 8\n\n写一个有2个方法的类，调用方法2次，一次单纯调用，一次使用this\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        dog.g();\n    }\n}\n\nclass Dog {\n    void f()\n    {\n        System.out.println(\"It's a test\");\n    }\n    void g()\n    {\n        f();\n        this.f();\n    }\n}\n\n\nTest 9\n\n编写2个重载构造器，一个调用另外的一个\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        Dog dog1 = new Dog(\"Java\");\n    }\n}\n\nclass Dog {\n    Dog() {\n        this(\"C++\");\n        System.out.println(\"Good baby\\n\");\n    }\n\n    Dog(String str) {\n        System.out.println(\"I like \" + str.replace(\"Java\", \"C++\"));\n    }\n}\n\n\nTest 10 - 12\n\n略\n\nTest 13\n\n验证段落中的语句\n\nclass Cup {\n    Cup(int marker) {\n        System.out.println(\"Cup(\" + marker + \")\");\n    }\n\n    void f(int marker) {\n        System.out.println(\"f(\" + marker + \")\");\n    }\n}\n\nclass Cups {\n    static Cup cup1;\n    static Cup cup2;\n\n    static {\n        cup1 = new Cup(1);\n        cup2 = new Cup(2);\n    }\n\n    Cups() {\n        System.out.println(\"Cups()\");\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Inside main()\");\n        Cups.cup1.f(99);\n    }\n\n    static Cups cups1 = new Cups();\n    //static Cups cups2 = new Cups();\n}\n\n\nTest 14\n\n编写一个类，拥有2个字符串域，一个在定义的时候初始化，一个在静态块中初始化，加入一个静态方法，打印他们的值，证明，他们会在使用之前完成初始化的动作\nclass Test14 {\n    static String s = \"s\";\n    static String s1;\n    static {\n        s1 = \"s1\";\n        System.out.println(\"s1 is initialized\");\n    }\n    static void f() {\n        System.out.println(s + \" and \" + s1);\n    }\n\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Inside main()\");\n        Test14.f();\n    }\n\n}\n\n\nChapter 6\n\nTest 1\n\nTest 1\n\nTest 1\n\nTest 1\n\nTest 1\n\nTest 1\n\nTest 1\n",
        "content": "Here is some answers of Thinking in Java, during the time i am studying Java, I find lots of differences and improvements between C++. I try my best to finish all questions behind every chapters, because I think the best way to study a programming language is to code as much as can. And here they are, these questions can be good practices for me to train my coding ability.  last update: 19_06_10\n\nChapter 3\n\nTest 2 &amp; 3\n\n创新一个包含一个float的类，并用这个类来展现别名机制。\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Test test1 = new Test();\n        Test test2 = new Test();\n        System.out.println(\"Init data:\");\n        System.out.println(\"test1.i = \" + test1.i);\n        System.out.println(\"test2.i = \" + test2.i);\n\n        System.out.println(\"use class.value = class.value:\");\n        test1.i = test2.i = 100;\n\n        System.out.println(\"test1.i = \" + test1.i);\n        System.out.println(\"test2.i = \" + test2.i);\n\n        System.out.println(\"use class = class:\");\n        test1 = test2;\n        test1.i = 45;\n\n        System.out.println(\"test1.i = \" + test1.i);\n        System.out.println(\"test2.i = \" + test2.i);\n\n    }\n}\n\nclass Test {\n    float i = 12.0f;\n}\n\n\nTest 4\n\n编写一个计算速度的程序，它所使用的距离和时间都是常量。\n\npublic class Main {\n\n    public static void main(String[] args) {\n        double Speed = 12.1;\n        double time = 60;\n        System.out.println(Speed * time);\n    }\n}\n\n\nTest 5\n\n创建一个名为Dog的类，它包含两个String域，name和says。 在main()方法种，创建两个Dog对象，一个名为Spot（它的叫声为“Ruff！”）另一个名为scruffy（它的叫声为“Wurf！”）然后显示它们的名字和叫声。\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog spot = new Dog(\"spot\", \"Ruff!\");\n        Dog scuffy = new Dog(\"scuffy\",\"Wurf!\");\n\n        System.out.println(\"Name is \" + spot.name + \", says: \" + spot.says);\n        System.out.println(\"Name is \" + scuffy.name + \", says: \" + scuffy.says);\n    }\n}\n\nclass Dog {\n    public\n    String name;\n    public\n    String says;\n\n    Dog(String name, String says)\n    {\n        this.name = name;\n        this.says = says;\n    }\n}\n\n\nTest 6\n\n创建一个新的Dog的索引，并对其赋值为spot对象，测试用==和equals（）来比较所有引用的效果\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog spot = new Dog(\"spot\", \"Ruff!\");\n        Dog spot1 = new Dog();\n        spot1.says = spot.says;\n        spot1.name = spot.name;\n\n        System.out.println(\"use == :  \");\n        System.out.println(spot == spot1);\n        System.out.println(\"use equal\");\n        System.out.println(spot.equals(spot1));\n    }\n}\n\n\nTest 7\n\n编写一个程序模拟扔硬币的结果\n\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Random rand = new Random();\n        int i;\n        int index = 0;\n        while (index != 10) {\n            i = rand.nextInt(2);\n\n            switch (i) {\n                case 1:\n                    System.out.println(\"head\");\n                    break;\n                case 0:\n                    System.out.println(\"tail\");\n                    break;\n                default:\n                    System.out.println(\"wrong random\");\n                    break;\n            }\n            index++;\n        }\n\n    }\n}\n\n\nTest 8\n\n使用 十六进制和八进制来操作long值。\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n       long l = 0xFFFFF;\n       long l1 = 011111;\n\n       System.out.println(Long.toBinaryString(l) + \" \" + l);\n       System.out.println(Long.toBinaryString(l1) + \" \" + l1);\n\n    }\n}\n\n\nTest 9\n\n分别显示float和double使用指数计数法表示的最大值和最小值\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n       System.out.println(\"Max value of float :\" + Float.MAX_VALUE);\n       System.out.println(\"Min value of float :\" + Float.MIN_VALUE);\n       System.out.println(\"Max value of double :\" + Double.MAX_VALUE);\n       System.out.println(\"Min value of double :\" + Double.MIN_VALUE);\n\n    }\n}\n\n\nTest 10\n\n一个具有交替的1和0，最低有效位为0，另一个最低有效位为1，使用位操作的所有方式结合他们\n\npublic class Main {\n\n    public static void main(String[] args) {\n        String s = \"10101010101010\";\n        String s1 = \"101010101010101\";\n        int i = Integer.parseInt(s, 2);\n        int i1 = Integer.parseInt(s1, 2);\n\n        System.out.println(\"^ : \" + (i ^ i1) + \"  \" + Integer.toBinaryString((i ^ i1)));\n        System.out.println(\"| : \" + (i | i1) + \"  \" + Integer.toBinaryString((i | i1)));\n        System.out.println(\"&amp; : \" + (i &amp; i1) + \"  \" + Integer.toBinaryString((i &amp; i1)));\n        System.out.println(\"~ : \" + (~i1) + \"  \" + Integer.toBinaryString(~i1));\n        System.out.println(\"~ : \" + (~i) + \"  \" + Integer.toBinaryString(~i));\n\n\n    }\n}\n\n\nTest 11\n\n最高位有效数字为1的数字开始，向右移位，知道所有二进制位都被移出为止\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n       String s = \"111110111\";\n\n       int i = Integer.parseInt(s, 2);\n\n       while(i != 0)\n       {\n           i &gt;&gt;= 1;\n           System.out.println(i + \" - \" + Integer.toBinaryString(i));\n       }\n    }\n}\n\n\nTest 12\n\n所有位为1的数开始，先左移，然后右移，直到所有都被移出为止\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n       String s = \"111111111\";\n\n       int i = Integer.parseInt(s, 2);\n\n       i &lt;&lt;= 3;\n       System.out.println(i + \" - \" + Integer.toBinaryString(i));\n        \n       while(i != 0)\n       {\n           i &gt;&gt;= 1;\n           System.out.println(i + \" - \" + Integer.toBinaryString(i));\n       }\n    }\n}\n\n\nTest 13\n\n以二进制形式显示char类型的值\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        char a[] = {'a', 'b', 'c', 'd'};\n\n        for (int i : a) {\n            System.out.println((char)i + \" - \" + i + \" - \" + Integer.toBinaryString(i));\n        }\n\n    }\n}\n\n\nChapter 4\n\nTest 1\n\n打印1到100的值\npublic class Main {\n\n    public static void main(String[] args) {\n\n        for(int i = 1; i &lt;= 100; i++)\n        {\n            System.out.print(i + \" \");\n            if((i % 10) == 0)\n            {\n                System.out.println();\n            }\n        }\n\n    }\n}\n\n\nTest 2 &amp; 3\n\n生成25个随机数，判断与下一个数的关系（大于，小于，等于）\n\nThis question should be worth to think about it.\nJava do not let you use some code like this below\nint r;\nfor(...)\nprint(r);\n\nThat will cause an error, r might not be initialized. if you are familiar with C or C++, you maybe thought this code should be ok, but java does not allow it.\nJava ask you to initialize and define any value before you use it.\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Random rand = new Random();\n        int r, temp = 0;\n        r = rand.nextInt(100);\n        System.out.println(\"The begin number is \" + r);\n        temp = r;\n        for (int i = 0; i &lt; 25; i++) {\n            if (i == 0) {\n                ;\n            } else {\n                r = rand.nextInt(100);\n                if (r &gt; temp)\n                    System.out.println(\"No.\" + i + \", this time number is \" + temp +\n                            \", and next time the number is \" + r +\n                            \", and the status is Smaller\");\n                else if (r == temp)\n                    System.out.println(\"No.\" + i + \", this time number is \" + temp +\n                            \", and next time the number is \" + r +\n                            \", and the status is equal\");\n                else\n                    System.out.println(\"No.\" + i + \", this time number is \" + temp +\n                            \", and next time the number is \" + r +\n                            \", and the status is larger\");\n                temp = r;\n\n            }\n\n        }\n        System.out.println(\"No.25, the final number is \" + r);\n    }\n}\n\nTest 4\n\n只用2层for和%找出素数\n\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Chapter4 c = new Chapter4();\n        c.CheckPrimeNumber0ToInput(0);\n    }\n}\n\nclass Chapter4 {\n    //you should type a number which is larger than 0\n    void CheckPrimeNumber0ToInput(int num) {\n        int isPrimeNumber = 0;\n\n        for (int j = 0; j &lt;= num; j++) {\n            if (j == 1 || j == 0)\n                isPrimeNumber = 1;\n            else {\n                for (int i = 2; i &lt; j; i++)\n                    if ((j % i) == 0)\n                        isPrimeNumber++;\n            }\n            if (isPrimeNumber == 0)\n                System.out.println(j + \" is Prime Number\");\n            else\n                System.out.println(j + \" is not Prime Number\");\n            isPrimeNumber = 0;\n        }\n    }\n}\n\n\nTest 5\n略\n\nTest 6\n\n增加两个参数，判断输入是否是在他们之间\n\npublic class Main {\n    static int test(int testval, int target, int begin, int end)\n    {\n        int returnValue = 0;\n        if(testval &gt; target)\n            returnValue = 1;\n        else if (testval &lt; target)\n             returnValue = -1;\n        else\n            returnValue = 0;\n        if(testval &lt;= end &amp;&amp; testval &gt;= begin)\n            System.out.println(\"test value is within the range\");\n        else\n            System.out.println(\"test value is not within the range\");\n\n        return returnValue;\n\n    }\n    public static void main(String[] args) {\n        System.out.println(test(5,10,2,8));\n        System.out.println(test(5,0,1,3));\n    }\n}\n\n\nTest 7\n\n使用break 和return 打到99\n\n// break\npublic class Main {\n    static void test() {\n        for (int i = 1; i &lt;= 100; i++) {\n\n            System.out.print(i + \" \");\n            if ((i % 10) == 0) {\n                System.out.println();\n            }\n            if (i == 99)\n                break;\n        }\n    }\n\n    public static void main(String[] args) {\n        test();\n    }\n}\n\n\n// return\npublic class Main {\n    static void test() {\n        for (int i = 1; i &lt;= 100; i++) {\n\n            System.out.print(i + \" \");\n            if ((i % 10) == 0) {\n                System.out.println();\n            }\n            if (i == 99)\n                return;\n        }\n    }\n\n    public static void main(String[] args) {\n        test();\n    }\n}\n\n\nTest 8\n\n写一个switch 开关，放入for中测试每次的情况，测试有break和没有break的区别\n\n// with break\npublic class Main {\n    \n    public static void main(String[] args) {\n\n        for (int i = 0; i != 3; i++) {\n            switch (i) {\n                case 0:\n                    System.out.println(\"First\");\n                    break;\n                case 1:\n                    System.out.println(\"Second\");\n                    break;\n                case 2:\n                    System.out.println(\"Third\");\n                    break;\n            }\n        }\n    }\n}\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        for (int i = 0; i != 3; i++) {\n            switch (i) {\n                case 0:\n                    System.out.println(\"First\");\n                case 1:\n                    System.out.println(\"Second\");\n                case 2:\n                    System.out.println(\"Third\");\n            }\n        }\n    }\n}\n\n\nTest 9\n\n输出斐波那契数列\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Fibonacci f = new Fibonacci(5);\n    }\n}\n\nclass Fibonacci {\n    Fibonacci(int index) {\n        for (int i = 1; i &lt;= index; i++) {\n            System.out.println(fibonacci(i));\n        }\n    }\n\n    int fibonacci(int i) {\n        if (i == 1 || i == 2)\n            return 1;\n        else\n            return fibonacci((i - 1)) + fibonacci((i - 2));\n    }\n}\n\n\nTest 10\n\n输出4位数的吸血鬼数\n\nIn this question, I made a big mistake, I should use method to replace the codes, because they are nearly same. (method in some way can help you type less code and make it readable).\n\nfor example:\n\n\n  ((ones * 10 + tens) * (hundreds * 10 + thousands) == i)\n\n\nI should add the new methods:\n\nstatic int multiply(int i, int j)\n{\n    return i * 10 + j;\n}\n\nstatic boolean check(int number, int i, int j)\n{\n    return number == (i * j);\n}\nstatic void print(int ones, int tens, int hundreds, int thousands)\n{\n    System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + tens + \" * \" + hundreds + thousands);\n}\n\nand replace my code like this:\n\n// ....\n// In this way, you can make your code look well and readable.\nif(check(i, multiply(ones, tens), multiply(hundreds, thousands)))\n    print(ones, tens, hundreds, thousands);\n// ....\n\nand here is my old answer. pretty messy.\n\npublic class Main {\n\n    public static void main(String[] args) {\n        VampireNumber v = new VampireNumber();\n        v.vampireNumber();\n    }\n}\n\n\nclass VampireNumber {\n    void vampireNumber() {\n        int ones, tens, hundreds, thousands;\n        for (int i = 1000; i &lt; 10000; i++) {\n            \n            ones = i % 10;\n            tens = i / 10 % 10;\n            hundreds = i / 100 % 10;\n            thousands = i / 1000;\n\n            if(ones == 0 &amp;&amp; tens == 0)\n                continue;\n            // 1\n            if ((ones * 10 + tens) * (hundreds * 10 + thousands) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + tens + \" * \" + hundreds + thousands);\n            }\n            // 2\n            else if ((ones * 10 + tens) * (thousands * 10 + hundreds) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + tens + \" * \" + thousands + hundreds);\n            }\n            // 3\n            else if ((ones * 10 + hundreds) * (tens  * 10 + thousands) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + hundreds + \" * \" + tens + thousands);\n            }\n            // 4\n            else if ((ones * 10 + hundreds) * (thousands * 10 + tens) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + hundreds + \" * \" + thousands + tens);\n            }\n            // 5\n            else if ((ones * 10 + thousands) * (tens * 10 + hundreds) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + thousands + \" * \" + tens + hundreds);\n            }\n            // 6\n            else if ((ones * 10 + thousands) * (hundreds * 10 + tens) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + ones + thousands + \" * \" + hundreds + tens );\n            }\n\n            // 21 34\n            else if ((tens * 10 + ones) * (hundreds * 10 + thousands) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + tens + ones + \" * \" + hundreds + thousands);\n            }\n            // 23 41\n            else if ((tens * 10 + hundreds) * (thousands * 10 + ones) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + tens + hundreds + \" * \" + thousands + ones);\n            }\n            // 24 31\n            else if ((tens * 10 + thousands) * (hundreds * 10 + ones) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + tens + thousands + \" * \" + hundreds + ones);\n            }\n\n            // 31 42\n            else if ((hundreds * 10 + ones) * (thousands * 10 + tens) == i)\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + hundreds + ones + \" * \" + thousands + tens);\n            }\n            // 32 41\n            else if ((hundreds * 10 + tens) * (thousands * 10 + ones) == i )\n            {\n                System.out.println(\"The Vampire number is \" + i +\n                        \" --\" + hundreds + tens + \" * \" + thousands + ones);\n            }\n        }\n    }\n}\n\n\nChapter 5\n\nTest 1\n\n创建类，包含一个string，验证被初始化为了null\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Test t = new Test();\n        if(t.str == null)\n            System.out.println(\"It's null\");\n        else\n            System.out.println(\"It isn't null\");\n    }\n}\n\nclass Test {\n    String str;\n}\n\n\nTest 2\n\n创建类，判断差异，一个string在定义时被初始化，一个通过构造器初始化\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Test t = new Test(\"a value\");\n        System.out.println(\"t.str \" + t.str);\n        System.out.println(\"t.testStr \" + t.testStr);\n\n        Test t1 = new Test();\n        System.out.println(\"t1.str \" + t1.str);\n        System.out.println(\"t1.testStr \" + t1.testStr);\n\n        t1.str = \"131\";\n        t1.testStr = \"13123\";\n        System.out.println(\"t1.str \" + t1.str);\n        System.out.println(\"t1.testStr \" + t1.testStr);\n    }\n}\n\nclass Test {\n    String str = \"get\";\n    String testStr;\n    Test(String testStr)\n    {\n        this.testStr = testStr;\n    }\n    Test()\n    {\n\n    }\n}\n\nTest 3\n\n创建一个默认构造器，打印一行话\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Test t = new Test();\n    }\n}\n\nclass Test {\n    Test() {\n        System.out.println(\"This is a sentence\");\n    }\n}\n\n\nTest 4\n\n为上一个问题添加一个重载的构造器，接受一个字符串参数，把自己的话和新增的话打印出来\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Test t = new Test();\n        Test t1 = new Test(\"again??\");\n    }\n}\n\nclass Test {\n    Test() {\n        System.out.println(\"This is a sentence\");\n    }\n    Test(String str)\n    {\n        System.out.println(\"This is a sentence. \" + str);\n    }\n}\n\n\nTest 5\n创建一个Dog类，有一个重载的bark()方法，打印不同类型的狗吠barking，咆哮 howling\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog myDog = new Dog(1);\n        Dog yourDog = new Dog(\"1\");\n    }\n}\n\nclass Dog {\n    Dog(int i) {\n        System.out.println(\"Barking\");\n    }\n\n    Dog(String str) {\n        System.out.println(\"Howling\");\n    }\n}\n\n\nTest 6\n\n设置2个参数来实现重载，但是顺序不同，判断是否工作\n\nBecause java does not Implicit convert data type, so these codes will all be fine to Java.\nBut if you were writing C++ code, you should pay much attention on these.\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog dog1 = new Dog(1,1);\n        Dog dog2 = new Dog(1,1.0);\n        Dog dog3 = new Dog(1.0,1.0);\n        Dog dog4 = new Dog(1.0f,1.0);\n        Dog dog5 = new Dog(1.0,1.0f);\n        Dog dog6 = new Dog(1,1.0f);\n        Dog dog7 = new Dog(1.0f,1);\n        Dog dog8 = new Dog(1.0,1);\n        Dog dog9 = new Dog(1,1l);\n        Dog dog10 = new Dog(1l,1);\n    }\n}\n\nclass Dog {\n    Dog(int i,float j) {\n        System.out.println(\"int float\");\n    }\n    Dog(double i, double j) {\n        System.out.println(\"double double\");\n    }\n    Dog(int i, int j) {\n        System.out.println(\"int int\");\n    }\n    Dog(int i, double j) {\n        System.out.println(\"int double\");\n    }\n    Dog(float i, int j) {\n        System.out.println(\"float int\");\n    }\n    Dog(double i, int j) {\n        System.out.println(\"double int\");\n    }\n    Dog(int i, long j) {\n        System.out.println(\"int long\");\n    }\n    Dog(long i, int j) {\n        System.out.println(\"long int\");\n    }\n    Dog(float i, double j) {\n        System.out.println(\"float double\");\n    }\n    Dog(double i, float j) {\n        System.out.println(\"double float\");\n    }\n}\n\n\nTest 7\n\n创建一个没有构造器的类，在main中创建对象，验证是否有自动加入了默认构造器\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n\n        System.out.println(\"Work well\");\n    }\n}\n\nclass Dog {\n}\n\n\nTest 8\n\n写一个有2个方法的类，调用方法2次，一次单纯调用，一次使用this\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        dog.g();\n    }\n}\n\nclass Dog {\n    void f()\n    {\n        System.out.println(\"It's a test\");\n    }\n    void g()\n    {\n        f();\n        this.f();\n    }\n}\n\n\nTest 9\n\n编写2个重载构造器，一个调用另外的一个\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Dog dog = new Dog();\n        Dog dog1 = new Dog(\"Java\");\n    }\n}\n\nclass Dog {\n    Dog() {\n        this(\"C++\");\n        System.out.println(\"Good baby\\n\");\n    }\n\n    Dog(String str) {\n        System.out.println(\"I like \" + str.replace(\"Java\", \"C++\"));\n    }\n}\n\n\nTest 10 - 12\n\n略\n\nTest 13\n\n验证段落中的语句\n\nclass Cup {\n    Cup(int marker) {\n        System.out.println(\"Cup(\" + marker + \")\");\n    }\n\n    void f(int marker) {\n        System.out.println(\"f(\" + marker + \")\");\n    }\n}\n\nclass Cups {\n    static Cup cup1;\n    static Cup cup2;\n\n    static {\n        cup1 = new Cup(1);\n        cup2 = new Cup(2);\n    }\n\n    Cups() {\n        System.out.println(\"Cups()\");\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Inside main()\");\n        Cups.cup1.f(99);\n    }\n\n    static Cups cups1 = new Cups();\n    //static Cups cups2 = new Cups();\n}\n\n\nTest 14\n\n编写一个类，拥有2个字符串域，一个在定义的时候初始化，一个在静态块中初始化，加入一个静态方法，打印他们的值，证明，他们会在使用之前完成初始化的动作\nclass Test14 {\n    static String s = \"s\";\n    static String s1;\n    static {\n        s1 = \"s1\";\n        System.out.println(\"s1 is initialized\");\n    }\n    static void f() {\n        System.out.println(s + \" and \" + s1);\n    }\n\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Inside main()\");\n        Test14.f();\n    }\n\n}\n\n\nChapter 6\n\nTest 1\n\nTest 1\n\nTest 1\n\nTest 1\n\nTest 1\n\nTest 1\n\nTest 1\n",
        "url": "/answers/2019/06/06/Thinking-in-Java/"
      },
    
      {
        "title": "编程中用到的计算方法",
        "excerpt": "整理一些不知道的计算方法\n\n不使用除号计算除法(整数)\n\nvoid f(int a, int b) {\n    int quotient, remainder;\n    quotient = 0;\n    while (a &gt; b) {\n        quotient++;\n        a -= b;\n    }\n    remainder = a;\n    printf(\"%d, %d\", quotient, remainder);\n}\n\n\n取得数字各位的值的加和\n\n```c\nwhile(x &gt; 0) {\n    y += x % 10;\n    x /= 10;\n}\n\n",
        "content": "整理一些不知道的计算方法\n\n不使用除号计算除法(整数)\n\nvoid f(int a, int b) {\n    int quotient, remainder;\n    quotient = 0;\n    while (a &gt; b) {\n        quotient++;\n        a -= b;\n    }\n    remainder = a;\n    printf(\"%d, %d\", quotient, remainder);\n}\n\n\n取得数字各位的值的加和\n\n```c\nwhile(x &gt; 0) {\n    y += x % 10;\n    x /= 10;\n}\n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/06/08/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"
      },
    
      {
        "title": "Design Patterns",
        "excerpt": "Nowadays I am studying Design Patterns, making lots of notes to help me understand the important knowledge in this book. and here are them, I try to upload them to my Blog everyday.\n\n#\n",
        "content": "Nowadays I am studying Design Patterns, making lots of notes to help me understand the important knowledge in this book. and here are them, I try to upload them to my Blog everyday.\n\n#\n",
        "url": "/notes/2019/06/10/Design-Patterns/"
      },
    
      {
        "title": "JavaScript - The Definitive Book",
        "excerpt": "This Blog mainly focus on learning JavaScript, I used JavaScript: THe Definitive Book to study JavaScript. Because lots of people call this book JavaScript’s Bible. \nI quickly read 5 chapters of this book, I think JavaScript is much like Java, but still has some differences. I will write down some notes which I think them are so important that I need to remember them, and some difference from other Object-oriented -languages, like Java or even C++.  last update: 19_06_14\n\nDifferent from Java\n\n##\n\n",
        "content": "This Blog mainly focus on learning JavaScript, I used JavaScript: THe Definitive Book to study JavaScript. Because lots of people call this book JavaScript’s Bible. \nI quickly read 5 chapters of this book, I think JavaScript is much like Java, but still has some differences. I will write down some notes which I think them are so important that I need to remember them, and some difference from other Object-oriented -languages, like Java or even C++.  last update: 19_06_14\n\nDifferent from Java\n\n##\n\n",
        "url": "/notes/2019/06/14/JavaScript-The-Definitive-Book/"
      },
    
      {
        "title": "编程学习笔记",
        "excerpt": "一些东西还是用中文总结一下，然后看看有没有可能再用英语写，叹气自己的英语水平。\n\n排序\n\n各种排序在不同情形下的使用场景.\n\n选择\n\n特点\n\n\n  运行时间和原数组数据无关\n  数据移动是所有排序中最少的\n  交换次数和数组的大小成线性相关\n\n\n插入\n\n特点\n\n\n  所需时间与原始数据有关, 元数据的随机性决定了时间所需的长短\n\n\n适用场景\n\n\n  非随机数组很有效\n  部分有序的数据\n\n\n希尔\n\n特点\n\n\n  插入排序的改进版\n  需要确定每个子数组的分段\n\n\n适用场景\n\n\n  可以适用于大型数组, 表现都比较好\n\n\n归并\n\n是分治的排序算法\n\n特点\n\n\n  保证长度为N的数组, 需要花费的时间与NlogN成正比\n  所需要的额外空间和N成正比\n  当数组长度为2的幂时, 2中方式所用的比较方式和访问数组的次数相同, 但是顺序不同.\n  当数组长度 不是 为2的幂时, 2种比较方式和访问数组的次数有所不同,\n\n\n自顶向下\n\n自底向上\n\n特点\n\n\n  比较适合用链表组织的数据\n\n\n快速\n\n是分治的排序算法\n\n定理和命题\n\n\n  \n\n",
        "content": "一些东西还是用中文总结一下，然后看看有没有可能再用英语写，叹气自己的英语水平。\n\n排序\n\n各种排序在不同情形下的使用场景.\n\n选择\n\n特点\n\n\n  运行时间和原数组数据无关\n  数据移动是所有排序中最少的\n  交换次数和数组的大小成线性相关\n\n\n插入\n\n特点\n\n\n  所需时间与原始数据有关, 元数据的随机性决定了时间所需的长短\n\n\n适用场景\n\n\n  非随机数组很有效\n  部分有序的数据\n\n\n希尔\n\n特点\n\n\n  插入排序的改进版\n  需要确定每个子数组的分段\n\n\n适用场景\n\n\n  可以适用于大型数组, 表现都比较好\n\n\n归并\n\n是分治的排序算法\n\n特点\n\n\n  保证长度为N的数组, 需要花费的时间与NlogN成正比\n  所需要的额外空间和N成正比\n  当数组长度为2的幂时, 2中方式所用的比较方式和访问数组的次数相同, 但是顺序不同.\n  当数组长度 不是 为2的幂时, 2种比较方式和访问数组的次数有所不同,\n\n\n自顶向下\n\n自底向上\n\n特点\n\n\n  比较适合用链表组织的数据\n\n\n快速\n\n是分治的排序算法\n\n定理和命题\n\n\n  \n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/06/25/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
      },
    
      {
        "title": "Data Structures and Algorithms",
        "excerpt": "整理一下《数据结构与算法分析 c语言描述 第二版》 （Data structures and algorithm analysis in c）这本书的相关知识点。\n\n\n  recursion 递归\n\n\n一些基本的问题\n\n单独输出整数每个位置上的数\n\nvoid print(int unsigned N)\n{\n    if(N &gt;= 10)\n        print(N / 10);\n    /* 1 */    \n    printf(\"%d\\n\", N % 10);\n}\n\n特别的，% 的开销会比较高， /* 1 */ 处可以使用 \nprintf(\"%d\\n\", N - ((N / 10) * 10));\n\n求最大子序列的和\n\n分治法\n\n//待补充\n\n\n最简单的大O算法\n\nint MaxSubSequence(const int A[], int N)\n{\n    int thisSum, maxSum = 0;\n    for (int i = 0; i &lt; N; i ++)\n    {\n        thisSum = 0;\n        for(int j = i; j &lt; N; j++)\n        {\n            thisSum += A[j];\n            if(thisSum &gt; maxSum)\n                maxSum = thisSum;\n        }\n    }\n    return maxSum;\n}\n\n\n二分搜索\n\n#define NOT_FOUND -1\nint BinarySearch(const float A[], float x, int N)\n{\n    int low = 0;\n    int high = N - 1;\n    \n    while (low &lt;= high) {\n        int mid = (low + high) / 2;\n        if(A[mid] &lt; x)\n            low = mid + 1;\n        else\n            if(A[mid] &gt; x)\n                high = mid - 1;\n            else\n                return mid;\n    }\n    return NOT_FOUND;\n}\n\n\n计算最大公因数 （欧几里得算法）\n\nlong Gcd(long m, long n)\n{\n    long rem;\n    while (n &gt; 0)\n    {\n        rem = m % n;\n        m = n;\n        n = rem;\n    }\n    return m;\n}\n\n\n求幂（优化版）\n\nint Isbool(long x)\n{\n    if(x % 2 == 0)\n        return 1;\n    else\n        return 0;\n}\nlong Pow(long x, long n)\n{\n    if(n == 0)\n        return 1;\n    if(n == 1)\n        return x;\n    if(Isbool(n))\n        return Pow(x * x, n / 2);\n    else\n        return Pow(x * x, n / 2) * x;\n    \n}\n\n\n基本数据结构\n\n链表\n\n\n  Http://\n\n\n##\n\n",
        "content": "整理一下《数据结构与算法分析 c语言描述 第二版》 （Data structures and algorithm analysis in c）这本书的相关知识点。\n\n\n  recursion 递归\n\n\n一些基本的问题\n\n单独输出整数每个位置上的数\n\nvoid print(int unsigned N)\n{\n    if(N &gt;= 10)\n        print(N / 10);\n    /* 1 */    \n    printf(\"%d\\n\", N % 10);\n}\n\n特别的，% 的开销会比较高， /* 1 */ 处可以使用 \nprintf(\"%d\\n\", N - ((N / 10) * 10));\n\n求最大子序列的和\n\n分治法\n\n//待补充\n\n\n最简单的大O算法\n\nint MaxSubSequence(const int A[], int N)\n{\n    int thisSum, maxSum = 0;\n    for (int i = 0; i &lt; N; i ++)\n    {\n        thisSum = 0;\n        for(int j = i; j &lt; N; j++)\n        {\n            thisSum += A[j];\n            if(thisSum &gt; maxSum)\n                maxSum = thisSum;\n        }\n    }\n    return maxSum;\n}\n\n\n二分搜索\n\n#define NOT_FOUND -1\nint BinarySearch(const float A[], float x, int N)\n{\n    int low = 0;\n    int high = N - 1;\n    \n    while (low &lt;= high) {\n        int mid = (low + high) / 2;\n        if(A[mid] &lt; x)\n            low = mid + 1;\n        else\n            if(A[mid] &gt; x)\n                high = mid - 1;\n            else\n                return mid;\n    }\n    return NOT_FOUND;\n}\n\n\n计算最大公因数 （欧几里得算法）\n\nlong Gcd(long m, long n)\n{\n    long rem;\n    while (n &gt; 0)\n    {\n        rem = m % n;\n        m = n;\n        n = rem;\n    }\n    return m;\n}\n\n\n求幂（优化版）\n\nint Isbool(long x)\n{\n    if(x % 2 == 0)\n        return 1;\n    else\n        return 0;\n}\nlong Pow(long x, long n)\n{\n    if(n == 0)\n        return 1;\n    if(n == 1)\n        return x;\n    if(Isbool(n))\n        return Pow(x * x, n / 2);\n    else\n        return Pow(x * x, n / 2) * x;\n    \n}\n\n\n基本数据结构\n\n链表\n\n\n  Http://\n\n\n##\n\n",
        "url": "/notes/2019/07/21/Data-Structures-and-Algorithms/"
      },
    
      {
        "title": "算法竞赛入门经典",
        "excerpt": "算法竞赛入门经典的例题和习题，变种题是自己想的和自己添加的，其他的题目则为书本上选取\n\n第一章\n\n圆柱体表面积\n\n输入底面半径r和高h，输出圆柱体的表面积，保留3位小数\n\n\n  3.5  9\n\n\n\n  Area = 274.889\n\n\ndouble fun(double r, double h) {\n    return (r * r * PI) * 2 + ((PI * 2 * r) * h);\n}\nvoid f_2(void) {\n    double r, h;\n    scanf(\"%lf%lf\", &amp;r, &amp;h);\n    printf(\"Area = %.3lf\", O_1_1(r, h));\n}\n\n// -----------------\n\nvoid f_simple(void) {\n    // one way to get the value of pi\n    const double pi = acos(-1.0);\n    double r, h;\n    scanf(\"%lf%lf\", &amp;r, &amp;h);\n    printf(\"Area = %.3f\", (r * r * pi) * 2 + ((pi * 2 * r) * h));\n}\n\n\n三位数反转\n\n输入一个三位数，分离出他的百位，十位，个位 并输出\n\n\n  127\n\n\n\n  721\n\n\nvoid fun(void) {\n    int n;\n    scanf(\"%d\", &amp;n);\n    printf(\"%d%d%d\", n % 10, n / 10 % 10, n / 100 );\n}\n\n变种一 3位反转后首位为0\n\n首位为0保留\n\n\n  上例代码。\n  转换为字符串。\n\n\n// In Programming language C, it has several methods to convert some types into string.\n// 1. using sprintf\n// 2. using the standard library (itoa)\n\n// in this question, we can know it only has 3 digits, using the sprintf will be the simplest.\n\nvoid swap(char *a, char *b) {\n    char temp = *a;\n    *a = *b;\n    *b = temp;\n}\nvoid fun_2(int num) {\n    char answer[4];\n    // convert to string\n    sprintf(answer,\"%d\", num);\n    swap(&amp;answer[0], &amp;answer[2]);\n    printf(\"%s\", answer);\n}\n\n\n首位为0去除\n\n\n  转换为字符串， 然后输出时判断为0 不输出。\n  将值加和，成为数字。\n\n\nvoid swap(char *a, char *b) {\n    char temp = *a;\n    *a = *b;\n    *b = temp;\n}\nvoid f_2_1(int num) {\n    char answer[4];\n    // convert to string\n    sprintf(answer,\"%d\", num);\n    swap(&amp;answer[0], &amp;answer[2]);\n    for(int i = 0; i != 4; i++)\n        if(answer[i] != '0')\n            printf(\"%c\", answer[i]);\n}\n\nvoid f_2_2(int num) {\n    int answer = (num % 10) * 100 + (n / 10 % 10) * 10 + (n / 100);\n    printf(\"%d\",answer);\n}\n\n变种二 任意位数的值都反转\n\n首位为0保留\n\n\n  转换为字符串\nBecause we don’t know how many digits we need to use, we can’t use sprintf\n\n\n首位为0去除\n\n交换变量\n\n输入两个整数a和b，交换2者的值\n\n\n  824 16\n\n\n\n  16 824\n\n\n最简单的, 3个变量交换方式.\n\n变种一 任意基本变量都交换\n\n传递另外的参数, 使用switch 确定 基本变量的类型.\n\nenum types {\n    Int, Double, Float\n};\n\nvoid swap_int(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid swap_double(double* a, double* b) {\n    double temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid swap(void* a, void* b, enum types type) {\n   \n    switch (type) {\n    case Int:\n        swap_int((int*)a, (int*)b);\n        break;\n    case Double:\n        swap_double((double*)a, (double*)b);\n        break;\n    }\n}\n\n\n鸡兔同笼\n\n已经鸡和兔的总数量为n，总腿数为m， 输入n和m，以此输出鸡和兔的数目，如果无解，则输出no answer.\n\n\n  14 32\n\n\n\n  12 2\n\n\n// 略\n\n三整数排序\n\n输入3个整数，从小到大排序后输出\n\n\n  20 7 33\n\n\n\n  7 20 33\n\n\n特别的，本题意在给出数据量固定，且比较少的特殊情况下 可以直接暴力输出.\n\n第二章\n\n形如aabb的4位完全平方数(即前两位数字相等, 后两位数学也相等)\n\n\n  1122\n\n\n枚举,然后判断\n\n枚举方式\n\n\n  枚举每个数符合aabb,然后判断是否是完全平方数\n  枚举每个数平方后判断是否为aabb\n\n\n3n +１\n\n任意大于1的自然数,若n为奇数, 则将n变为3n + 1, 否则将变为n的一半,经过这样的若干次变换,一定会使n变为1. 例如3 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\n\n输入n,输出变换的次数.\n\n\n  3\n7\n\n\nint fun(int n) {\n    int index = 0;\n    while (n != 1) {\n        if (n % 2 == 1) {\n            n = 3 * n + 1;\n        }\n        else {\n            n /= 2;\n        }\n        index++;\n    }\n    return index;\n}\n\n\n近似计算\n\n计算pi/4 = 1 - 1/3 + 1/5 - 1/7 + …  直到最后一项小于10e-6\n\ndouble fun(void) {\n    double sum = 0;\n    double item;\n    for (int i = 0; ; i++) {\n        item = 1.0 / (i * 2 + 1);\n        if (i % 2) {\n            sum -= item;\n        }\n        else {\n            sum += item;\n        }\n        if (item &lt; 1e-6)\n            break;\n    }\n    return sum; \n}\n\n\n阶乘之和\n\n输入n, 计算S = 1! + 2! + 3! + …. + n! 的末6位(不含前导0). n &lt;= 1e6\n\n\n  10\n37913\n\n\n\n  只计算末尾6位 (因为只需要末尾的6位,可以只用考虑末尾6位的情况, 防止溢出的可能)\n  全部计算,最后取出6位数据,因为该式为阶乘,所以很大概率会溢出\n\n\n特别的 25! 末尾有6个0, 所以后面的加和不会影响数据的结果. \nif(n &gt; 25) n = 25;\n\nint fun(int n) {\n    if (n &gt; 25)\n        n = 25;\n    int sum = 0;\n    int temp;\n    for (int i = 1; i &lt;= n; i++) {\n        temp = 1;\n        for (int j = 1; j &lt;= i; j++) {\n            temp = j * temp % 1000000;\n        }\n        sum = (sum + temp) % 1000000;  \n    }\n    return sum;\n}\n\n\n数据统计\n\n输入一些整数, 求出它们的最小值,最大值和平均值(保留3位小数) 保证不超过1000的整数\n\n变种 不作任何限制,产生溢出的情况下\n\n自己实现相关的数据结构和运算(考虑到溢出的情况)\n\n\n  简单: 利用字符串完成所有的操作\n  比较难: 位运算\n\n\n第三章\n\n开灯问题\n有n盏灯,编号1-n, 第1个人把所有的灯打开, 第二个人按下所有编号为2的倍数的开关, 第三个人按下所有编号为3的倍数的开关. 以此类推, 一共有k个人,最后哪些灯开着?\n\n\n  7 3\n1 5 6 7\n\n\nvoid fun(int n, int k) {\n    // 灯的个数以1开头,为了不进行加减运算, 直接创建的时候,浪费了0下标的元素\n    int* p = (int*)malloc(sizeof(int) * n + 1);\n   \n    for (int i = 0; i &lt;= n; i++) {\n        p[i] = 1;\n    }\n    p[0] = 0; \n    for (int i = 1; i &lt;= k; i++) {\n        if (i != 1) {\n            int temp = 1;\n            for (int j = i; j &lt;= n;) {\n                j = temp * i;\n                p[j] = !p[j];\n                temp++;\n            }\n        }\n    }\n    for (int i = 0; i &lt;= n; i++)\n        if (p[i] == 1)\n            printf(\"%d \", i);\n}\n\n\n蛇形填数\n\n在n * n 的方阵中填成蛇形, 1, 2, 3….\n\n\n  10 11 12 1\n9  16 13 2\n8  15 14 3\n7  6  5  4\n\n\n可以判断相应位置, 和周围是否已经被填入数字(先用0 填满整个数组)\n\nx = 0;\ny = n - 1;\ntot = a[x][y] = 1;\nwhile(tot &lt; n * n) {\n    while(x + 1 &lt; n &amp;&amp; !a[x + 1][y])\n        a[++x][y] = ++tot;\n    while(y - 1 &gt;= 0 &amp;&amp; !a[x][y-1])\n        a[x][--y] = ++tot;\n    while(x - 1 &gt;= 0 &amp;&amp; !a[x - 1][y])\n        a[--x][y] = ++tot;\n    while(y + 1 &lt; n &amp;&amp; !a[x][y + 1])\n        a[x][++y] = ++tot;\n}\n\n\n自己实现的:\nvoid fun(int n)\n{\n    int** matrix = (int**)malloc(sizeof(int*) * n);\n    for (int i = 0; i != n; i++)\n        matrix[i] = (int*)malloc(sizeof(int) * n);\n    int x;\n    int y;\n    int index = 1;\n    int round = 1;\n    while (index &lt; n * n) {\n        x = round - 1; \n        y = n - round; \n        while (x &lt; n - round &amp;&amp; index &lt;= n * n)\n            matrix[x++][y] = index++;\n        while (y &gt;  round - 1 &amp;&amp; index &lt;= n * n)\n            matrix[x][y--] = index++;    \n        while (x &gt; round - 1 &amp;&amp; index &lt;= n * n)\n            matrix[x--][y] = index++;\n        while (y &lt; n - round &amp;&amp; index &lt;= n * n)\n            matrix[x][y++] = index++;\n        round++; \n    }\n    if (n % 2)\n        matrix[++x][--y] = index;\n    for (int i = 0; i != n; i++) {\n        for (int j = 0; j != n; j++)\n            printf(\"%3d \", matrix[i][j]);\n        putchar('\\n');\n    }\n}\n\n猴子排位\n\n题目内容：n只猴子（n&lt;100）要选大王，选举方法如下：所有猴子按1,2,3,……, n编号围坐一圈，从第1号开始按照1,2,……, m报数，凡报到m号的退出圈外，如此循环报数，直到圈内剩下一只猴子时，这只猴子就是大王。编程一个程序实现上述过程，n和m由键盘输入。\n\n\n  5 3\n3 1 5 2 4\n\n\nvoid fun(int n, int k) {\n    int* p = (int*)malloc(sizeof(int) * n);\n    for (int i = 0; i != n; i++)\n        p[i] = i + 1;\n    int temp = 1;\n    \n    int out_number = 0;\n    for (int i = 0;; ) {\n        if (p[i] != -1) {\n            if (temp == k) {\n                printf(\"%d \", p[i]);\n                temp = 0;\n                p[i] = -1;\n                out_number++;             \n            }\n            temp++;\n        }\n   \n        if (out_number == n - 1)\n            break;\n        i++;\n        i %= n;\n    }\n    for (int i = 0; i != n; i++)\n        if (p[i] != -1)\n            printf(\"%d\", p[i]);\n}\n\n\n竖式问题\n\n输入一些数字, 利用这些数字生成 abc * bc 的竖式. 要求中间的每个步骤生成的数,都必须在输入的数字范围内. 并根据有多少解,输出相应的竖式. 若不存在,输出不存在.\n\nint x = abc * (de % 10), y = abc * (de / 10), z = abc * de;\nsprintf(buf, \"%d%d%d%d%d\", abc, de, x, y, z);\n\n以此判读buf中的数是否在输入的范围之中. 使用strchr 函数\n\nTeX中的引号\n\n将双引号转换为其他字符\n\n用一个变量保存状态就可以\n\nint status = 1;\nif(c == '\"') {\n    printf(\"%s\", status ? \"-\", \"+\");\n    status = !status;\n}\nelse\n    printf(\"%c\", c);\n\n\n错位键盘\n\n输入一个顺序错误的字符串, 每一个字符都依照键盘位置向右边一位.\n输出一个顺序正确的字符串\n\n建立表,查找\n\n回文词和镜像\n\n判断一个字符串是回文词和镜像串\n\n建立表,查找\n\n猜数字\n\n生成元\n\n环状序列\n",
        "content": "算法竞赛入门经典的例题和习题，变种题是自己想的和自己添加的，其他的题目则为书本上选取\n\n第一章\n\n圆柱体表面积\n\n输入底面半径r和高h，输出圆柱体的表面积，保留3位小数\n\n\n  3.5  9\n\n\n\n  Area = 274.889\n\n\ndouble fun(double r, double h) {\n    return (r * r * PI) * 2 + ((PI * 2 * r) * h);\n}\nvoid f_2(void) {\n    double r, h;\n    scanf(\"%lf%lf\", &amp;r, &amp;h);\n    printf(\"Area = %.3lf\", O_1_1(r, h));\n}\n\n// -----------------\n\nvoid f_simple(void) {\n    // one way to get the value of pi\n    const double pi = acos(-1.0);\n    double r, h;\n    scanf(\"%lf%lf\", &amp;r, &amp;h);\n    printf(\"Area = %.3f\", (r * r * pi) * 2 + ((pi * 2 * r) * h));\n}\n\n\n三位数反转\n\n输入一个三位数，分离出他的百位，十位，个位 并输出\n\n\n  127\n\n\n\n  721\n\n\nvoid fun(void) {\n    int n;\n    scanf(\"%d\", &amp;n);\n    printf(\"%d%d%d\", n % 10, n / 10 % 10, n / 100 );\n}\n\n变种一 3位反转后首位为0\n\n首位为0保留\n\n\n  上例代码。\n  转换为字符串。\n\n\n// In Programming language C, it has several methods to convert some types into string.\n// 1. using sprintf\n// 2. using the standard library (itoa)\n\n// in this question, we can know it only has 3 digits, using the sprintf will be the simplest.\n\nvoid swap(char *a, char *b) {\n    char temp = *a;\n    *a = *b;\n    *b = temp;\n}\nvoid fun_2(int num) {\n    char answer[4];\n    // convert to string\n    sprintf(answer,\"%d\", num);\n    swap(&amp;answer[0], &amp;answer[2]);\n    printf(\"%s\", answer);\n}\n\n\n首位为0去除\n\n\n  转换为字符串， 然后输出时判断为0 不输出。\n  将值加和，成为数字。\n\n\nvoid swap(char *a, char *b) {\n    char temp = *a;\n    *a = *b;\n    *b = temp;\n}\nvoid f_2_1(int num) {\n    char answer[4];\n    // convert to string\n    sprintf(answer,\"%d\", num);\n    swap(&amp;answer[0], &amp;answer[2]);\n    for(int i = 0; i != 4; i++)\n        if(answer[i] != '0')\n            printf(\"%c\", answer[i]);\n}\n\nvoid f_2_2(int num) {\n    int answer = (num % 10) * 100 + (n / 10 % 10) * 10 + (n / 100);\n    printf(\"%d\",answer);\n}\n\n变种二 任意位数的值都反转\n\n首位为0保留\n\n\n  转换为字符串\nBecause we don’t know how many digits we need to use, we can’t use sprintf\n\n\n首位为0去除\n\n交换变量\n\n输入两个整数a和b，交换2者的值\n\n\n  824 16\n\n\n\n  16 824\n\n\n最简单的, 3个变量交换方式.\n\n变种一 任意基本变量都交换\n\n传递另外的参数, 使用switch 确定 基本变量的类型.\n\nenum types {\n    Int, Double, Float\n};\n\nvoid swap_int(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid swap_double(double* a, double* b) {\n    double temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid swap(void* a, void* b, enum types type) {\n   \n    switch (type) {\n    case Int:\n        swap_int((int*)a, (int*)b);\n        break;\n    case Double:\n        swap_double((double*)a, (double*)b);\n        break;\n    }\n}\n\n\n鸡兔同笼\n\n已经鸡和兔的总数量为n，总腿数为m， 输入n和m，以此输出鸡和兔的数目，如果无解，则输出no answer.\n\n\n  14 32\n\n\n\n  12 2\n\n\n// 略\n\n三整数排序\n\n输入3个整数，从小到大排序后输出\n\n\n  20 7 33\n\n\n\n  7 20 33\n\n\n特别的，本题意在给出数据量固定，且比较少的特殊情况下 可以直接暴力输出.\n\n第二章\n\n形如aabb的4位完全平方数(即前两位数字相等, 后两位数学也相等)\n\n\n  1122\n\n\n枚举,然后判断\n\n枚举方式\n\n\n  枚举每个数符合aabb,然后判断是否是完全平方数\n  枚举每个数平方后判断是否为aabb\n\n\n3n +１\n\n任意大于1的自然数,若n为奇数, 则将n变为3n + 1, 否则将变为n的一半,经过这样的若干次变换,一定会使n变为1. 例如3 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\n\n输入n,输出变换的次数.\n\n\n  3\n7\n\n\nint fun(int n) {\n    int index = 0;\n    while (n != 1) {\n        if (n % 2 == 1) {\n            n = 3 * n + 1;\n        }\n        else {\n            n /= 2;\n        }\n        index++;\n    }\n    return index;\n}\n\n\n近似计算\n\n计算pi/4 = 1 - 1/3 + 1/5 - 1/7 + …  直到最后一项小于10e-6\n\ndouble fun(void) {\n    double sum = 0;\n    double item;\n    for (int i = 0; ; i++) {\n        item = 1.0 / (i * 2 + 1);\n        if (i % 2) {\n            sum -= item;\n        }\n        else {\n            sum += item;\n        }\n        if (item &lt; 1e-6)\n            break;\n    }\n    return sum; \n}\n\n\n阶乘之和\n\n输入n, 计算S = 1! + 2! + 3! + …. + n! 的末6位(不含前导0). n &lt;= 1e6\n\n\n  10\n37913\n\n\n\n  只计算末尾6位 (因为只需要末尾的6位,可以只用考虑末尾6位的情况, 防止溢出的可能)\n  全部计算,最后取出6位数据,因为该式为阶乘,所以很大概率会溢出\n\n\n特别的 25! 末尾有6个0, 所以后面的加和不会影响数据的结果. \nif(n &gt; 25) n = 25;\n\nint fun(int n) {\n    if (n &gt; 25)\n        n = 25;\n    int sum = 0;\n    int temp;\n    for (int i = 1; i &lt;= n; i++) {\n        temp = 1;\n        for (int j = 1; j &lt;= i; j++) {\n            temp = j * temp % 1000000;\n        }\n        sum = (sum + temp) % 1000000;  \n    }\n    return sum;\n}\n\n\n数据统计\n\n输入一些整数, 求出它们的最小值,最大值和平均值(保留3位小数) 保证不超过1000的整数\n\n变种 不作任何限制,产生溢出的情况下\n\n自己实现相关的数据结构和运算(考虑到溢出的情况)\n\n\n  简单: 利用字符串完成所有的操作\n  比较难: 位运算\n\n\n第三章\n\n开灯问题\n有n盏灯,编号1-n, 第1个人把所有的灯打开, 第二个人按下所有编号为2的倍数的开关, 第三个人按下所有编号为3的倍数的开关. 以此类推, 一共有k个人,最后哪些灯开着?\n\n\n  7 3\n1 5 6 7\n\n\nvoid fun(int n, int k) {\n    // 灯的个数以1开头,为了不进行加减运算, 直接创建的时候,浪费了0下标的元素\n    int* p = (int*)malloc(sizeof(int) * n + 1);\n   \n    for (int i = 0; i &lt;= n; i++) {\n        p[i] = 1;\n    }\n    p[0] = 0; \n    for (int i = 1; i &lt;= k; i++) {\n        if (i != 1) {\n            int temp = 1;\n            for (int j = i; j &lt;= n;) {\n                j = temp * i;\n                p[j] = !p[j];\n                temp++;\n            }\n        }\n    }\n    for (int i = 0; i &lt;= n; i++)\n        if (p[i] == 1)\n            printf(\"%d \", i);\n}\n\n\n蛇形填数\n\n在n * n 的方阵中填成蛇形, 1, 2, 3….\n\n\n  10 11 12 1\n9  16 13 2\n8  15 14 3\n7  6  5  4\n\n\n可以判断相应位置, 和周围是否已经被填入数字(先用0 填满整个数组)\n\nx = 0;\ny = n - 1;\ntot = a[x][y] = 1;\nwhile(tot &lt; n * n) {\n    while(x + 1 &lt; n &amp;&amp; !a[x + 1][y])\n        a[++x][y] = ++tot;\n    while(y - 1 &gt;= 0 &amp;&amp; !a[x][y-1])\n        a[x][--y] = ++tot;\n    while(x - 1 &gt;= 0 &amp;&amp; !a[x - 1][y])\n        a[--x][y] = ++tot;\n    while(y + 1 &lt; n &amp;&amp; !a[x][y + 1])\n        a[x][++y] = ++tot;\n}\n\n\n自己实现的:\nvoid fun(int n)\n{\n    int** matrix = (int**)malloc(sizeof(int*) * n);\n    for (int i = 0; i != n; i++)\n        matrix[i] = (int*)malloc(sizeof(int) * n);\n    int x;\n    int y;\n    int index = 1;\n    int round = 1;\n    while (index &lt; n * n) {\n        x = round - 1; \n        y = n - round; \n        while (x &lt; n - round &amp;&amp; index &lt;= n * n)\n            matrix[x++][y] = index++;\n        while (y &gt;  round - 1 &amp;&amp; index &lt;= n * n)\n            matrix[x][y--] = index++;    \n        while (x &gt; round - 1 &amp;&amp; index &lt;= n * n)\n            matrix[x--][y] = index++;\n        while (y &lt; n - round &amp;&amp; index &lt;= n * n)\n            matrix[x][y++] = index++;\n        round++; \n    }\n    if (n % 2)\n        matrix[++x][--y] = index;\n    for (int i = 0; i != n; i++) {\n        for (int j = 0; j != n; j++)\n            printf(\"%3d \", matrix[i][j]);\n        putchar('\\n');\n    }\n}\n\n猴子排位\n\n题目内容：n只猴子（n&lt;100）要选大王，选举方法如下：所有猴子按1,2,3,……, n编号围坐一圈，从第1号开始按照1,2,……, m报数，凡报到m号的退出圈外，如此循环报数，直到圈内剩下一只猴子时，这只猴子就是大王。编程一个程序实现上述过程，n和m由键盘输入。\n\n\n  5 3\n3 1 5 2 4\n\n\nvoid fun(int n, int k) {\n    int* p = (int*)malloc(sizeof(int) * n);\n    for (int i = 0; i != n; i++)\n        p[i] = i + 1;\n    int temp = 1;\n    \n    int out_number = 0;\n    for (int i = 0;; ) {\n        if (p[i] != -1) {\n            if (temp == k) {\n                printf(\"%d \", p[i]);\n                temp = 0;\n                p[i] = -1;\n                out_number++;             \n            }\n            temp++;\n        }\n   \n        if (out_number == n - 1)\n            break;\n        i++;\n        i %= n;\n    }\n    for (int i = 0; i != n; i++)\n        if (p[i] != -1)\n            printf(\"%d\", p[i]);\n}\n\n\n竖式问题\n\n输入一些数字, 利用这些数字生成 abc * bc 的竖式. 要求中间的每个步骤生成的数,都必须在输入的数字范围内. 并根据有多少解,输出相应的竖式. 若不存在,输出不存在.\n\nint x = abc * (de % 10), y = abc * (de / 10), z = abc * de;\nsprintf(buf, \"%d%d%d%d%d\", abc, de, x, y, z);\n\n以此判读buf中的数是否在输入的范围之中. 使用strchr 函数\n\nTeX中的引号\n\n将双引号转换为其他字符\n\n用一个变量保存状态就可以\n\nint status = 1;\nif(c == '\"') {\n    printf(\"%s\", status ? \"-\", \"+\");\n    status = !status;\n}\nelse\n    printf(\"%c\", c);\n\n\n错位键盘\n\n输入一个顺序错误的字符串, 每一个字符都依照键盘位置向右边一位.\n输出一个顺序正确的字符串\n\n建立表,查找\n\n回文词和镜像\n\n判断一个字符串是回文词和镜像串\n\n建立表,查找\n\n猜数字\n\n生成元\n\n环状序列\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/08/06/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/"
      },
    
      {
        "title": "Tips on C",
        "excerpt": "This blog is talking about the tips about C which i think are most important.\n\nCovert to String\n\n##\n\nint main() {\n    printf(\"test\");\n}\n\n\n",
        "content": "This blog is talking about the tips about C which i think are most important.\n\nCovert to String\n\n##\n\nint main() {\n    printf(\"test\");\n}\n\n\n",
        "url": "/notes/2019/10/31/Tips-on-C/"
      },
    
      {
        "title": "杂项",
        "excerpt": "作为个人不知道如何分类的一些反思和总结。\n\n总结\n\n封装\n\n主要的原因是为了编程简单，比如说，一段重复的操作，或者重复的结构，可以通过封装对程序进行简化处理，只需要在某次编写好相关的函数，或者类，通过调用或者继承，将大大减少开发的时间。同时在修改时，也会变得更为简单。（只需要修改一处，其余的部分都会随之更改。), 同时。如果有写有细微的改动，此时，可以使用各种语言提供的，比如虚函数，抽象函数，对相应的实现进行针对化的封装。\n\nTry-Catch\n\n对程序要有相应的错误处理。需要有出错文件，出错行号（可选）， 出错函数，或者是确认用的信息。\n确认需要是否需去自己实现相关的功能，相关的语言中是否有提供相应的类。 如果实现的话，有几个问题：\n\n\n  如何确定行号，（c语言可以简单实现，其他的好像比较复杂）\n  如何确定函数名，自动确定。（被包括的函数？程序的API？）\n  出错的源文件\n\n\n正式上线的时候不需要清空log文件。\n\n设计模式\n\n相应的，先要去确认一下\n\n\n  错误如何处理，是否要留有记录，出错后应该如何操作。\n  这里是业务逻辑。\n  结束处理。确认结束后应该出现什么样子的提示，或者发送邮件。\n  用户体验。\n\n\nclass -&gt;  方法 -&gt; 变量 （注意各种变量的保护级别，相应的处理。）\n\n学习：\n\nDo the test————–&gt;get wrong or do not understand\n      |                                 |\n      |                                 |\n      +read the book and get understand +\n\ndesign and code———-&gt;get wrong or do not understand\n      |                                  |\n    redesign                             |\n      |                                  |\n      + read the book and get understand +\n\n设计的HR系统。\n可以使用数据库和excel 对公司进行管理。首先设计一个完整的成品。然后在对具体的逻辑抽取形成框架。\n\n具体要学习的，注册多个github账号，然后练习使用git的分支管理。\n一开始使用操作excel 接口的C# 来制作。\n然后抽成框架后，对该系统进行移植。以达到基础的编程练习。\n\n所以要做到：\n\n\n  操作SQL （增删查改， 初始化新表）\n  操作excel （增删查改， 初始化新EXCEL)\n  练习多线程\n  设计简单的UI\n  发送邮件 （建立简单的邮件服务器。能够理解邮件协议）\n\n\n其次，制作微信小程序。\n学习制作。具体情况做情况讨论。\n\n比较2个相同结构的datatable new 和 old，并从new中删除old的数据\n\n我的主要思路如下：\n使用.NET 提供的 Merge 方法。\n\n\n  先将2个datatable设置主键。\n  然后在New 中添加一个flag column，并设置默认值。\n  使用Merge方法\n  Select New 这个datatable，并删除flag column中值为空的行。\n\n\nstatic DataTable CompareAndDelete(DataTable dtNew, DataTable dtOld)\n{\n    // DataTable has only 2 columns\n    dtNew.PrimaryKey = new DataColumn[]{ dtNew.Columns[0], dtNew.Columns[1]};\n    dtOld.PrimaryKey = new DataColumn[] { dtOld.Columns[0], dtOld.Columns[1] };\n\n    DataColumn column;\n    column = new DataColumn();\n    column.DataType = System.Type.GetType(\"System.String\");\n    column.ColumnName = \"Flag\";\n\n    dtNew.Columns.Add(column);\n    dtNew.Merge(dtOld);\n    dtNew.Select(\"[Flag] = ''\");\n\n    foreach(DataRow row in dtNew.Rows)\n    {\n        row.Delete();\n    }\n    return dtNew;\n}\n\n\n奇怪的错误\n\n在使用dataTable的select时，发现了奇怪的问题。\n\nDataTable Name = new DataTable();\nName.Columns.Add(\"Test\");\nName.Columns.Add(\"TestA\");\nName.Rows.Add(new object[] { 1, \"2\" });\n// 2 处的select 都会为匹配得到。\nint intCountNoSpace = Name.Select(\"[Test] = '1'\").Count();\nint intCountWithSpace = Name.Select(\"[Test] = '1 '\").Count();\n\n// 如果添加如下代码：\nName.Columns[\"Test\"].DataType = System.Type.GetType(\"System.Int32\");\n// 则只有noSpace会被匹配得到\nint intCountNoSpace = Name.Select(\"[Test] = '1'\").Count();\nint intCountWithSpace = Name.Select(\"[Test] = '1 '\").Count();\n\n\n所以在使用select时，要先确认该列数据的类型，然后再做判断。如果为默认的objecct类型会默认使用字符串的匹配方式。需要十分的注意。\n\n函数调用方式\n\n如 题目要求 n = m 时函数中止, 此时我推荐将改判断条件放置在调用该函数的地方进行实现\n\nvoid myfun(int n, int m) {\n  //\n}\n\nvoid f() {\n  if(n == m) \n    ;\n  else\n    myfun(n, m)\n}\n\n此时,能极大的提高相关的编程效率,不用考虑什么时候需要停止,在myfun 中也不需要做过多的判断. 提高了代码可读性.\n\n",
        "content": "作为个人不知道如何分类的一些反思和总结。\n\n总结\n\n封装\n\n主要的原因是为了编程简单，比如说，一段重复的操作，或者重复的结构，可以通过封装对程序进行简化处理，只需要在某次编写好相关的函数，或者类，通过调用或者继承，将大大减少开发的时间。同时在修改时，也会变得更为简单。（只需要修改一处，其余的部分都会随之更改。), 同时。如果有写有细微的改动，此时，可以使用各种语言提供的，比如虚函数，抽象函数，对相应的实现进行针对化的封装。\n\nTry-Catch\n\n对程序要有相应的错误处理。需要有出错文件，出错行号（可选）， 出错函数，或者是确认用的信息。\n确认需要是否需去自己实现相关的功能，相关的语言中是否有提供相应的类。 如果实现的话，有几个问题：\n\n\n  如何确定行号，（c语言可以简单实现，其他的好像比较复杂）\n  如何确定函数名，自动确定。（被包括的函数？程序的API？）\n  出错的源文件\n\n\n正式上线的时候不需要清空log文件。\n\n设计模式\n\n相应的，先要去确认一下\n\n\n  错误如何处理，是否要留有记录，出错后应该如何操作。\n  这里是业务逻辑。\n  结束处理。确认结束后应该出现什么样子的提示，或者发送邮件。\n  用户体验。\n\n\nclass -&gt;  方法 -&gt; 变量 （注意各种变量的保护级别，相应的处理。）\n\n学习：\n\nDo the test————–&gt;get wrong or do not understand\n      |                                 |\n      |                                 |\n      +read the book and get understand +\n\ndesign and code———-&gt;get wrong or do not understand\n      |                                  |\n    redesign                             |\n      |                                  |\n      + read the book and get understand +\n\n设计的HR系统。\n可以使用数据库和excel 对公司进行管理。首先设计一个完整的成品。然后在对具体的逻辑抽取形成框架。\n\n具体要学习的，注册多个github账号，然后练习使用git的分支管理。\n一开始使用操作excel 接口的C# 来制作。\n然后抽成框架后，对该系统进行移植。以达到基础的编程练习。\n\n所以要做到：\n\n\n  操作SQL （增删查改， 初始化新表）\n  操作excel （增删查改， 初始化新EXCEL)\n  练习多线程\n  设计简单的UI\n  发送邮件 （建立简单的邮件服务器。能够理解邮件协议）\n\n\n其次，制作微信小程序。\n学习制作。具体情况做情况讨论。\n\n比较2个相同结构的datatable new 和 old，并从new中删除old的数据\n\n我的主要思路如下：\n使用.NET 提供的 Merge 方法。\n\n\n  先将2个datatable设置主键。\n  然后在New 中添加一个flag column，并设置默认值。\n  使用Merge方法\n  Select New 这个datatable，并删除flag column中值为空的行。\n\n\nstatic DataTable CompareAndDelete(DataTable dtNew, DataTable dtOld)\n{\n    // DataTable has only 2 columns\n    dtNew.PrimaryKey = new DataColumn[]{ dtNew.Columns[0], dtNew.Columns[1]};\n    dtOld.PrimaryKey = new DataColumn[] { dtOld.Columns[0], dtOld.Columns[1] };\n\n    DataColumn column;\n    column = new DataColumn();\n    column.DataType = System.Type.GetType(\"System.String\");\n    column.ColumnName = \"Flag\";\n\n    dtNew.Columns.Add(column);\n    dtNew.Merge(dtOld);\n    dtNew.Select(\"[Flag] = ''\");\n\n    foreach(DataRow row in dtNew.Rows)\n    {\n        row.Delete();\n    }\n    return dtNew;\n}\n\n\n奇怪的错误\n\n在使用dataTable的select时，发现了奇怪的问题。\n\nDataTable Name = new DataTable();\nName.Columns.Add(\"Test\");\nName.Columns.Add(\"TestA\");\nName.Rows.Add(new object[] { 1, \"2\" });\n// 2 处的select 都会为匹配得到。\nint intCountNoSpace = Name.Select(\"[Test] = '1'\").Count();\nint intCountWithSpace = Name.Select(\"[Test] = '1 '\").Count();\n\n// 如果添加如下代码：\nName.Columns[\"Test\"].DataType = System.Type.GetType(\"System.Int32\");\n// 则只有noSpace会被匹配得到\nint intCountNoSpace = Name.Select(\"[Test] = '1'\").Count();\nint intCountWithSpace = Name.Select(\"[Test] = '1 '\").Count();\n\n\n所以在使用select时，要先确认该列数据的类型，然后再做判断。如果为默认的objecct类型会默认使用字符串的匹配方式。需要十分的注意。\n\n函数调用方式\n\n如 题目要求 n = m 时函数中止, 此时我推荐将改判断条件放置在调用该函数的地方进行实现\n\nvoid myfun(int n, int m) {\n  //\n}\n\nvoid f() {\n  if(n == m) \n    ;\n  else\n    myfun(n, m)\n}\n\n此时,能极大的提高相关的编程效率,不用考虑什么时候需要停止,在myfun 中也不需要做过多的判断. 提高了代码可读性.\n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/01/Small-Tips/"
      },
    
      {
        "title": "study of C",
        "excerpt": "综述\n\n  文献摘录\n  C其他展开\n  extern 变量 &amp; 函数\n  指针\n  指针和数组\n  const的含义\n  const与指针结合\n  使用Typeof提升可读性\n  为什么要封装成函数\n  全部功能写在main里有什么坏处\n  封装函数时会出现什么困难\n  宏\n\n\n备注 每日一更 +代表更新 -代表还在占坑中（没有内容暂待更新）\n更新内容：\n\n\n  C其他展开\n  \n    \n      数组\n    \n  \n\n\n\n\n文献摘录\n\n\n  摘自 你必须知道的495个C语言问题\n\n\nQA\n\nQ：如何生成“半全局变量” （部分源文件中部分函数可以访问的变量）\nA: C语言办不到。但是实在要做的话：\n\n\n  为一个库或相关函数的集合中的所有函数和全局变量加一个唯一的前缀。并用文字警告，使用该集合的用户不能定义和使用文档列出的公用符合意外的任何带有前缀的其他符号。\n  使用下划线命名。\n\n\n作用域\n\n标识声明的有效区域：\n\n\n  函数\n  文件\n  块\n  原型\n\n\n命名空间\n\n\n  行标（label，goto的目的地）\n  标签（tag，struct，union和enum的名称&lt;-这3种命名空间不相互独立）\n  struct/union的成员\n  普通标识符（函数，变量，类型定义，枚举常量）\n\n\n链接类型\n\n\n  外部链接（全局，非静态变量和函数）\n  内部链接（仅限于文件作用域内的静态函数和变量）\n  无链接（举办变量和类型定义（typedef）名称，枚举常量\n\n\nC其他展开\n\n数组\n\n在创建一个数组的时，有时需要去创建2维甚至是多维的数组，但是往往需要动态的生成。那么可以给出一个简单的方法。\n一下例子是用c++ 实现，但是思路相同。主要的思路就是，通过创建一长串的一维数组，模拟二维数组的操作，比如你要访问相应的数组长度，可以使用数组的计算方法，在一维数组中快速的找到相应的元素，同时减少了循环的次数。（如果动态实现，则会减少一个*。 在编程中如果条件允许，可以使用这种方式提高编程效率。（因为C，c++ 本身并不是真的存在高于一维的数据结构。都是模拟的进行操作。（即，都是开辟线性的内存块，我不知道这种编程方式是否会有真正的性能提升。虽然减少了一层的循环。）为了不要成为优化神教， 还是需要对具体情况进行具体的分析。\n\nint intNumber;\n    cin &gt;&gt; intNumber;\n    int *intArray = new int[intNumber * intNumber];\n\n    for (int i = 0; i != (intNumber * intNumber); i++)\n    {\n        cin &gt;&gt; intArray[i];\n    }\n    for (int i = 0,j = 1; i != (intNumber * intNumber); i++, j++)\n    {\n        cout &lt;&lt; intArray[i] &lt;&lt; \" \";\n        if (j == intNumber)\n        {\n            cout &lt;&lt; endl;\n            // 为什么这里是0？读者自己思考\n            j = 0;\n        }\n    }\n\n\n结构体比较\n\n不能使用 == 和 ！= 比较结构体，简单的按字节比较的方法会遇到结构体中没有使用的内存空间（洞）的随机内容和失败。这里的洞是用来补位，以便后续成员对齐的\n如果需要比较，需要自己写函数，按域比较。\n\n未定义\n\n// bad code 1\na[i] = i++;\n// bad code 2\nint i = 7;\nprintf(\"%d\\n\", i++ * i++);\n\n\n诸如此类代码是未定义的，千万不要使用。\n\nint f()\nint h()\nint g()\n\nf() + (g() * h())\n\n\n如上代码也不会改变函数的调用顺序。同理：\n\n(i++) * (i++)\n\n\n有没有括号都是未定义的。\n\n短路\n\n可以假定：\n一旦&amp;&amp;和|| 左边 的表达式已经决定了整个表达式的结果，那么右边的表达式一定不会被求职\n\n序列点\n\n序列点是一个时间点，所有的副作用都应该保证结束。\n在上一个和下一个序列点之间，一个对象所保存的值至多只能被表达式修改 一次 ，而且只有在确定将要保存的值的时候才能访问之前的一个值。\nC语言标准提及的序列点包括：\n\n\n  完整的表达式尾部（表达式语句完成。并且该表达式不是其他表达式的子语句存在）\n  \n    \n      \n        \n          &amp;&amp;、\n           \n          、?: 、, 操作处\n        \n      \n    \n  \n  函数调用时（参数已经被求值完毕，函数在被实际调用之前）\n\n\n声明和定义\n\nC系列的语言中，要严格分清，定义和声明的区别。其实也很简单：\n\n// 这是声明\nint f();\n\n\n// 上面还有很多的code\n// 这是定义\nint f()\n{\n    return 0;\n}\n\n\n// 这是申明和定义\nint f()\n{\n    return 0;\n}\n\n\nC语言中，一般来说，定义只能一次。在同一作用空间之中\n在希望多个源文件中共享变量或函数的时候，需要确保声明和定义的一致性，（如果有同名的函数或者是变量，在编译的时候不会报错，但是在链接的时候会link失败的错误。这时应该检查是否有变量重名 ）\n在.h 和.c文件中，其实相关的处理没有区别。仅仅是在使用的时候，以便编译器检查定义和声明的一致性。\n如果需要编译器检查声明的一致性，一定要把全局变量放在头文件中。\n永远不要把外部函数的原型放在.C文件中，函数的定义发生改变，很容易忘记修改函数原型\n\nextern 变量 &amp; 函数\n\nextern标识这个变量在外部进行了声明。\n外部指仍在同一工程下，但是不属于同一文件之中。\n\n// A.c\n#include &lt;stdio.h&gt;\n#include \"B.c\"\nextern int i;\nint main()\n{\n    // 输出6\n    printf(\"&amp;d\", i);\n    return 0;\n}\n// B.c\nint i = 6;\n\n\n实际上，extern在c和c++之中的处理不同。具体的可以单纯将其理解为，改变量已经在别处定义了。\n\n指针\n\n顾名思义，指针作为一个“特殊的类型”，在初学者中成为了一个十分头疼的问题。\n但是我觉得还是可以一探究竟的。\n指针可以做为不同的一种数据类型而存在。\n比如\n\n// 这里声明一个变量为i， 为int类型\nint i;\n// 这里声明一个指针类型p， 指向int类型\nint *p;\n\n\n这里要明确2个概念，指向空间的内存，和指针本身所占用的内存。\n可以将指针理解为去寻找打开秘密门的钥匙。所指向的类型作为门的类型。虽然统称为钥匙[指针] 但是打开的门[指向类型]不同。门的类型有不同，所以[指向类型]的内存空间大小也有不同。\n但指针的内存依然保持着都为4位的这个特性。\n\n指针的关键之处在于，要将“指针类型” 这个概念分开，化为\n\n* 指针类型\n* 指针所指向的类型\n\n\n这2种情况来看。\n先声明几个指针放着做例子：\n\n// 指向类型是int\nint *ptr;\n// 指向类型是char\nchar *ptr;\n// 指向（指向int类型的指针）\nint **ptr;\n// 指向 int () [3]\nint (*ptr)[3];\n// 指向 int *() [4]\nint *(*ptr)[4];\n\n\n通过上面可以观察到，指针所指向的类型仅仅把*ptr部分提取出来剩下的类型就是这个指针所指向的类型。\n\n再通过将括号转换为变量A来确定真实的指向类型。\n所以\n\nint (*ptr)[3];\n/* ↓ */\nint A [3];\n\n\n这样看来所指向的数据类型就一目了然了。\n\n补充-转换任意进制\n\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\nint main()\n{\n    int number = 12345;\n    char string[25];\n\n    itoa(number, string, 2);\n    printf(\"integer = %d string = %s\\n\", number, string);\n    return 0;\n}\n\n\n指针就是去访问一段变量的地址。那么对此可能会产生一些疑问，为什么要用指针去访问呢？\n比如，有这么一段代码。\n\nint main\n{\n    i = 5;\n    // your code\n}\n\n\n你想要去将i修改成7。那么你会怎么做？是不是会理所应到的想到如下代码\n\nint main\n{\n    int i = 5;\n    i = 7;\n}\n\n\n简单方便。是不是? 但是如果告诉你i是这样的。\n\nvoid f(/*your code*/)\n{\n    // your code\n}\nint main\n{\n    int i = 5;\n}\n\n\n那么在此时。你应该怎么去修改i的值呢？\n\nvoid f(int i)\n{\n    i = 7;\n}\n\n\n这样的代码能够实现你想要的功能么？\n\n此时你在运行中，你就会发现不管你怎么设值，在main中的值一直都会是5，不会做出任何的更改。\n\n这是为什么呢？其实很简单，在发生函数调用的时候，会出现传值，还是传地址的考虑。\n\n传值\n\n在C语言中，是将一个变量即上文中的i产生一个副本，即复制一份传送给那个函数。\n这是当时为了便于封装函数而采取的设计。即你在函数中对变量的任何操作都不会反应到该变量本身。\n这对数学计算的时候是一个非常好的设计，你不需要关系经过了一轮计算后的值会不会被意外的更改，程序会帮你保证不会更改变量自身的值。\n\n传地址\n\n你可能想知道，如果要修改变量的本身那么应该怎么做呢？\n那就是传地址的重要性了，地址和指针息息相关，函数通过地址，找到真正的变量，然后通过相应的指针类型，将地址解析出值，然后进行计算。\n（说句题外话，数组一定是传地址的，并且因为C语言设计比较懒，在函数传递的时候，并没有传递真正的数组，而是单纯的将函数头的首地址传入。那么，其实这个数组到底有多长呢？）\n\n你可能还有一个疑问，一个int也好，double也好，不是都是占用内存块么？一个指针按理说保存的是一个值，难道保存的是111110-111111这样的么？\n当然不可能啊。其实指针只保存第一个地址，即一个类型所占用的第一个内存单元。那么怎么取得正确的值，那就是看指针自身的类型了。比如。\n\nint *\n\n\n类型的指针，就会在它保存的内存单元往后切4块。然后将内存中的值抽出。如果使用强制转换，你会发现你会得到很多奇怪的值哦。可以自己进行测试。\n\n指针和数组\n\n指针和数组的关系，千丝万缕。因为C语言的懒操作，对于数组这个东西，其实是由一个指针所维护的，其不保存数组长度在每个数组的类型之中，所以会在传参后丢失数组的长度。\nsizeof实在编译时发生作用，在数组传递后，C内部只保存数组的头指针。此时在函数中很容易出现越位的错误。（并且越位后，如果不对其做取指，赋值操作，很难发现这个错误编译器因为不知道长度，不会检查此错误）所以要非常小心的使用数组。\n\n如果要传递数组进行操作时，有如下3种方式：\n\n\n  定义数组的文件中，声明，定义并初始化一个变量，用以保存数组长度。\n\n\n// file1.c:\nint array[] = {1, 2, 3};\nint array_size = sizeof(array) / array[0];\n// file2.c\nextern int array[];\nextern int array_size;\n\n\n\n  使用#define确定数组的长度\n\n\n// file.h\n#define ARRAYSZ 3\n// file1.c\n#include \"file.h\"\nint array[ARRAYSZ];\n// file2.c\n#include \"file.h\"\nextern int array[ARRAYSZ];\n\n\n\n  在数组的最后的一个元素放入一个 “哨兵值” （通常0， -1， NULL）\n\n\n// file1.c\nint array[] = {1, 2, 3, -1};\n// file2.c\nextern int array[];\n\n\n如果数组已经被初始化，使用2的话就不太好。\n\n虽然C中的数组是由指针假扮的，但是仍然满足C语言的定义匹配规则。即数组和指针是不同的，所以你不能写如下代码：\n\n// file1.c\nchar a[6];\n// file2.c\nextern char *a;\n\n\n这时是类型不匹配的。\n你需要将代码改成：\n\nextern char a[6];\n\n\n数组之坑\n\n为什么说C语言的数组是坑呢？这也是为什么上文所提到的数组长度的计算方法，只有在申明了数组的同一函数内部中才能使用的原因。\n可能会很困惑。为什么呢？\n\n因为C语言的数组只有一个指针。\n这个仔细想想就会知道答案，为什么在函数内部可以取到数组的长度，转递参数以后，数组的长度就没有了呢？其实这个很简单，脱离了该数组，数组的长度就消失了。这也是为什么在C99之前，要求你声明的数组长度一定是一个常量的原因。\n即数组不像以后的类型，里面即保存了数组的头指针，还保存了数组的长度。\n\nC语言只保存了数组的头指针。并在__其他的地方假装__保存了数组的长度。如果在某一函数内部声明了一个数组，这个数组的长度并不保存在这个数组的内部。只有在你去取指的时候（sizeof时），编译器会将这个假装的值给出，让你得到数组的长度。\n但是。如果传递参数给出到下一个函数，那这个假装的值就没法给出了。数组就只有一个孤零零的指针，需要考程序员手工维护不要越界。 往往在学生的代码中会出现这种代码：\n\nvoid f(const int *array_a)\n{\n    // 遍历\n    for(int i = 0; i != 3/*←*/; i++)\n    {\n        // 有问题么?\n    }\n}\nint main()\n{\n    int a[] = {1,2,3};\n    f(a);\n    return 0;\n}\n\n\n乍一看，毫无问题，其实问题很大，比如，那个3(魔法数)，怎么蹦出来的？！ 请解释。你可能回答，啊，数组长度是3啊。但是，这是你自己写的代码，以后工作，或者稍微大一点的项目，你不可能自己一个人完成，那么就牵扯到了多人协作，多人工作。那。如果这个数组是你要调用他人写的代码中的数组时，你怎么知道这个数组有多长？\n所以现在比较流行的解决办法是：具体可以参加 __part3 指针__下的内容\n\nvoid f(const int *array_a, unsigned int size)\n{\n    // 遍历\n    for(int i = 0; i != size; i++)\n    {\n\n    }\n}\n\n\n来获取这个数组的长度。 简单的一个数组稍微展开一些就会有非常多的地方要学呢。\n\n指针和假的字符串\n\n// Q1\nchar *p = \"asdadada\";\np[1] = 'S';\nprintf(\"%s\\n\", p);\n// Q2\nchar a[] = \"adadasda\";\nchar *q = a;\nq[1] = 'S';\nprintf(\"%s\\n\", q);\n\n\n这段程序的运行结果是什么呢？\n是否会被迷惑住，以为都会修改了这个值。其实答案是只有Q2成功修改了该值。\n这是为什么呢？\n\n\n  Q1 是用数组作为初始值，只是多了一个结尾的数组，与其他数组作无异。\n  Q2 将改字符串转换为一个无名的静态字符串数组。可能存储在只读内存之中。这将导致它不会被修改。（这里指向的是无名数组的第一个元素）。\n\n\n空指针\n\n0\n\n原来将设定0的指针称之为空指针。如下：\n\nchar *p = 0;\n\n\n判断指针为空可以简单的记做：\n\nif(p)\n    //\n\n\n可以直接使用空指针的情况请确保在如下之一：\n\n\n  初始化\n  赋值\n  比较（判断开始，或结尾）\n  固定参数的函数调用且在作用域中有函数原型\n\n\n必须要显示的类型转换的：\n\n\n  函数调用， 作用域内没有原型\n  变参函数调用中的可变参数\n\n\nNULL\n\n是一个宏， 其值是一个空指针。（原先是为了避免魔法数0的出现）\nNULL只能用作指针， 并且NULL和0完全等价。上记的注意都是一样的。\n同时，编译器还是根据上下文的来进行处理NULL，仍然需要对NULL进行相应的转换。\n\n总结\n\n简单来说，保证如下2点即可\n\n\n  当源码中需要空指针常量时，用0或NULL\n  如果在函数中调用0，或者NULL时，要把它转换成被调用函数需要的指针类型\n\n\n好玩的\n\nprintf(\"%c\\n\",\"helloworld\"[5]);\nprintf(\"%c\\n\", 5[\"helloworld\"]);\n\n\n结果是一样的。\n\nconst的含义\n\n首先明确， const是告诉程序员这是一个常量。嗯。在C中，const是假的。\n\n不信？可以试试如下代码:\n根据 大佬  __←大佬的博客__的测试，\n如下代码仍然存在着一些问题。\n同时，如果该代码是在__全局变量__中，会产生error。__不能__通过编译。\n\nconst int i = 12;\nint *p = &amp;i;\n// 修改了i\n*p = 5;\n\n\nVS2017中，该代码修改了const所声明的变量。但在mac的gcc中，i的值并未发生改变，不过当你去获取i地址上的值时，发现已经改变了。\n\n// code\n// i 的值为 12\nprintf(\"%d\", i);\nint *q = &amp;i;\n//  *q 的值为5\nprintf(\"%d\", *q);\n\n\n这是为什么呢？\n根据爆栈\n 的数据：\n\nWhen it does optimisation, the compiler presumably loads 12 into a register and doesn't bother to load it again when it needs to access a for the printf because it \"knows\" that a can't change.\n\n\n所以是一个很神奇的未定义行为。\n\n展开\n\n应该去写可以移植的代码，一个好的可移植的代码应该遵守：\n\n可移植代码\n\n\n  只使用已知的特性\n  不突破编译器的限制\n  不使用，依赖任何的未定义行为\n\n\n不可移植代码\n\n由编译器定义的代码，是由编译器决定的如何采取行动\n\n烂代码\n\n\n  有未定义行为的\n  没有遵守约束条件的（常量表达式不被赋值或修改，变量和常量的值应该在其所在的范围内）\n  其他可以导致程序出现异常或增加读代码人的劳动的\n\n\n综上，其实在C编译器中其实不能很好的做到对const声明变量的保护，gcc的保护行为也是未定义的，不能假象某一个编译器的实现去类推其他操作系统或者代码。远离未定义 是否修改了const也是程序员应该关心的问题呢。（←别指望编译器了。）\n\n所以，这个大前提一定要明白，清楚。const是告诉程序员这是一个常量。所以你要自己去保证不要去乱改const里所保存的值。（出了问题就是你的锅）\n\nconst的含义就是：\n告诉你这是一个常量，你不要改。\n\n当然你希望这个常量不能被改，理所应当给它设个初始值。这是常识。什么时候用const也不必说。\n但是在新手中常犯的错误有：\n\n\\\\ 不理解const的是假的含义,但知道程序中不能存在魔法数的规范：\nconst int i = 1;\n\\\\ 会报错\n\\\\ C99 后不报错，成为新的规则。具体情况请参阅自己编译器所支持的语言版本。\nint arrA[i] = { 1 };\n\n\nconst与指针结合\n\nconst int n = 5;\nint const m = 10;\n\n\n效果等价。\n但是如果和指针相互结合在一起。就会有很大的不同。\n\nconst int *p;\nint const *q;\n\n\n这2个所指向的类型是什么呢？ 根据上文所说，去掉__*变量名__所剩下的就是所指向的类型，那么这两个所剩下的是：\n\nconst int\nint const\n\n\n由根据上文所说，const和int的位置交换所代表的含义相同。所以这2个变量所指向的类型也是相同的，指向const int类型，所以这个p和q是可以随便指向其他的const int类型的，甚至int类型（你关了warming的话）\n\n为了避免误解，请将变量名自己规定为const在前。（←正常人的想法）\n\n那么我现在其实想声明一个不可以改变的指针怎么办？\n\nint n = 12;\nint *const r = &amp;n;\n\n\n上面的代码片段才是正确的写法。用正确的写法能够最大的减少误解， 程序是给人读的！\n\n再按照之前的原则拆分一下。*变量名，哎？变量名中间有const，那就是指针本身不可改。剩下了int，那就是指向int类型。\n\n下面给出一些栗子。（举个栗子，请脑补）\n\nchar **p;\nconst char **p2;\nchar *const *p3;\nconst char *const *p4;\nchar **const p5;\nconst char **const p6;\nchar *const *const p7;\nconst char *const* const p8;\n\n\n方法学会了么？\n以第4个为例，\n\n\n  首先抽出 *const p4, 证明这是一个const 指针\n  剩下的为const char *A\n  所以这是一个const指针指向[ 一个指向const char 类型的指针 ]\n\n\n答案\n\n\n  p1是指向char类型的指针的指针；\n  p2是指向const char类型的指针的指针；\n  p3是指向char类型的const指针；\n  p4是指向const char类型的const指针；\n  p5是指向char类型的指针的const指针；\n  p6是指向const char类型的指针的const指针；\n  p7是指向char类型const指针的const指针；\n  p8是指向const char类型的const指针的const指针。\n\n\n使用Typeof提升可读性\n\n良好的使用typedef可以使你的代码具有更好的可读性。\n比如：\n\ntypedef char * PCHAR;\n// 声明了2个指向字符的指针 p，q\nPCHAR p,q;\n//类比如下代码\nchar *p, q;\n\n\n最后一行代码读懂了么？乍一看是也是声明了2个指针。其实是声明了一个指针和一个char类型的变量。所以要分清指针的*表述的意思。\n\n与#define的区别\n\n\n  typedef 遵守作用域规则。而#define是全局的，全部替换，并且不能正确的处理指针类型。\n  但是#define 可以使用#ifedf。\n\n\n所以要根据实际情况进行选择。\n\n命名方式展开\n\n推荐采用：\n\nchar *p;\n\n\n这样(星号靠右)的命名方式，这样你才能理解到，这个指针是针对于p的。即，只有char，int等类型，和一个指针类型__*__, 前面的类型仅仅是用来标识，从内存中读出几位字节而已。这样理解就不会出现如上的声明方式，而产生误解。或者采用 typedef 来讲其进行别名转换。\n\n具体的好处可以参见如下：\n\ntypedef char *a;\ntypedef a b();\ntypedef b *c;\ntypedef c d();\ntypedef d *e;\ne var[10];\n\n\n是不是一下子就晕了。\n咱们来慢慢梳理一下。\n由后往前看。\n\n\n  这是一个 1.数组。 （1类型是e）\n  这是一个 2.指针类型的 1.数组。 （2指向的类型是d）\n  这是一个 3.指向函数的 2.指针类型的 1.数组。 （3函数返回的类型是c）\n  这是一个 4.指向有返回值的 3.指向函数的 2.指针类型的 1.数组。 （4指向的类型是b）\n  这是一个 4.指向返回值 5.是指针的 3.指向函数的 2.指针类型的 1.数组。 （5函数返回的类型是a）\n  这是一个 4.指向返回值 5.是指针指向 6.返回值是指向char类型的 3.指向函数的 2.指针类型的 1.数组。 （6指向的类型是char）\n\n\n是不是一下子就懂了呢。\n然后以此类推。\n初次使用typedef可能会晕，还是要多多练习。\n同时，在使用typedef时，注意。\n\n// 普通声明变量\nint a;\n// typedef申明变量别名\ntypedef int a;\n\n\ntypedef在保证原来申明语法不变的前提下，将原变量的命名，作为空格之前的__东西__作为它的别名。\n这点要在以后的函数指针中要理解透彻。\n\n为什么要封装成函数\n\n封装成函数可以：\n\n\n  提高可读性\n  提高健壮性\n  在修改函数的时候更加方便\n  维护程序的时候能够更好的去修改代码\n  适合项目中多人开发\n\n\n但同时也有一些不算缺点的问题：\n\n\n  封装函数反而降低维护性\n  封装函数产生技术困难\n  封装函数没有意思\n\n\n下面针对几点进行说明：\n\n// 使用函数\nint addValueFive(int a)\n{\n    return a += 5；\n}\n\n\n// 不使用函数\nint main()\n{\n    int i = 21;\n    // 其他code\n    i += 5；\n    return 0;\n}\n\n\n可读性更高，阅读他人代码的时候，可以跟读小说一样将代码的含义阅读出来。而不必去关心其余不相关的问题，比如这里的值是否正确，是否真的是要去加5而不是误输入等其他问题。\n\n当然封装函数的时候要掌握一个度，不需要将所有的功能全部拆分成块。毕竟在调用函数的时候也会产生相应的开销。在需要特殊优化的地方。这里应该也是需要被最后考虑的问题。\n\n其次在初学者学习的时候，容易犯下如此的错误：\n\n// wrong code 1\nvoid changeValue1(int i)\n{\n    i += 5;\n    printf(\"%d\", i);\n}\n// wrong code 2\nvoid changeValue2()\n{\n    int i = 21;\n    i += 5;\n    printf（\"%d\", i);\n}\n\nint main()\n{\n    int i1 = 21;\n    int i2 = 21;\n    changeValue1(i1);\n    changeValue2();\n    return 0;\n}\n\n\n乍一看，上述2个函数都完成了将i增加5的功能，并有效的输出了变换后的值，但是其实并没有真正的实现这一个功能，对于第一个代码来说，仅仅是对形参增加了5，对main函数自身的i并没有更改，而第二个代码。根本没有将功能封装成函数。这是初学者容易犯的错误。其实对于第二种代码片段，更像是其他语言所拥有的命名空间，偶尔在C语言中也可以如此使用，但是一定要确保自己的函数是正确的，并且自己知道这么做的后果是什么再去这样使用。\n\n全部功能写在main里有什么坏处\n\n初学者会烦的错误就是一般会将所有部分全都写在main函数中，这样做其实也有一定的好处。\n\n\n  不需要考虑同名变量的作用域\n  不需要考虑用指针去修改变量\n  数组可以直接获取到长度\n  思维直线式-符合初学者思维\n\n\n嗯，有这么多优点呢。这些优点就是你以后要努力克服不去触及的坑呢。如果不把坑填平，无论如何都不可能学会C的。甚至其他语言。\n上文提到过，程序的可读性这个问题，在你面对上百上千行代码的时候，而且全部揉在main中，这个程序的可读性基本是0，过了几个月后，开发者本身可能都不能理解其中的逻辑依赖关系，再三强调代码是给人读的所以一定要将代码抽成函数。\n抽出函数的时候，才能更好的提高自己的知识水平。\n全部都写在main里。总结来说会使你的代码越来越烂而已。无他。\n\n小提示：\n\n\\\\获取数组长度 只在申明了数组的同一函数内部中使用\n\\\\ 数组类型是int\nint size = sizeof(array) / sizeof(int);\n\\\\ 或使用如下方法\nint size = sizeof(array) / sizeof(array[0]);\n\n\n封装函数时会出现什么困难\n\n\n  程序封装函数后，传参出现问题，主要是由数组导致的（丢失了长度），产生数组越界或者其他bug\n  程序需要对多个变量进行更改，而返回值只有一个。需要更好的设计对整体操作进行拆分\n\n\n宏\n\n#define\n\n使用宏可以完成很多非常有用的功能，比如如下代码：\n\n__VA_ARGS__\n\n// C99支持\n#define showlist(...) puts(#__VA_ARGS__)\n// puts(\"\")\nshowlist();\n// puts(\"1,\\\"x\\\", int\")\nshowlist(1, \"x\", int);\n\n\n此时，应用：不需要输入”“\\等符号直接生成表示地址的字符串。\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define showlist(...) put_file_name(#__VA_ARGS__)\n\nchar file_name[100] ={0};\n\nchar* put_file_name(const char * file)\n{\n    int i = 0;\n\n    while((*file++) != '\\0')\n    {\n        file_name[i] = *(file - 1);\n        i++;\n        if(i == 98)\n            break;\n    }\n    file_name[i + 1] = '\\0';\n    return file_name;\n}\n\nint main()\n{\n    char *file;\n    int j = 0;\n    // 不需要写转义字符，直接书写地址。\n    file = showlist(\"D:\\code\\cplus\\TestGCC\\Test\\bin\\Debug\");\n    puts(file);\n    system(\"pause\");\n    return 0;\n}\n\n\n使用宏还可以装作模板来生成代码：(摘抄自手册)\n\n#include &lt;stdio.h&gt;\n\n//make function factory and use it\n#define FUNCTION(name, a) int fun_##name(int x) { return (a)*x;}\n\nFUNCTION(quadruple, 4)\nFUNCTION(double, 2)\n\n#undef FUNCTION\n#define FUNCTION 34\n#define OUTPUT(a) puts( #a )\n\nint main(void)\n{\n    printf(\"quadruple(13): %d\\n\", fun_quadruple(13) );\n    printf(\"double(21): %d\\n\", fun_double(21) );\n    printf(\"%d\\n\", FUNCTION);\n    OUTPUT(million);               //note the lack of quotes\n}\n\n\n其他问题点\n\nmalloc 和 free\n\nfree 掉malloc 开辟出来的内存时,是全部都会被free 掉.\n因为malloc 在开辟内存的时候,在内存之前添加了header.\n",
        "content": "综述\n\n  文献摘录\n  C其他展开\n  extern 变量 &amp; 函数\n  指针\n  指针和数组\n  const的含义\n  const与指针结合\n  使用Typeof提升可读性\n  为什么要封装成函数\n  全部功能写在main里有什么坏处\n  封装函数时会出现什么困难\n  宏\n\n\n备注 每日一更 +代表更新 -代表还在占坑中（没有内容暂待更新）\n更新内容：\n\n\n  C其他展开\n  \n    \n      数组\n    \n  \n\n\n\n\n文献摘录\n\n\n  摘自 你必须知道的495个C语言问题\n\n\nQA\n\nQ：如何生成“半全局变量” （部分源文件中部分函数可以访问的变量）\nA: C语言办不到。但是实在要做的话：\n\n\n  为一个库或相关函数的集合中的所有函数和全局变量加一个唯一的前缀。并用文字警告，使用该集合的用户不能定义和使用文档列出的公用符合意外的任何带有前缀的其他符号。\n  使用下划线命名。\n\n\n作用域\n\n标识声明的有效区域：\n\n\n  函数\n  文件\n  块\n  原型\n\n\n命名空间\n\n\n  行标（label，goto的目的地）\n  标签（tag，struct，union和enum的名称&lt;-这3种命名空间不相互独立）\n  struct/union的成员\n  普通标识符（函数，变量，类型定义，枚举常量）\n\n\n链接类型\n\n\n  外部链接（全局，非静态变量和函数）\n  内部链接（仅限于文件作用域内的静态函数和变量）\n  无链接（举办变量和类型定义（typedef）名称，枚举常量\n\n\nC其他展开\n\n数组\n\n在创建一个数组的时，有时需要去创建2维甚至是多维的数组，但是往往需要动态的生成。那么可以给出一个简单的方法。\n一下例子是用c++ 实现，但是思路相同。主要的思路就是，通过创建一长串的一维数组，模拟二维数组的操作，比如你要访问相应的数组长度，可以使用数组的计算方法，在一维数组中快速的找到相应的元素，同时减少了循环的次数。（如果动态实现，则会减少一个*。 在编程中如果条件允许，可以使用这种方式提高编程效率。（因为C，c++ 本身并不是真的存在高于一维的数据结构。都是模拟的进行操作。（即，都是开辟线性的内存块，我不知道这种编程方式是否会有真正的性能提升。虽然减少了一层的循环。）为了不要成为优化神教， 还是需要对具体情况进行具体的分析。\n\nint intNumber;\n    cin &gt;&gt; intNumber;\n    int *intArray = new int[intNumber * intNumber];\n\n    for (int i = 0; i != (intNumber * intNumber); i++)\n    {\n        cin &gt;&gt; intArray[i];\n    }\n    for (int i = 0,j = 1; i != (intNumber * intNumber); i++, j++)\n    {\n        cout &lt;&lt; intArray[i] &lt;&lt; \" \";\n        if (j == intNumber)\n        {\n            cout &lt;&lt; endl;\n            // 为什么这里是0？读者自己思考\n            j = 0;\n        }\n    }\n\n\n结构体比较\n\n不能使用 == 和 ！= 比较结构体，简单的按字节比较的方法会遇到结构体中没有使用的内存空间（洞）的随机内容和失败。这里的洞是用来补位，以便后续成员对齐的\n如果需要比较，需要自己写函数，按域比较。\n\n未定义\n\n// bad code 1\na[i] = i++;\n// bad code 2\nint i = 7;\nprintf(\"%d\\n\", i++ * i++);\n\n\n诸如此类代码是未定义的，千万不要使用。\n\nint f()\nint h()\nint g()\n\nf() + (g() * h())\n\n\n如上代码也不会改变函数的调用顺序。同理：\n\n(i++) * (i++)\n\n\n有没有括号都是未定义的。\n\n短路\n\n可以假定：\n一旦&amp;&amp;和|| 左边 的表达式已经决定了整个表达式的结果，那么右边的表达式一定不会被求职\n\n序列点\n\n序列点是一个时间点，所有的副作用都应该保证结束。\n在上一个和下一个序列点之间，一个对象所保存的值至多只能被表达式修改 一次 ，而且只有在确定将要保存的值的时候才能访问之前的一个值。\nC语言标准提及的序列点包括：\n\n\n  完整的表达式尾部（表达式语句完成。并且该表达式不是其他表达式的子语句存在）\n  \n    \n      \n        \n          &amp;&amp;、\n           \n          、?: 、, 操作处\n        \n      \n    \n  \n  函数调用时（参数已经被求值完毕，函数在被实际调用之前）\n\n\n声明和定义\n\nC系列的语言中，要严格分清，定义和声明的区别。其实也很简单：\n\n// 这是声明\nint f();\n\n\n// 上面还有很多的code\n// 这是定义\nint f()\n{\n    return 0;\n}\n\n\n// 这是申明和定义\nint f()\n{\n    return 0;\n}\n\n\nC语言中，一般来说，定义只能一次。在同一作用空间之中\n在希望多个源文件中共享变量或函数的时候，需要确保声明和定义的一致性，（如果有同名的函数或者是变量，在编译的时候不会报错，但是在链接的时候会link失败的错误。这时应该检查是否有变量重名 ）\n在.h 和.c文件中，其实相关的处理没有区别。仅仅是在使用的时候，以便编译器检查定义和声明的一致性。\n如果需要编译器检查声明的一致性，一定要把全局变量放在头文件中。\n永远不要把外部函数的原型放在.C文件中，函数的定义发生改变，很容易忘记修改函数原型\n\nextern 变量 &amp; 函数\n\nextern标识这个变量在外部进行了声明。\n外部指仍在同一工程下，但是不属于同一文件之中。\n\n// A.c\n#include &lt;stdio.h&gt;\n#include \"B.c\"\nextern int i;\nint main()\n{\n    // 输出6\n    printf(\"&amp;d\", i);\n    return 0;\n}\n// B.c\nint i = 6;\n\n\n实际上，extern在c和c++之中的处理不同。具体的可以单纯将其理解为，改变量已经在别处定义了。\n\n指针\n\n顾名思义，指针作为一个“特殊的类型”，在初学者中成为了一个十分头疼的问题。\n但是我觉得还是可以一探究竟的。\n指针可以做为不同的一种数据类型而存在。\n比如\n\n// 这里声明一个变量为i， 为int类型\nint i;\n// 这里声明一个指针类型p， 指向int类型\nint *p;\n\n\n这里要明确2个概念，指向空间的内存，和指针本身所占用的内存。\n可以将指针理解为去寻找打开秘密门的钥匙。所指向的类型作为门的类型。虽然统称为钥匙[指针] 但是打开的门[指向类型]不同。门的类型有不同，所以[指向类型]的内存空间大小也有不同。\n但指针的内存依然保持着都为4位的这个特性。\n\n指针的关键之处在于，要将“指针类型” 这个概念分开，化为\n\n* 指针类型\n* 指针所指向的类型\n\n\n这2种情况来看。\n先声明几个指针放着做例子：\n\n// 指向类型是int\nint *ptr;\n// 指向类型是char\nchar *ptr;\n// 指向（指向int类型的指针）\nint **ptr;\n// 指向 int () [3]\nint (*ptr)[3];\n// 指向 int *() [4]\nint *(*ptr)[4];\n\n\n通过上面可以观察到，指针所指向的类型仅仅把*ptr部分提取出来剩下的类型就是这个指针所指向的类型。\n\n再通过将括号转换为变量A来确定真实的指向类型。\n所以\n\nint (*ptr)[3];\n/* ↓ */\nint A [3];\n\n\n这样看来所指向的数据类型就一目了然了。\n\n补充-转换任意进制\n\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\nint main()\n{\n    int number = 12345;\n    char string[25];\n\n    itoa(number, string, 2);\n    printf(\"integer = %d string = %s\\n\", number, string);\n    return 0;\n}\n\n\n指针就是去访问一段变量的地址。那么对此可能会产生一些疑问，为什么要用指针去访问呢？\n比如，有这么一段代码。\n\nint main\n{\n    i = 5;\n    // your code\n}\n\n\n你想要去将i修改成7。那么你会怎么做？是不是会理所应到的想到如下代码\n\nint main\n{\n    int i = 5;\n    i = 7;\n}\n\n\n简单方便。是不是? 但是如果告诉你i是这样的。\n\nvoid f(/*your code*/)\n{\n    // your code\n}\nint main\n{\n    int i = 5;\n}\n\n\n那么在此时。你应该怎么去修改i的值呢？\n\nvoid f(int i)\n{\n    i = 7;\n}\n\n\n这样的代码能够实现你想要的功能么？\n\n此时你在运行中，你就会发现不管你怎么设值，在main中的值一直都会是5，不会做出任何的更改。\n\n这是为什么呢？其实很简单，在发生函数调用的时候，会出现传值，还是传地址的考虑。\n\n传值\n\n在C语言中，是将一个变量即上文中的i产生一个副本，即复制一份传送给那个函数。\n这是当时为了便于封装函数而采取的设计。即你在函数中对变量的任何操作都不会反应到该变量本身。\n这对数学计算的时候是一个非常好的设计，你不需要关系经过了一轮计算后的值会不会被意外的更改，程序会帮你保证不会更改变量自身的值。\n\n传地址\n\n你可能想知道，如果要修改变量的本身那么应该怎么做呢？\n那就是传地址的重要性了，地址和指针息息相关，函数通过地址，找到真正的变量，然后通过相应的指针类型，将地址解析出值，然后进行计算。\n（说句题外话，数组一定是传地址的，并且因为C语言设计比较懒，在函数传递的时候，并没有传递真正的数组，而是单纯的将函数头的首地址传入。那么，其实这个数组到底有多长呢？）\n\n你可能还有一个疑问，一个int也好，double也好，不是都是占用内存块么？一个指针按理说保存的是一个值，难道保存的是111110-111111这样的么？\n当然不可能啊。其实指针只保存第一个地址，即一个类型所占用的第一个内存单元。那么怎么取得正确的值，那就是看指针自身的类型了。比如。\n\nint *\n\n\n类型的指针，就会在它保存的内存单元往后切4块。然后将内存中的值抽出。如果使用强制转换，你会发现你会得到很多奇怪的值哦。可以自己进行测试。\n\n指针和数组\n\n指针和数组的关系，千丝万缕。因为C语言的懒操作，对于数组这个东西，其实是由一个指针所维护的，其不保存数组长度在每个数组的类型之中，所以会在传参后丢失数组的长度。\nsizeof实在编译时发生作用，在数组传递后，C内部只保存数组的头指针。此时在函数中很容易出现越位的错误。（并且越位后，如果不对其做取指，赋值操作，很难发现这个错误编译器因为不知道长度，不会检查此错误）所以要非常小心的使用数组。\n\n如果要传递数组进行操作时，有如下3种方式：\n\n\n  定义数组的文件中，声明，定义并初始化一个变量，用以保存数组长度。\n\n\n// file1.c:\nint array[] = {1, 2, 3};\nint array_size = sizeof(array) / array[0];\n// file2.c\nextern int array[];\nextern int array_size;\n\n\n\n  使用#define确定数组的长度\n\n\n// file.h\n#define ARRAYSZ 3\n// file1.c\n#include \"file.h\"\nint array[ARRAYSZ];\n// file2.c\n#include \"file.h\"\nextern int array[ARRAYSZ];\n\n\n\n  在数组的最后的一个元素放入一个 “哨兵值” （通常0， -1， NULL）\n\n\n// file1.c\nint array[] = {1, 2, 3, -1};\n// file2.c\nextern int array[];\n\n\n如果数组已经被初始化，使用2的话就不太好。\n\n虽然C中的数组是由指针假扮的，但是仍然满足C语言的定义匹配规则。即数组和指针是不同的，所以你不能写如下代码：\n\n// file1.c\nchar a[6];\n// file2.c\nextern char *a;\n\n\n这时是类型不匹配的。\n你需要将代码改成：\n\nextern char a[6];\n\n\n数组之坑\n\n为什么说C语言的数组是坑呢？这也是为什么上文所提到的数组长度的计算方法，只有在申明了数组的同一函数内部中才能使用的原因。\n可能会很困惑。为什么呢？\n\n因为C语言的数组只有一个指针。\n这个仔细想想就会知道答案，为什么在函数内部可以取到数组的长度，转递参数以后，数组的长度就没有了呢？其实这个很简单，脱离了该数组，数组的长度就消失了。这也是为什么在C99之前，要求你声明的数组长度一定是一个常量的原因。\n即数组不像以后的类型，里面即保存了数组的头指针，还保存了数组的长度。\n\nC语言只保存了数组的头指针。并在__其他的地方假装__保存了数组的长度。如果在某一函数内部声明了一个数组，这个数组的长度并不保存在这个数组的内部。只有在你去取指的时候（sizeof时），编译器会将这个假装的值给出，让你得到数组的长度。\n但是。如果传递参数给出到下一个函数，那这个假装的值就没法给出了。数组就只有一个孤零零的指针，需要考程序员手工维护不要越界。 往往在学生的代码中会出现这种代码：\n\nvoid f(const int *array_a)\n{\n    // 遍历\n    for(int i = 0; i != 3/*←*/; i++)\n    {\n        // 有问题么?\n    }\n}\nint main()\n{\n    int a[] = {1,2,3};\n    f(a);\n    return 0;\n}\n\n\n乍一看，毫无问题，其实问题很大，比如，那个3(魔法数)，怎么蹦出来的？！ 请解释。你可能回答，啊，数组长度是3啊。但是，这是你自己写的代码，以后工作，或者稍微大一点的项目，你不可能自己一个人完成，那么就牵扯到了多人协作，多人工作。那。如果这个数组是你要调用他人写的代码中的数组时，你怎么知道这个数组有多长？\n所以现在比较流行的解决办法是：具体可以参加 __part3 指针__下的内容\n\nvoid f(const int *array_a, unsigned int size)\n{\n    // 遍历\n    for(int i = 0; i != size; i++)\n    {\n\n    }\n}\n\n\n来获取这个数组的长度。 简单的一个数组稍微展开一些就会有非常多的地方要学呢。\n\n指针和假的字符串\n\n// Q1\nchar *p = \"asdadada\";\np[1] = 'S';\nprintf(\"%s\\n\", p);\n// Q2\nchar a[] = \"adadasda\";\nchar *q = a;\nq[1] = 'S';\nprintf(\"%s\\n\", q);\n\n\n这段程序的运行结果是什么呢？\n是否会被迷惑住，以为都会修改了这个值。其实答案是只有Q2成功修改了该值。\n这是为什么呢？\n\n\n  Q1 是用数组作为初始值，只是多了一个结尾的数组，与其他数组作无异。\n  Q2 将改字符串转换为一个无名的静态字符串数组。可能存储在只读内存之中。这将导致它不会被修改。（这里指向的是无名数组的第一个元素）。\n\n\n空指针\n\n0\n\n原来将设定0的指针称之为空指针。如下：\n\nchar *p = 0;\n\n\n判断指针为空可以简单的记做：\n\nif(p)\n    //\n\n\n可以直接使用空指针的情况请确保在如下之一：\n\n\n  初始化\n  赋值\n  比较（判断开始，或结尾）\n  固定参数的函数调用且在作用域中有函数原型\n\n\n必须要显示的类型转换的：\n\n\n  函数调用， 作用域内没有原型\n  变参函数调用中的可变参数\n\n\nNULL\n\n是一个宏， 其值是一个空指针。（原先是为了避免魔法数0的出现）\nNULL只能用作指针， 并且NULL和0完全等价。上记的注意都是一样的。\n同时，编译器还是根据上下文的来进行处理NULL，仍然需要对NULL进行相应的转换。\n\n总结\n\n简单来说，保证如下2点即可\n\n\n  当源码中需要空指针常量时，用0或NULL\n  如果在函数中调用0，或者NULL时，要把它转换成被调用函数需要的指针类型\n\n\n好玩的\n\nprintf(\"%c\\n\",\"helloworld\"[5]);\nprintf(\"%c\\n\", 5[\"helloworld\"]);\n\n\n结果是一样的。\n\nconst的含义\n\n首先明确， const是告诉程序员这是一个常量。嗯。在C中，const是假的。\n\n不信？可以试试如下代码:\n根据 大佬  __←大佬的博客__的测试，\n如下代码仍然存在着一些问题。\n同时，如果该代码是在__全局变量__中，会产生error。__不能__通过编译。\n\nconst int i = 12;\nint *p = &amp;i;\n// 修改了i\n*p = 5;\n\n\nVS2017中，该代码修改了const所声明的变量。但在mac的gcc中，i的值并未发生改变，不过当你去获取i地址上的值时，发现已经改变了。\n\n// code\n// i 的值为 12\nprintf(\"%d\", i);\nint *q = &amp;i;\n//  *q 的值为5\nprintf(\"%d\", *q);\n\n\n这是为什么呢？\n根据爆栈\n 的数据：\n\nWhen it does optimisation, the compiler presumably loads 12 into a register and doesn't bother to load it again when it needs to access a for the printf because it \"knows\" that a can't change.\n\n\n所以是一个很神奇的未定义行为。\n\n展开\n\n应该去写可以移植的代码，一个好的可移植的代码应该遵守：\n\n可移植代码\n\n\n  只使用已知的特性\n  不突破编译器的限制\n  不使用，依赖任何的未定义行为\n\n\n不可移植代码\n\n由编译器定义的代码，是由编译器决定的如何采取行动\n\n烂代码\n\n\n  有未定义行为的\n  没有遵守约束条件的（常量表达式不被赋值或修改，变量和常量的值应该在其所在的范围内）\n  其他可以导致程序出现异常或增加读代码人的劳动的\n\n\n综上，其实在C编译器中其实不能很好的做到对const声明变量的保护，gcc的保护行为也是未定义的，不能假象某一个编译器的实现去类推其他操作系统或者代码。远离未定义 是否修改了const也是程序员应该关心的问题呢。（←别指望编译器了。）\n\n所以，这个大前提一定要明白，清楚。const是告诉程序员这是一个常量。所以你要自己去保证不要去乱改const里所保存的值。（出了问题就是你的锅）\n\nconst的含义就是：\n告诉你这是一个常量，你不要改。\n\n当然你希望这个常量不能被改，理所应当给它设个初始值。这是常识。什么时候用const也不必说。\n但是在新手中常犯的错误有：\n\n\\\\ 不理解const的是假的含义,但知道程序中不能存在魔法数的规范：\nconst int i = 1;\n\\\\ 会报错\n\\\\ C99 后不报错，成为新的规则。具体情况请参阅自己编译器所支持的语言版本。\nint arrA[i] = { 1 };\n\n\nconst与指针结合\n\nconst int n = 5;\nint const m = 10;\n\n\n效果等价。\n但是如果和指针相互结合在一起。就会有很大的不同。\n\nconst int *p;\nint const *q;\n\n\n这2个所指向的类型是什么呢？ 根据上文所说，去掉__*变量名__所剩下的就是所指向的类型，那么这两个所剩下的是：\n\nconst int\nint const\n\n\n由根据上文所说，const和int的位置交换所代表的含义相同。所以这2个变量所指向的类型也是相同的，指向const int类型，所以这个p和q是可以随便指向其他的const int类型的，甚至int类型（你关了warming的话）\n\n为了避免误解，请将变量名自己规定为const在前。（←正常人的想法）\n\n那么我现在其实想声明一个不可以改变的指针怎么办？\n\nint n = 12;\nint *const r = &amp;n;\n\n\n上面的代码片段才是正确的写法。用正确的写法能够最大的减少误解， 程序是给人读的！\n\n再按照之前的原则拆分一下。*变量名，哎？变量名中间有const，那就是指针本身不可改。剩下了int，那就是指向int类型。\n\n下面给出一些栗子。（举个栗子，请脑补）\n\nchar **p;\nconst char **p2;\nchar *const *p3;\nconst char *const *p4;\nchar **const p5;\nconst char **const p6;\nchar *const *const p7;\nconst char *const* const p8;\n\n\n方法学会了么？\n以第4个为例，\n\n\n  首先抽出 *const p4, 证明这是一个const 指针\n  剩下的为const char *A\n  所以这是一个const指针指向[ 一个指向const char 类型的指针 ]\n\n\n答案\n\n\n  p1是指向char类型的指针的指针；\n  p2是指向const char类型的指针的指针；\n  p3是指向char类型的const指针；\n  p4是指向const char类型的const指针；\n  p5是指向char类型的指针的const指针；\n  p6是指向const char类型的指针的const指针；\n  p7是指向char类型const指针的const指针；\n  p8是指向const char类型的const指针的const指针。\n\n\n使用Typeof提升可读性\n\n良好的使用typedef可以使你的代码具有更好的可读性。\n比如：\n\ntypedef char * PCHAR;\n// 声明了2个指向字符的指针 p，q\nPCHAR p,q;\n//类比如下代码\nchar *p, q;\n\n\n最后一行代码读懂了么？乍一看是也是声明了2个指针。其实是声明了一个指针和一个char类型的变量。所以要分清指针的*表述的意思。\n\n与#define的区别\n\n\n  typedef 遵守作用域规则。而#define是全局的，全部替换，并且不能正确的处理指针类型。\n  但是#define 可以使用#ifedf。\n\n\n所以要根据实际情况进行选择。\n\n命名方式展开\n\n推荐采用：\n\nchar *p;\n\n\n这样(星号靠右)的命名方式，这样你才能理解到，这个指针是针对于p的。即，只有char，int等类型，和一个指针类型__*__, 前面的类型仅仅是用来标识，从内存中读出几位字节而已。这样理解就不会出现如上的声明方式，而产生误解。或者采用 typedef 来讲其进行别名转换。\n\n具体的好处可以参见如下：\n\ntypedef char *a;\ntypedef a b();\ntypedef b *c;\ntypedef c d();\ntypedef d *e;\ne var[10];\n\n\n是不是一下子就晕了。\n咱们来慢慢梳理一下。\n由后往前看。\n\n\n  这是一个 1.数组。 （1类型是e）\n  这是一个 2.指针类型的 1.数组。 （2指向的类型是d）\n  这是一个 3.指向函数的 2.指针类型的 1.数组。 （3函数返回的类型是c）\n  这是一个 4.指向有返回值的 3.指向函数的 2.指针类型的 1.数组。 （4指向的类型是b）\n  这是一个 4.指向返回值 5.是指针的 3.指向函数的 2.指针类型的 1.数组。 （5函数返回的类型是a）\n  这是一个 4.指向返回值 5.是指针指向 6.返回值是指向char类型的 3.指向函数的 2.指针类型的 1.数组。 （6指向的类型是char）\n\n\n是不是一下子就懂了呢。\n然后以此类推。\n初次使用typedef可能会晕，还是要多多练习。\n同时，在使用typedef时，注意。\n\n// 普通声明变量\nint a;\n// typedef申明变量别名\ntypedef int a;\n\n\ntypedef在保证原来申明语法不变的前提下，将原变量的命名，作为空格之前的__东西__作为它的别名。\n这点要在以后的函数指针中要理解透彻。\n\n为什么要封装成函数\n\n封装成函数可以：\n\n\n  提高可读性\n  提高健壮性\n  在修改函数的时候更加方便\n  维护程序的时候能够更好的去修改代码\n  适合项目中多人开发\n\n\n但同时也有一些不算缺点的问题：\n\n\n  封装函数反而降低维护性\n  封装函数产生技术困难\n  封装函数没有意思\n\n\n下面针对几点进行说明：\n\n// 使用函数\nint addValueFive(int a)\n{\n    return a += 5；\n}\n\n\n// 不使用函数\nint main()\n{\n    int i = 21;\n    // 其他code\n    i += 5；\n    return 0;\n}\n\n\n可读性更高，阅读他人代码的时候，可以跟读小说一样将代码的含义阅读出来。而不必去关心其余不相关的问题，比如这里的值是否正确，是否真的是要去加5而不是误输入等其他问题。\n\n当然封装函数的时候要掌握一个度，不需要将所有的功能全部拆分成块。毕竟在调用函数的时候也会产生相应的开销。在需要特殊优化的地方。这里应该也是需要被最后考虑的问题。\n\n其次在初学者学习的时候，容易犯下如此的错误：\n\n// wrong code 1\nvoid changeValue1(int i)\n{\n    i += 5;\n    printf(\"%d\", i);\n}\n// wrong code 2\nvoid changeValue2()\n{\n    int i = 21;\n    i += 5;\n    printf（\"%d\", i);\n}\n\nint main()\n{\n    int i1 = 21;\n    int i2 = 21;\n    changeValue1(i1);\n    changeValue2();\n    return 0;\n}\n\n\n乍一看，上述2个函数都完成了将i增加5的功能，并有效的输出了变换后的值，但是其实并没有真正的实现这一个功能，对于第一个代码来说，仅仅是对形参增加了5，对main函数自身的i并没有更改，而第二个代码。根本没有将功能封装成函数。这是初学者容易犯的错误。其实对于第二种代码片段，更像是其他语言所拥有的命名空间，偶尔在C语言中也可以如此使用，但是一定要确保自己的函数是正确的，并且自己知道这么做的后果是什么再去这样使用。\n\n全部功能写在main里有什么坏处\n\n初学者会烦的错误就是一般会将所有部分全都写在main函数中，这样做其实也有一定的好处。\n\n\n  不需要考虑同名变量的作用域\n  不需要考虑用指针去修改变量\n  数组可以直接获取到长度\n  思维直线式-符合初学者思维\n\n\n嗯，有这么多优点呢。这些优点就是你以后要努力克服不去触及的坑呢。如果不把坑填平，无论如何都不可能学会C的。甚至其他语言。\n上文提到过，程序的可读性这个问题，在你面对上百上千行代码的时候，而且全部揉在main中，这个程序的可读性基本是0，过了几个月后，开发者本身可能都不能理解其中的逻辑依赖关系，再三强调代码是给人读的所以一定要将代码抽成函数。\n抽出函数的时候，才能更好的提高自己的知识水平。\n全部都写在main里。总结来说会使你的代码越来越烂而已。无他。\n\n小提示：\n\n\\\\获取数组长度 只在申明了数组的同一函数内部中使用\n\\\\ 数组类型是int\nint size = sizeof(array) / sizeof(int);\n\\\\ 或使用如下方法\nint size = sizeof(array) / sizeof(array[0]);\n\n\n封装函数时会出现什么困难\n\n\n  程序封装函数后，传参出现问题，主要是由数组导致的（丢失了长度），产生数组越界或者其他bug\n  程序需要对多个变量进行更改，而返回值只有一个。需要更好的设计对整体操作进行拆分\n\n\n宏\n\n#define\n\n使用宏可以完成很多非常有用的功能，比如如下代码：\n\n__VA_ARGS__\n\n// C99支持\n#define showlist(...) puts(#__VA_ARGS__)\n// puts(\"\")\nshowlist();\n// puts(\"1,\\\"x\\\", int\")\nshowlist(1, \"x\", int);\n\n\n此时，应用：不需要输入”“\\等符号直接生成表示地址的字符串。\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define showlist(...) put_file_name(#__VA_ARGS__)\n\nchar file_name[100] ={0};\n\nchar* put_file_name(const char * file)\n{\n    int i = 0;\n\n    while((*file++) != '\\0')\n    {\n        file_name[i] = *(file - 1);\n        i++;\n        if(i == 98)\n            break;\n    }\n    file_name[i + 1] = '\\0';\n    return file_name;\n}\n\nint main()\n{\n    char *file;\n    int j = 0;\n    // 不需要写转义字符，直接书写地址。\n    file = showlist(\"D:\\code\\cplus\\TestGCC\\Test\\bin\\Debug\");\n    puts(file);\n    system(\"pause\");\n    return 0;\n}\n\n\n使用宏还可以装作模板来生成代码：(摘抄自手册)\n\n#include &lt;stdio.h&gt;\n\n//make function factory and use it\n#define FUNCTION(name, a) int fun_##name(int x) { return (a)*x;}\n\nFUNCTION(quadruple, 4)\nFUNCTION(double, 2)\n\n#undef FUNCTION\n#define FUNCTION 34\n#define OUTPUT(a) puts( #a )\n\nint main(void)\n{\n    printf(\"quadruple(13): %d\\n\", fun_quadruple(13) );\n    printf(\"double(21): %d\\n\", fun_double(21) );\n    printf(\"%d\\n\", FUNCTION);\n    OUTPUT(million);               //note the lack of quotes\n}\n\n\n其他问题点\n\nmalloc 和 free\n\nfree 掉malloc 开辟出来的内存时,是全部都会被free 掉.\n因为malloc 在开辟内存的时候,在内存之前添加了header.\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/01/study-of-C/"
      },
    
      {
        "title": "study of Java",
        "excerpt": "综述\n* Java 9 有坑 (+) 11-18\n* Java 学习\n* Java 学习\n\n\n备注 每日一更 +代表更新完成。-为待续\n\n\njava 9 对环境变量做了改动，原来的：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 中的dt.jar 和tools.jar 被取消了。所以现在只需要一个__[ . ]__\n嗯。就是这样。\n\n\n  \n    JAVA_HOME\n  JDK installation path, example: C:\\Program Files\\Java\\jdk-9\n  \n  \n    CLASSPATH \n  . (just a dot)\n  \n  \n    PATH \n  It may already exists on your system under the name Path, so edit its value by adding at the end: %JAVA_HOME%\\bin; If it not exists already, create a new one with the value %JAVA_HOME%\\bin;\n  \n\n\n初始化\n\n\n  java 保证了保证所有的成员变量都会被初始化\n\n\n相应的，如基本类型的 int， double 都有相应的固定的初始化值\n\n如自己创建的变量（类） 则会按照类的构造函数进行初始化。\n\n具体可以参加如下代码：\n研究 如果仅仅在main 中 new Cupboard(); 时， 产生的结果，不难得到：\n初始化的顺序为 static &gt; 成员变量 &gt; 构造函数。\n\nimport javax.management.MBeanNotificationInfo;\n\nclass Bowl {\n    Bowl(int marker) {\n        System.out.println(\"Bowl(\" + marker + \")\");\n    }\n\n    void f1(int marker) {\n        System.out.println(\"f1(\" + marker + \")\");\n    }\n}\n\nclass Table {\n    static Bowl bowl1 = new Bowl(1);\n\n    Table() {\n        System.out.println(\"Table()\");\n        bowl2.f1(1);\n    }\n\n    void f2(int marker) {\n        System.out.println(\"f2(\" + marker + \")\");\n    }\n\n    static Bowl bowl2 = new Bowl(2);\n}\n\nclass Cupboard {\n    Bowl bowl3 = new Bowl(3);\n    static Bowl bowl4 = new Bowl(4);\n\n    Cupboard() {\n        System.out.println(\"Cupboard()\");\n        bowl4.f1(2);\n    }\n\n    void f3(int marker) {\n        System.out.println(\"f3(\" + marker + \")\");\n    }\n\n    static Bowl bowl5 = new Bowl(5);\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Creating new Cupboard in main\");\n        new Cupboard();\n        System.out.println(\"Creating new Cupboard in main\");\n        new Cupboard();\n        table.f2(1);\n        cupboard.f3(1);\n    }\n\n    static Table table = new Table();\n    static Cupboard cupboard = new Cupboard();\n}\n\n\nout put\n\nBowl(1)\nBowl(2)\nTable()\nf1(1)\n// 特别的应该注意-----------\nBowl(4)\nBowl(5)\nBowl(3)\nCupboard()\nf1(2)\n// -----------------------\nCreating new Cupboard in main\nBowl(3)\nCupboard()\nf1(2)\nCreating new Cupboard in main\nBowl(3)\nCupboard()\nf1(2)\nf2(1)\nf3(1)\n\n\n",
        "content": "综述\n* Java 9 有坑 (+) 11-18\n* Java 学习\n* Java 学习\n\n\n备注 每日一更 +代表更新完成。-为待续\n\n\njava 9 对环境变量做了改动，原来的：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 中的dt.jar 和tools.jar 被取消了。所以现在只需要一个__[ . ]__\n嗯。就是这样。\n\n\n  \n    JAVA_HOME\n  JDK installation path, example: C:\\Program Files\\Java\\jdk-9\n  \n  \n    CLASSPATH \n  . (just a dot)\n  \n  \n    PATH \n  It may already exists on your system under the name Path, so edit its value by adding at the end: %JAVA_HOME%\\bin; If it not exists already, create a new one with the value %JAVA_HOME%\\bin;\n  \n\n\n初始化\n\n\n  java 保证了保证所有的成员变量都会被初始化\n\n\n相应的，如基本类型的 int， double 都有相应的固定的初始化值\n\n如自己创建的变量（类） 则会按照类的构造函数进行初始化。\n\n具体可以参加如下代码：\n研究 如果仅仅在main 中 new Cupboard(); 时， 产生的结果，不难得到：\n初始化的顺序为 static &gt; 成员变量 &gt; 构造函数。\n\nimport javax.management.MBeanNotificationInfo;\n\nclass Bowl {\n    Bowl(int marker) {\n        System.out.println(\"Bowl(\" + marker + \")\");\n    }\n\n    void f1(int marker) {\n        System.out.println(\"f1(\" + marker + \")\");\n    }\n}\n\nclass Table {\n    static Bowl bowl1 = new Bowl(1);\n\n    Table() {\n        System.out.println(\"Table()\");\n        bowl2.f1(1);\n    }\n\n    void f2(int marker) {\n        System.out.println(\"f2(\" + marker + \")\");\n    }\n\n    static Bowl bowl2 = new Bowl(2);\n}\n\nclass Cupboard {\n    Bowl bowl3 = new Bowl(3);\n    static Bowl bowl4 = new Bowl(4);\n\n    Cupboard() {\n        System.out.println(\"Cupboard()\");\n        bowl4.f1(2);\n    }\n\n    void f3(int marker) {\n        System.out.println(\"f3(\" + marker + \")\");\n    }\n\n    static Bowl bowl5 = new Bowl(5);\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Creating new Cupboard in main\");\n        new Cupboard();\n        System.out.println(\"Creating new Cupboard in main\");\n        new Cupboard();\n        table.f2(1);\n        cupboard.f3(1);\n    }\n\n    static Table table = new Table();\n    static Cupboard cupboard = new Cupboard();\n}\n\n\nout put\n\nBowl(1)\nBowl(2)\nTable()\nf1(1)\n// 特别的应该注意-----------\nBowl(4)\nBowl(5)\nBowl(3)\nCupboard()\nf1(2)\n// -----------------------\nCreating new Cupboard in main\nBowl(3)\nCupboard()\nf1(2)\nCreating new Cupboard in main\nBowl(3)\nCupboard()\nf1(2)\nf2(1)\nf3(1)\n\n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/01/study-of-Java/"
      },
    
      {
        "title": "study of Python",
        "excerpt": "* Python语法\n* Python新增语法(与C/C++不同的)\n* Python函数\n* 简单Python练习\n\n\n备注 每日一更 +代表更新完成。-为待续\n\n先占个坑\n\nPython语法\n\n众所周知，python是个动态类型的语言。意味着，你可以不用去声明变量类型就去使用它，但是一定要记住，python是一个强类型的语言，不用声明变量类型，不是所该语言不区分变量类型，而是语言本身在底层将转换替你做好了。\n所以在面对”123” + “3”和 123 + 3 时，你还是需要手工去确认它的类型。\n其他的函数细节直接help可以去查询相关的函数细节。\n对于python所提供的相对序列的操作相较C或者C++更为直观。可以讲python的这些数据结构理解为一个void* 的变长数据也好，或者一个打包好的object也好。（其实往往不需要去关心这些的内部细节）\n\n闭包\n\n闭包就是能够读取其他函数内部变量的函数。创建闭包的三点：（援引自网络）\n\n\n  \n    闭包函数必须有内嵌函数\n    内嵌函数需要引用该嵌套函数上一级namespace中的变量\n    闭包函数必须返回内嵌函数\n  \n\n\nlist\n\n相比较来说，list，以[]包括的元素，可以类比成C++中的vector，但是内部的元素可以是任意的类型，相比C++必须在vector中确定明确的数据类型，更加的便利和可读，能够实现插入，删除，更改的操作。同时也可以支持C风格的下标访问。\n\n特别的，在使用help时，内置函数的说明存在相互的包含关系，比如在list中的index，单独使用help(index())无法查询得到，需要使用\n\nhelp(list)\n\n\n来查询到相应的帮助文件。\n\n特别的，复制是浅复制（对一个的更改后，复制的内容也会更改）\n\na = [1,2,3]\nb = a\nb[1] = 100\n\n# b [1, 100, 3]\n# a [1, 100, 3]\n\n\ntuple\n\n与list相同，但是其中的数据不可更改，同时，list 和tuple可以相互转换。\n特别的python可以假装返回多个返回值。比如如下代码：\n\ndef fun():\n    return 1,2,3\nf = fun()\n# (1,2,3)\n# It will automatic change to tuple.\n\n\nPython新增语法(与C/C++不同的)\n\n语法\n\n分支语句\n\n不同于C语言的三目运算符。python使用如下的语法表示三目运算：\n\nvalue = x if boolStatus else y\n# boolStatus can be \"x &gt; y\" or anything you want\n\n\n如果boolStatus为真，则value的值为x，反之为y。\n\nforeach 循环\n\n类比C#中的foreach，但是python中只需要使用for就可以。\n\nfor i in listArray:\n    # something you want to do in the loops\n\n\n函数别名\n\n一个函数结尾必须要用()，如果没有()，相应的返回值就会成为这个函数的别名。\n换句话说，value = object.fun这样的语法，相当于讲fun这个函数起了一个别名叫做value，而不是所期望的获取这个函数的返回值。特别的，python可以对无返回值的函数对其他值进行赋值，（结果为none）\n\nc = print()\na = print\n\nc的值为none，类型为NoneType\na是一个函数\n\n\n字符串\n\n转义字符串\n\n可以通过将字符串前置r的形式将一段内容为地址的字符串转换成相应的增加转义字符的字符串。比如\n\nr'C:\\abc'\n\n\n将转换为C:\\\\abc\n\n大块字符串\n\n三个引号的字符串可以在其中直接包含一整段文字。包括空行\n\nstr = '''字符串\n字符串\n字符串'''\n\n\n将会被转换为'字符串\\n字符串\\n字符串'\n\n格式化字符串\n\n与C语言相似，可以通过%控制字符，对字符串进行格式上的设定，但是还是有不同的地方。python更为智能的可以对多个序列进行操作。可以实现如下代码：\n\n'%c %c %c' % (97, 98, 99)\n# 'a b c'\n'%c is not %c' % (97, 98)\n# 'b is not  c'\n\n\n这样的书写方式更像是去除了第一个参数的sprintf函数。其中，字符串和序列中的%是表明这里字符串的%是相关的格式控制字符。格式化设置同C语言。\n\n同时python还提供一种更类似于C#的格式控制。{}，但是使用这种方式的时候，需要使用字符串的内置函数 format。\n不过特别的，python还支持对替换位置命名。可以序号和命名同时出现，但是，序号不能出现在字符串的最后。\n\n\"{0} love {b}, {c}\".format(\"i\", c = \"coding\", b = \"reading\")\n# 'i love reading, coding'\n\n\nPython函数\n\nrange函数，可以自动产生一个序列，对于一个序列，python提供更为简单的初始化方式，比如，可以在初始化的时候设定步长，起始位置等参数。具体的细节也可以参见help函数。\n",
        "content": "* Python语法\n* Python新增语法(与C/C++不同的)\n* Python函数\n* 简单Python练习\n\n\n备注 每日一更 +代表更新完成。-为待续\n\n先占个坑\n\nPython语法\n\n众所周知，python是个动态类型的语言。意味着，你可以不用去声明变量类型就去使用它，但是一定要记住，python是一个强类型的语言，不用声明变量类型，不是所该语言不区分变量类型，而是语言本身在底层将转换替你做好了。\n所以在面对”123” + “3”和 123 + 3 时，你还是需要手工去确认它的类型。\n其他的函数细节直接help可以去查询相关的函数细节。\n对于python所提供的相对序列的操作相较C或者C++更为直观。可以讲python的这些数据结构理解为一个void* 的变长数据也好，或者一个打包好的object也好。（其实往往不需要去关心这些的内部细节）\n\n闭包\n\n闭包就是能够读取其他函数内部变量的函数。创建闭包的三点：（援引自网络）\n\n\n  \n    闭包函数必须有内嵌函数\n    内嵌函数需要引用该嵌套函数上一级namespace中的变量\n    闭包函数必须返回内嵌函数\n  \n\n\nlist\n\n相比较来说，list，以[]包括的元素，可以类比成C++中的vector，但是内部的元素可以是任意的类型，相比C++必须在vector中确定明确的数据类型，更加的便利和可读，能够实现插入，删除，更改的操作。同时也可以支持C风格的下标访问。\n\n特别的，在使用help时，内置函数的说明存在相互的包含关系，比如在list中的index，单独使用help(index())无法查询得到，需要使用\n\nhelp(list)\n\n\n来查询到相应的帮助文件。\n\n特别的，复制是浅复制（对一个的更改后，复制的内容也会更改）\n\na = [1,2,3]\nb = a\nb[1] = 100\n\n# b [1, 100, 3]\n# a [1, 100, 3]\n\n\ntuple\n\n与list相同，但是其中的数据不可更改，同时，list 和tuple可以相互转换。\n特别的python可以假装返回多个返回值。比如如下代码：\n\ndef fun():\n    return 1,2,3\nf = fun()\n# (1,2,3)\n# It will automatic change to tuple.\n\n\nPython新增语法(与C/C++不同的)\n\n语法\n\n分支语句\n\n不同于C语言的三目运算符。python使用如下的语法表示三目运算：\n\nvalue = x if boolStatus else y\n# boolStatus can be \"x &gt; y\" or anything you want\n\n\n如果boolStatus为真，则value的值为x，反之为y。\n\nforeach 循环\n\n类比C#中的foreach，但是python中只需要使用for就可以。\n\nfor i in listArray:\n    # something you want to do in the loops\n\n\n函数别名\n\n一个函数结尾必须要用()，如果没有()，相应的返回值就会成为这个函数的别名。\n换句话说，value = object.fun这样的语法，相当于讲fun这个函数起了一个别名叫做value，而不是所期望的获取这个函数的返回值。特别的，python可以对无返回值的函数对其他值进行赋值，（结果为none）\n\nc = print()\na = print\n\nc的值为none，类型为NoneType\na是一个函数\n\n\n字符串\n\n转义字符串\n\n可以通过将字符串前置r的形式将一段内容为地址的字符串转换成相应的增加转义字符的字符串。比如\n\nr'C:\\abc'\n\n\n将转换为C:\\\\abc\n\n大块字符串\n\n三个引号的字符串可以在其中直接包含一整段文字。包括空行\n\nstr = '''字符串\n字符串\n字符串'''\n\n\n将会被转换为'字符串\\n字符串\\n字符串'\n\n格式化字符串\n\n与C语言相似，可以通过%控制字符，对字符串进行格式上的设定，但是还是有不同的地方。python更为智能的可以对多个序列进行操作。可以实现如下代码：\n\n'%c %c %c' % (97, 98, 99)\n# 'a b c'\n'%c is not %c' % (97, 98)\n# 'b is not  c'\n\n\n这样的书写方式更像是去除了第一个参数的sprintf函数。其中，字符串和序列中的%是表明这里字符串的%是相关的格式控制字符。格式化设置同C语言。\n\n同时python还提供一种更类似于C#的格式控制。{}，但是使用这种方式的时候，需要使用字符串的内置函数 format。\n不过特别的，python还支持对替换位置命名。可以序号和命名同时出现，但是，序号不能出现在字符串的最后。\n\n\"{0} love {b}, {c}\".format(\"i\", c = \"coding\", b = \"reading\")\n# 'i love reading, coding'\n\n\nPython函数\n\nrange函数，可以自动产生一个序列，对于一个序列，python提供更为简单的初始化方式，比如，可以在初始化的时候设定步长，起始位置等参数。具体的细节也可以参见help函数。\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/01/study-of-Python/"
      },
    
      {
        "title": "study of Regular Expressions",
        "excerpt": "综述\n* 原字符 \n* 实例\n* 练习题\n\n\n备注 每日一更 +代表更新 -代表还在占坑中（没有内容暂待更新）\n更新内容：\n\n  新的元字符更新\n\n\n编程依赖\n使用C#作为正则表达式的学习工具，正则表达式在各种语言中都支持（自带或者相关的库）\n在这里使用C#作为学习的工具。\nC#中使用正则表达式可以有几种方式：\n// 本次主要采用这样的实现方式（便于书写）\nstring[] s = { \"catTheOtherText\", \"TheOtherTextcat\",\n               \"TheOtherText\", \"TheOthercatText\", \"ThecOtheraTextt\" };\nstring strRegular = \"^cat\";\nforeach( var str in s)\n{\n    Match match = Regex.Match(str, @strRegular);\n    if (match.Success)\n    {\n        Console.WriteLine(str + \"    The Regular is  \" + strRegular);\n    }\n\n}\n\n这种方式比较便于理解，但是其实缺少了很多相关的设置条件，相关的设置条件，每个语言有所不同，如果有需要，需要查阅相关的手册，进行确认。如果有需要（比如设置忽略大小写，在shell里是在正则表达式之前添加参数 -i），则用如下的这种方式进行书写：\nstring[] s = { \"catTheOtherText\", \"TheOtherTextcat\",\n               \"TheOtherText\", \"TheOthercatText\", \"ThecOtheraTextt\" };\nstring strRegular = \"^cat\";\n// 这里的RegexOptions 提供了更多正则表达式的相关选项。\n// 这里的IgnoreCase 是忽略大小写的含义\nRegex reg = new Regex(@strRegular, RegexOptions.IgnoreCase);\nforeach( var str in s)\n{\n    Match match = reg.Match(str);\n    \n    if (match.Success)\n    {\n        Console.WriteLine(str + \"    The Regular is  \" + strRegular);\n    }\n\n}\n\n\n元字符\n^\n行的起始 如：^cat 取得行首是cat的行\n\nstring[] s = { \"catTheOtherText\", \"TheOtherTextcat\",\n               \"TheOtherText\", \"TheOthercatText\", \"ThecOtheraTextt\" };\nstring strRegular = \"^cat\";\n// \"catTheOtherText\"\n\n$\n行的结束 如： cat$ 取得行尾是cat的行\nstring[] s = { \"catTheOtherText\", \"TheOtherTextcat\",\n                           \"TheOtherText\", \"TheOthercatText\", \"ThecOtheraTextt\" };\nstring strRegular = \"cat$\";\n// output\n// \"TheOtherTextcat\"\n\n\n[]\n匹配多个字符 如[ab] 匹配a或者b\nstring[] s = { \"aTheOtherText\", \"bTheOtherText\",\n               \"abTheOtherText\", \"TheOtheraText\", \"b\" };\nstring strRegular = \"[ab]\";\n// output\n// aTheOtherText    The Regular is  [ab]\n// bTheOtherText    The Regular is  [ab]\n// abTheOtherText    The Regular is  [ab]\n// TheOtheraText    The Regular is  [ab]\n// b    The Regular is  [ab]\n\n\n[-]\n[]中的连字符，可以连接有顺序的序列 如：[1-3] 取1到3中任意__一个__数 \n特别的[0123456789abcdefgABCDEFG]可以写作：[0-9a-gA-G] 或[A-G0-9a-g] (顺序无关)\n\n展开\n（以后讲到） 只有-在[]中是作为有意义的字符，其他字符保留原来含义。\nstring[] s = { \"2TheOtherText\", \"1TheOtherText\",\n               \"90TheOtherText\", \"TheOtheraText\", \"9\", \"TheOther?Text\" };\nstring strRegular = \"[0-9?]\";\n// 2TheOtherText    The Regular is  [0-9?]\n// 1TheOtherText    The Regular is  [0-9?]\n// 90TheOtherText    The Regular is  [0-9?]\n// 9    The Regular is  [0-9?]\n// TheOther?Text    The Regular is  [0-9?]\n\n\n[^]\n表示除此以外 如：[^a] 取得除了有a的行\n也可以使用[^0-9] 取得除了只包含0-9的其他行\nstring[] s = { \"123456\", \"Text\",\n               \"?Text\", \"123456Text\", \"9\" , \"?\", \n               \"Text123456\", \"T123e45x6t\" };\nstring strRegular = \"[^0-9?]\";\n// Text    The Regular is  [^0-9?]\n// ?Text    The Regular is  [^0-9?]\n// 123456Text    The Regular is  [^0-9?]\n// Text123456    The Regular is  [^0-9?]\n// T123e45x6t    The Regular is  [^0-9?]\n\n\n|\n或 如 ab|ba 匹配ab和ba\n如同编程中的|（或）\nstring[] s = { \"abc\", \"cba\",\n               \"bca\", \"ab\", \"a\"};\nstring strRegular = \"ab|ba\";\n// abc    The Regular is  ab|ba\n// cba    The Regular is  ab|ba\n// ab    The Regular is  ab|ba\n\n\n()\n使用()包含|，限制|的作用范围 则只针对括号中的内容进行或匹配 如a(ab|ba) 匹配aab 或者aba\nstring[] s = { \"abc\", \"cba\",\n                \"bca\", \"ab\", \"a\", \"aab\"};\nstring strRegular = \"c(ab|ba)\";\n// cba    The Regular is  c(ab|ba)\n\n值得注意的是，以下3者等价：\nstring strRegular1 = \"(Geoff|Jeff)(rey|ery)\";\nstring strRegular2 = \"(Geo|Je)ff(rey|ery)\";\nstring strRegular3 = \"(Geo|Je)ff(re|er)y\"\n\n下面这种方式与上面3者也等价（较为蠢）\nstring strOtherWayRegular = \"Jeffrey|Geoffery|Jeffery|Geoffrey\"; \n\n单词分界符\nC#的实现不同，本例参照所选用语言的正则表达式手册。\n标准中提供\\&lt;和\\&gt; 来匹配单词的首位，和末尾。\nC#中则只提供\\b 匹配单词分割，不特别区分首尾（看放置于哪个部分）。\n\n模糊匹配\n\n?\n一定会被匹配到。\n必须前面有一个字符, 前面字符出现__0次或1次__ 如 abca? 匹配abc或者abca\n一个有歧义，其实可以将多个用括号包裹起来，这样的话也算一个 如 ab(abc)? 匹配ababc或ab\nstring[] s = { \"abca\", \"abcaaa\",\n                \"abc\", \"abcd\", \"babcd\"};\nstring strRegular = \"abca?\";\n// abca    The Regular is  abca?\n// abcaaa    The Regular is  abca?\n// abc    The Regular is  abca?\n// abcd    The Regular is  abca?\n// babcd    The Regular is  abca?\n\nstring[] s = { \"ababc\", \"abca\",\n                \"babcdeg\", \"cbagcd\" };\nstring strRegular = \"ab(abc)?\";\n// ababc    The Regular is  ab(abc)?\n// abca    The Regular is  ab(abc)?\n// babcdeg    The Regular is  ab(abc)?\n\n\n+\n必须前面有一个字符, 前面字符出现__1次或多次__ 如 abca? 匹配abca或者abcaa\nstring[] s = { \"abca\", \"abcaaa\",\n                \"abc\", \"abcd\", \"babcd\"};\nstring strRegular = \"abca+\";\n// abca    The Regular is  abca+\n// abcaaa    The Regular is  abca+\n\n\n*\n一定会被匹配到。\n必须前面有一个字符, 前面字符出现__0次或多次__ 如 ba? 匹配b或者ba或者baa\nstring[] s = { \"abca\", \"abcaaa\",\n                \"abc\", \"abcd\", \"babcd\"};\nstring strRegular = \"abca*\";\n// abca    The Regular is  abca*\n// abcaaa    The Regular is  abca*\n// abc    The Regular is  abca*\n// abcd    The Regular is  abca*\n// babcd    The Regular is  abca*\n\n\n展开 ? *\n看了上面的例子是不是对这2个有点困惑。看起来结果是一样的。其实主要在于，只有存在于明确首尾的情况时，才能使之不同。比如：\n^aa?b和^aa*b\nstring[] s = { \"ab\", \"aaaab\",\n                \"aab\"};\nstring strRegular = \"^aa?b\";\n// ab    The Regular is  ^aa?b\n// aab    The Regular is  ^aa?b\n\nstring[] s = { \"ab\", \"aaaab\",\n                \"aab\"};\nstring strRegular = \"^aa*b\";\n// ab    The Regular is  ^aa*b\n// aaaab    The Regular is  ^aa*b\n// aab    The Regular is  ^aa*b\n\n\n练习\n[][^]\n'q1xText', 'Textq1',\n'q2cText', 'Textq2c' 1. `q[0-9][^x]` 会匹配哪一个呢？\n\n\n\n  \n    q[0-9][^x]$会匹配哪一个呢？\n  \n  \n    ^q[0-9][^x]会匹配哪一个呢？\n  \n\n\n答案\n\n  \n    q2cText    The Regular is  q[0-9][^x]\nTextq2c    The Regular is  q[0-9][^x]\n  \n  \n    Textq2c    The Regular is  q[0-9][^x]$\n  \n  \n    q2cText    The Regular is  ^q[0-9][^x]\n  \n\n",
        "content": "综述\n* 原字符 \n* 实例\n* 练习题\n\n\n备注 每日一更 +代表更新 -代表还在占坑中（没有内容暂待更新）\n更新内容：\n\n  新的元字符更新\n\n\n编程依赖\n使用C#作为正则表达式的学习工具，正则表达式在各种语言中都支持（自带或者相关的库）\n在这里使用C#作为学习的工具。\nC#中使用正则表达式可以有几种方式：\n// 本次主要采用这样的实现方式（便于书写）\nstring[] s = { \"catTheOtherText\", \"TheOtherTextcat\",\n               \"TheOtherText\", \"TheOthercatText\", \"ThecOtheraTextt\" };\nstring strRegular = \"^cat\";\nforeach( var str in s)\n{\n    Match match = Regex.Match(str, @strRegular);\n    if (match.Success)\n    {\n        Console.WriteLine(str + \"    The Regular is  \" + strRegular);\n    }\n\n}\n\n这种方式比较便于理解，但是其实缺少了很多相关的设置条件，相关的设置条件，每个语言有所不同，如果有需要，需要查阅相关的手册，进行确认。如果有需要（比如设置忽略大小写，在shell里是在正则表达式之前添加参数 -i），则用如下的这种方式进行书写：\nstring[] s = { \"catTheOtherText\", \"TheOtherTextcat\",\n               \"TheOtherText\", \"TheOthercatText\", \"ThecOtheraTextt\" };\nstring strRegular = \"^cat\";\n// 这里的RegexOptions 提供了更多正则表达式的相关选项。\n// 这里的IgnoreCase 是忽略大小写的含义\nRegex reg = new Regex(@strRegular, RegexOptions.IgnoreCase);\nforeach( var str in s)\n{\n    Match match = reg.Match(str);\n    \n    if (match.Success)\n    {\n        Console.WriteLine(str + \"    The Regular is  \" + strRegular);\n    }\n\n}\n\n\n元字符\n^\n行的起始 如：^cat 取得行首是cat的行\n\nstring[] s = { \"catTheOtherText\", \"TheOtherTextcat\",\n               \"TheOtherText\", \"TheOthercatText\", \"ThecOtheraTextt\" };\nstring strRegular = \"^cat\";\n// \"catTheOtherText\"\n\n$\n行的结束 如： cat$ 取得行尾是cat的行\nstring[] s = { \"catTheOtherText\", \"TheOtherTextcat\",\n                           \"TheOtherText\", \"TheOthercatText\", \"ThecOtheraTextt\" };\nstring strRegular = \"cat$\";\n// output\n// \"TheOtherTextcat\"\n\n\n[]\n匹配多个字符 如[ab] 匹配a或者b\nstring[] s = { \"aTheOtherText\", \"bTheOtherText\",\n               \"abTheOtherText\", \"TheOtheraText\", \"b\" };\nstring strRegular = \"[ab]\";\n// output\n// aTheOtherText    The Regular is  [ab]\n// bTheOtherText    The Regular is  [ab]\n// abTheOtherText    The Regular is  [ab]\n// TheOtheraText    The Regular is  [ab]\n// b    The Regular is  [ab]\n\n\n[-]\n[]中的连字符，可以连接有顺序的序列 如：[1-3] 取1到3中任意__一个__数 \n特别的[0123456789abcdefgABCDEFG]可以写作：[0-9a-gA-G] 或[A-G0-9a-g] (顺序无关)\n\n展开\n（以后讲到） 只有-在[]中是作为有意义的字符，其他字符保留原来含义。\nstring[] s = { \"2TheOtherText\", \"1TheOtherText\",\n               \"90TheOtherText\", \"TheOtheraText\", \"9\", \"TheOther?Text\" };\nstring strRegular = \"[0-9?]\";\n// 2TheOtherText    The Regular is  [0-9?]\n// 1TheOtherText    The Regular is  [0-9?]\n// 90TheOtherText    The Regular is  [0-9?]\n// 9    The Regular is  [0-9?]\n// TheOther?Text    The Regular is  [0-9?]\n\n\n[^]\n表示除此以外 如：[^a] 取得除了有a的行\n也可以使用[^0-9] 取得除了只包含0-9的其他行\nstring[] s = { \"123456\", \"Text\",\n               \"?Text\", \"123456Text\", \"9\" , \"?\", \n               \"Text123456\", \"T123e45x6t\" };\nstring strRegular = \"[^0-9?]\";\n// Text    The Regular is  [^0-9?]\n// ?Text    The Regular is  [^0-9?]\n// 123456Text    The Regular is  [^0-9?]\n// Text123456    The Regular is  [^0-9?]\n// T123e45x6t    The Regular is  [^0-9?]\n\n\n|\n或 如 ab|ba 匹配ab和ba\n如同编程中的|（或）\nstring[] s = { \"abc\", \"cba\",\n               \"bca\", \"ab\", \"a\"};\nstring strRegular = \"ab|ba\";\n// abc    The Regular is  ab|ba\n// cba    The Regular is  ab|ba\n// ab    The Regular is  ab|ba\n\n\n()\n使用()包含|，限制|的作用范围 则只针对括号中的内容进行或匹配 如a(ab|ba) 匹配aab 或者aba\nstring[] s = { \"abc\", \"cba\",\n                \"bca\", \"ab\", \"a\", \"aab\"};\nstring strRegular = \"c(ab|ba)\";\n// cba    The Regular is  c(ab|ba)\n\n值得注意的是，以下3者等价：\nstring strRegular1 = \"(Geoff|Jeff)(rey|ery)\";\nstring strRegular2 = \"(Geo|Je)ff(rey|ery)\";\nstring strRegular3 = \"(Geo|Je)ff(re|er)y\"\n\n下面这种方式与上面3者也等价（较为蠢）\nstring strOtherWayRegular = \"Jeffrey|Geoffery|Jeffery|Geoffrey\"; \n\n单词分界符\nC#的实现不同，本例参照所选用语言的正则表达式手册。\n标准中提供\\&lt;和\\&gt; 来匹配单词的首位，和末尾。\nC#中则只提供\\b 匹配单词分割，不特别区分首尾（看放置于哪个部分）。\n\n模糊匹配\n\n?\n一定会被匹配到。\n必须前面有一个字符, 前面字符出现__0次或1次__ 如 abca? 匹配abc或者abca\n一个有歧义，其实可以将多个用括号包裹起来，这样的话也算一个 如 ab(abc)? 匹配ababc或ab\nstring[] s = { \"abca\", \"abcaaa\",\n                \"abc\", \"abcd\", \"babcd\"};\nstring strRegular = \"abca?\";\n// abca    The Regular is  abca?\n// abcaaa    The Regular is  abca?\n// abc    The Regular is  abca?\n// abcd    The Regular is  abca?\n// babcd    The Regular is  abca?\n\nstring[] s = { \"ababc\", \"abca\",\n                \"babcdeg\", \"cbagcd\" };\nstring strRegular = \"ab(abc)?\";\n// ababc    The Regular is  ab(abc)?\n// abca    The Regular is  ab(abc)?\n// babcdeg    The Regular is  ab(abc)?\n\n\n+\n必须前面有一个字符, 前面字符出现__1次或多次__ 如 abca? 匹配abca或者abcaa\nstring[] s = { \"abca\", \"abcaaa\",\n                \"abc\", \"abcd\", \"babcd\"};\nstring strRegular = \"abca+\";\n// abca    The Regular is  abca+\n// abcaaa    The Regular is  abca+\n\n\n*\n一定会被匹配到。\n必须前面有一个字符, 前面字符出现__0次或多次__ 如 ba? 匹配b或者ba或者baa\nstring[] s = { \"abca\", \"abcaaa\",\n                \"abc\", \"abcd\", \"babcd\"};\nstring strRegular = \"abca*\";\n// abca    The Regular is  abca*\n// abcaaa    The Regular is  abca*\n// abc    The Regular is  abca*\n// abcd    The Regular is  abca*\n// babcd    The Regular is  abca*\n\n\n展开 ? *\n看了上面的例子是不是对这2个有点困惑。看起来结果是一样的。其实主要在于，只有存在于明确首尾的情况时，才能使之不同。比如：\n^aa?b和^aa*b\nstring[] s = { \"ab\", \"aaaab\",\n                \"aab\"};\nstring strRegular = \"^aa?b\";\n// ab    The Regular is  ^aa?b\n// aab    The Regular is  ^aa?b\n\nstring[] s = { \"ab\", \"aaaab\",\n                \"aab\"};\nstring strRegular = \"^aa*b\";\n// ab    The Regular is  ^aa*b\n// aaaab    The Regular is  ^aa*b\n// aab    The Regular is  ^aa*b\n\n\n练习\n[][^]\n'q1xText', 'Textq1',\n'q2cText', 'Textq2c' 1. `q[0-9][^x]` 会匹配哪一个呢？\n\n\n\n  \n    q[0-9][^x]$会匹配哪一个呢？\n  \n  \n    ^q[0-9][^x]会匹配哪一个呢？\n  \n\n\n答案\n\n  \n    q2cText    The Regular is  q[0-9][^x]\nTextq2c    The Regular is  q[0-9][^x]\n  \n  \n    Textq2c    The Regular is  q[0-9][^x]$\n  \n  \n    q2cText    The Regular is  ^q[0-9][^x]\n  \n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/01/study-of-Regular-Expressions/"
      },
    
      {
        "title": "计算机网络学习笔记",
        "excerpt": "一些东西还是用中文总结一下，然后看看有没有可能再用英语写，叹气自己的英语水平。学习计算机网络的书本是:计算机网络自顶向下方法(computer networking A top-down approach)\n\n概念术语说明\n\n端系统(end system) 彼此交换报文，通过通信链路(communication link)和 分组交换机 (Packet switch)连接在一起。 端系统通过因特网服务提供商(Internet Service Provider ISP)接入互联网。端系统、分组交换机和其他因特网部件都要运行一系列协议。TCP/IP 为因特网主要的协议。与因特网相连的端系统提供了一个套接字接口(socket interface)。\n\n分组 Packet: 当一台端系统向另外的一台端系统发送数据的时候，发送端系统讲数据分段，并为每段加上首部字节，由此形成的信息包。\n\n每个分组都要经过\n\n  分组交换机(Packet switch)\n  通信链路(communication link)\n\n\n通过分组交换机和通信链路的有\n\n  电路交换(circuit switching)\n  分组交换(packet switching)\n\n\n分组交换机 Packet switch: 从一条入通信链路接受到达的分组，并从他的一条出通信链路转发该分组。 多数分组交换机在链路的输入端使用存储转发传输(store-and-forward transmission)\n\n\n  与电路交换的区别见下\n\n\n交换机主要有\n\n  有路由器(router)\n  链路层交换机 (link-layer switch)。\n\n\n存储转发传输 store-and-forward transmission: 交换机能够在开始向输出链路传输该跟组的第一个比特之前，必须接收到整个分组。\n\n路径 route/path: 一个分组所经历的一系列通信链路和分组交换机。\n\n协议 protocol: 控制因特网中信息的发送和接收。定义了两个或者多个通信实体之间交换的报文格式和顺序，以及报文(message)发送/接收一条报文或其他时间所采取的动作。\n\n传输控制协议 TCP (Transmission control Protocol)\n\n网际协议 IP (Internet Protocol): 路由器和端系统直接发送和接收的分组格式。\n\n分布式应用程序 distributed application: 涉及多个相互交换数据的端系统\n\n套接字接口 socket interface: 规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的程序交付数据的方式。\n\n互联网两种描述方式\n\n  硬件 软件\n  基础设施向分布式应用程序提供的服务\n\n\n丢包 packet loss: 分组到达分组交换机时，分组交换机的(output buffer/output queue) 已经充满，则该分组将被丢弃。\n\n排队时延 queuing delay: 分组在交换机等待被转发的时间。\n\n转发表 forwarding table: 每台路由器将目的地址（或目的地址的一部分）映射成为输出链路。当分组到达一台路由时，路由器检查该地址，并用这个目的地址搜索其转发表，发现适合的输出链路，并转发出。\n\n时延 (delay): 主要有\n\n\n  节点处理时延 nodal processing delay\n  排队时延 queuing delay\n  传输时延 transmission delay\n  传播时延 propagation delay\n\n\n\n  传输时延和传播时延的区别见下\n\n\n这些何在一起就是时节点总时延 (total nodal delay)\n\n复用 Multiplexing: 主要是在一定带宽内，通过不同的频率或者时间间隔，传输来自不同源的数据的方式。\n\n主要有\n\n  频分复用 Frequency-Division Multiplexing FDM\n  时分复用 Time-Division Multiplexing TDM\n\n\n复杂概念\n\n分组交换和电路交换的对比\n\n分组交换\n\n缺点：\n\n\n  不适合实时的服务 （端到端的时延是不可预测和可变的）\n\n\n优点：\n\n\n  提供了更好的带宽共享\n  更简单，实现成本低\n  按需在链路上分配，用户按照分组之间被共享\n\n\n传输时延和传播时延的对比\n\n以车队经过收费站并到下一个收费站做比喻：\n\n传输时延： 路由器推出分组需要的时延 （车队长度和收费站服务速度）\n\n有关：\n\n\n  分组长度和链路传输速率\n\n\n传播时延： 一台路由器到另外一台之间所需要的时延（车队在路上的行进速度）\n\n有关：\n\n\n  两台路由器之间的距离\n\n\n",
        "content": "一些东西还是用中文总结一下，然后看看有没有可能再用英语写，叹气自己的英语水平。学习计算机网络的书本是:计算机网络自顶向下方法(computer networking A top-down approach)\n\n概念术语说明\n\n端系统(end system) 彼此交换报文，通过通信链路(communication link)和 分组交换机 (Packet switch)连接在一起。 端系统通过因特网服务提供商(Internet Service Provider ISP)接入互联网。端系统、分组交换机和其他因特网部件都要运行一系列协议。TCP/IP 为因特网主要的协议。与因特网相连的端系统提供了一个套接字接口(socket interface)。\n\n分组 Packet: 当一台端系统向另外的一台端系统发送数据的时候，发送端系统讲数据分段，并为每段加上首部字节，由此形成的信息包。\n\n每个分组都要经过\n\n  分组交换机(Packet switch)\n  通信链路(communication link)\n\n\n通过分组交换机和通信链路的有\n\n  电路交换(circuit switching)\n  分组交换(packet switching)\n\n\n分组交换机 Packet switch: 从一条入通信链路接受到达的分组，并从他的一条出通信链路转发该分组。 多数分组交换机在链路的输入端使用存储转发传输(store-and-forward transmission)\n\n\n  与电路交换的区别见下\n\n\n交换机主要有\n\n  有路由器(router)\n  链路层交换机 (link-layer switch)。\n\n\n存储转发传输 store-and-forward transmission: 交换机能够在开始向输出链路传输该跟组的第一个比特之前，必须接收到整个分组。\n\n路径 route/path: 一个分组所经历的一系列通信链路和分组交换机。\n\n协议 protocol: 控制因特网中信息的发送和接收。定义了两个或者多个通信实体之间交换的报文格式和顺序，以及报文(message)发送/接收一条报文或其他时间所采取的动作。\n\n传输控制协议 TCP (Transmission control Protocol)\n\n网际协议 IP (Internet Protocol): 路由器和端系统直接发送和接收的分组格式。\n\n分布式应用程序 distributed application: 涉及多个相互交换数据的端系统\n\n套接字接口 socket interface: 规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的程序交付数据的方式。\n\n互联网两种描述方式\n\n  硬件 软件\n  基础设施向分布式应用程序提供的服务\n\n\n丢包 packet loss: 分组到达分组交换机时，分组交换机的(output buffer/output queue) 已经充满，则该分组将被丢弃。\n\n排队时延 queuing delay: 分组在交换机等待被转发的时间。\n\n转发表 forwarding table: 每台路由器将目的地址（或目的地址的一部分）映射成为输出链路。当分组到达一台路由时，路由器检查该地址，并用这个目的地址搜索其转发表，发现适合的输出链路，并转发出。\n\n时延 (delay): 主要有\n\n\n  节点处理时延 nodal processing delay\n  排队时延 queuing delay\n  传输时延 transmission delay\n  传播时延 propagation delay\n\n\n\n  传输时延和传播时延的区别见下\n\n\n这些何在一起就是时节点总时延 (total nodal delay)\n\n复用 Multiplexing: 主要是在一定带宽内，通过不同的频率或者时间间隔，传输来自不同源的数据的方式。\n\n主要有\n\n  频分复用 Frequency-Division Multiplexing FDM\n  时分复用 Time-Division Multiplexing TDM\n\n\n复杂概念\n\n分组交换和电路交换的对比\n\n分组交换\n\n缺点：\n\n\n  不适合实时的服务 （端到端的时延是不可预测和可变的）\n\n\n优点：\n\n\n  提供了更好的带宽共享\n  更简单，实现成本低\n  按需在链路上分配，用户按照分组之间被共享\n\n\n传输时延和传播时延的对比\n\n以车队经过收费站并到下一个收费站做比喻：\n\n传输时延： 路由器推出分组需要的时延 （车队长度和收费站服务速度）\n\n有关：\n\n\n  分组长度和链路传输速率\n\n\n传播时延： 一台路由器到另外一台之间所需要的时延（车队在路上的行进速度）\n\n有关：\n\n\n  两台路由器之间的距离\n\n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
      },
    
      {
        "title": "数据结构和算法",
        "excerpt": "通过反复的练习，达到自己手写的程度（白板写代码），基本上为了理解好的代码，进行的代码摘抄。\n\n基本数据结构\n\n通过反复的练习，达到自己手写的程度（白板写代码）\n每个数据结构的实现必须熟悉（最为基本的实现）虽然C++或者其他语言都有这相应的的基本实现，可以直接调用使用，（调用库函数）但是还是应该能够直接手写出代码。以其获得更为具体的优化。（能所不能）\n相应的，要理解每个数据结构的优缺点。\n\n展开\n\n以后自己的代码也需要这样的设计。建立一个良好的接口，增加程序代码的复用。\n比如在上记得代码中，对链表这个数据结构进行了抽象，相同的结构如：\n\n\n  插入\n  删除\n  头节点\n  尾结点\n  链表长度\n  链表初始化\n  链表销毁\n\n\n这些地方这3种数据结构操作相似。可以进行抽象，在其他提供类的语言中，这些可以通过类进行继承，以期实现代码的复用。\n\n对于工作之中，使代码多结构化可以减少需求变更的情况下，尽可能的减少修改代码的行数。\n比如，链表实现的代码中，需要添加一个功能，那么可以只需要在list中实现这个功能，其他数据结构就可以通过相应的参数，return给相关的函数。\n另外比如需要修改插入函数，那么仅仅只需要在list函数中就行修改就可以保证，剩下的数据结构同时被修改。\n\n这里的数据结构可以替换成其他工作中需要实现的功能等。结果同样。\n\nC语言编程细节\n\n注意因为C语言没有bool类型。所以在返回值的时候，会出现 -1， 0， 1等多种情况。因为在C中True 是任意的非0数字，只有0是false, 所以在写自己的函数的时候，要注意自己的函数应该返回状态码（比如一些函数错误结束后的返回-1），还是用于if判断的（0，1）\n\n链表系\n\n单链表\n\n最为简单的数据结构，每个节点为一个自己定义的结构（包含数据，指针 指向下一个节点）\n因为只保存了下一个节点的地址，所以单链表是不可以倒序遍历的，也不能随机访问。必须由头节点逐个依次的访问。\n    如果每个下一个节点有重复则称之为循环链表 &lt;-判断是否成环也是相应的算法题之一，并且我觉得也是一些有用的算法题，需要特别记忆的。\n特别的：\n\n\n  每个节点的位置是离散的（后一个节点的内存位置并不是在节点内存的下一个） 这种分散的特性，相比数组的连续内存有些时候会更加高效。\n  如果发生删除操作一定要先获取以后节点的地址\n\n\n如果插入、删除的__位置为NULL__，则默认插入、删除的位置在表头。\n\n//节点定义\ntypedef struct ListElmt_\n{\n    void *data; // can use point to get the real data\n    struct ListElmt_ * next;\n} ListElmt;\n\ntypedef struct List_\n{\n    int size;\n    int(*match)(const void *key1, const void *key2);\n    void(*destroy)(void *data);\n    ListElmt *head;\n    ListElmt *tail;\n} List;\n\n\n然后定义相关的函数： 增删查改\n\n//接口函数\nvoid list_init(List *list, void(*destroy)(void *data));\nvoid list_destroy(List *list);\n\n// should use bool but C do not give bool before C99\nint list_ins_next(List *list, ListElmt *element, const void * data);\n/* when you want to remove a element, you should give the value to the programer\n/ because they want to use this data, you can not just delete the element and do nothing\n/ also the element can be return as return value, but in this way, you can not judge\n/ if it has been remove already */\nint list_rem_next(List *list, ListElmt *element, void **data);\n\n// in other language you should use inline function instead of using macro\n#define list_size(list) ((list)-&gt;size)\n#define list_head(list) ((list)-&gt;head)\n#define list_tail(list) ((list)-&gt;tail)\n#define list_is_head(list, element) ((element) == (list)-&gt;head ? 1 : 0)\n#define list_is_tail(element) ((element)-&gt;next == NULL ? 1 : 0)\n#define list_data(element) ((element)-&gt;data)\n#define list_next(element) ((element)-&gt;next)\n\n\n//函数实现\nvoid list_init(List *list, void(*destroy)(void *data))\n{\n    list-&gt;size = 0;\n    list-&gt;destroy = destroy;\n    list-&gt;head = NULL;\n    list-&gt;tail = NULL;\n}\n\nvoid list_destroy(List *list)\n{\n    void *data;\n    while (list_size(list) &gt; 0)\n    {\n        if (list_rem_next(list, NULL, (void **)&amp;data) == 0 &amp;&amp; list-&gt;destory != NULL)\n        {\n\n            list-&gt;destory(data);\n        }\n    }\n    memset(list, 0, sizeof(List));\n}\n\nint list_ins_next(List *list, ListElmt *element, const void * data)\n{\n    ListElmt * new_element;\n    if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL)\n        return -1;\n    new_element-&gt;data = (void *)data;\n    // if element is null insert the data in the head of list\n    if (element == NULL)\n    {\n        if (list_size(list) == 0)\n            list-&gt;tail = new_element;\n        new_element-&gt;next = list-&gt;head;\n        list-&gt;head = new_element;\n    }\n    else\n    {\n        if (element-&gt;next == NULL)\n            list-&gt;tail = new_element;\n        // here you can use new_element-&gt;next = NULL\n        new_element-&gt;next = element-&gt;next;\n        element-&gt;next = new_element;\n    }\n    list-&gt;size++;\n    return 0;\n}\n\nint list_rem_next(List *list, ListElmt *element, void **data)\n{\n    ListElmt *old_element;\n    if (list_size(list) == 0)\n        return -1;\n    // if element is null remove the data in the head of list\n    if (element == NULL)\n    {\n        *data = list-&gt;head-&gt;data;\n        old_element = list-&gt;head;\n        list-&gt;head = list-&gt;head-&gt;next;\n\n        if (list_size(list) == 1)\n            list-&gt;tail = NULL;\n    }\n    else\n    {\n        if (element-&gt;next == NULL)\n            return -1;\n        *data = element-&gt;next-&gt;data;\n        old_element = element-&gt;next;\n        // you can use element-&gt;next = old_element-&gt;next;\n        element-&gt;next = element-&gt;next-&gt;next;\n\n        if (element-&gt;next == NULL)\n            list-&gt;tail = NULL;\n    }\n    free(old_element);\n    list-&gt;size--;\n    return 0;\n}\n\n\n当然， 我们应该还要编写相应的find函数，destroy函数，来使得这个链表程序更加的完整。\n\n也可以类比其他书籍查看不同，比如\n\n  数据结构与算法分析 C语言描述\n\n\n就可以明白在不同的编程思路下，虽然是同一数据结构，但是代码可能会完全不同。具体喜欢哪种风格，那还是需要自己见仁见智了。\n\n栈\n\n栈的实现方式很简单，可以通过很多的方式来实现，栈只要保证操作只在头部就可以称之为栈。这里栈的实现是利用先前做出的假设，如果插入位置为空的话将操作位置设定为表的头部\n\n//节点定义\ntypedef List Stack;\n\n\n//接口函数\n#define stack_init list_init\n#define stack_destroy list_destroy\n\n#define stack_peek(stack) ((stack)-&gt;head == NULL ? NULL : (stack)-&gt;head-&gt;data)\n#define stack_size list_size\n\nint stack_push(Stack *stack, const void *data);\nint stack_pop(Stack *stack, void **data);\n\n\n//函数实现\nint stack_push(Stack *stack, const void *data)\n{\n    return list_ins_next(stack, NULL, data);\n}\n\nint stack_pop(Stack *stack, void **data)\n{\n    return list_rem_next(stack, NULL, data);\n}\n\n\n队列\n\n队列也可以看作特殊的链表，操作分别在头尾两端。在头部进行删除，在尾部进行插入。\n同栈一样，没有操作内部节点的接口。\n\n//节点定义\ntypedef List Queue;\n\n\n//接口函数\n#define queue_init list_init\n#define queue_destroy list_destroy\n\n#define queue_peek(queue) ((queue)-&gt;head == NULL ? NULL : (queue)-&gt;head-&gt;data)\n#define queue_size list_size\n\nint queue_enqueue(Queue *queue, const void *data);\nint queue_dequeue(Queue *queue, void **data);\n\n\n//函数实现\nint queue_enqueue(Queue *queue, const void *data)\n{\n    return list_ins_next(queue, list_tail(queue), data);\n}\nint queue_dequeue(Queue *queue, void **data)\n{\n    return list_rem_next(queue, NULL, data);\n}\n\n\n栈和队列可以使用不同的实现方式，比如链表，或者是可以增长的数组。简单的思路如下：\n如果对于数据的插入，删除的个数确定，可以简单的使用数组进行实现，（惰性删除即可，或直接在建立的初期为以后的插入位置进行预留等其他的实现方式），或者更进一步，使用其他语言提供的库函数进行封装。\n另外，数据量确定和可读性起见，可以直接在结构体中包含所需要的数据。这时，可以建立单独的带有类型的链表，如int类型的链表，char类型的链表等。\n\n上述实现是通过链表系作为接口，修改而成的。如果单纯只使用其中一种数据结构，可以针对这种结构单独写出。\n\n集合\n\n集合是一种很特殊的数据结构，（set），它所拥有的性质元素唯一性，可以为编程提供很大的便利。比如去重可以直接将数据存入到set就可以了。\n\n//节点定义\ntypedef List Set;\n\n\n//接口函数\nvoid set_init(Set *set, int(*match)(const void *key1, const void *key2), void(*destroy)(void *data));\nint set_insert(Set *set, const void *data);\nint set_remove(Set *set, void **data);\nint set_union(Set *setu, const Set *set1, const Set *set2);\nint set_intersction(Set *seti, const Set *set1, const Set *set2);\nint set_difference(Set *setd, const Set *set1, const Set *set2);\nint set_is_member(const Set *set, const void *data);\nint set_is_subset(const Set *set1, const Set *set2);\nint set_is_equal(const Set *set1, const Set *set2);\n\n#define set_size(set) ((set)-&gt;size)\n#define set_destroy list_destroy\n\n\n//函数实现\nvoid set_init(Set *set, int(*match)(const void *key1, const void *key2), void(*destroy)(void *data))\n{\n    list_init(set, destroy);\n    set-&gt;match = match;\n}\n\nint set_insert(Set *set, const void *data)\n{\n    if (set_is_member(set, data))\n        return 1;\n    return list_ins_next(set, list_tail(set), data);\n}\n\nint set_remove(Set *set, void **data)\n{\n    ListElmt *member;\n    ListElmt *prev;\n\n    prev = NULL;\n\n    for (member = list_head(set); member != NULL; member = list_next(member))\n    {\n        if (set-&gt;match(*data, list_data(member)))\n            break;\n        prev = member;\n    }\n    if (member == NULL)\n        return -1;\n\n    return list_rem_next(set, prev, data);\n}\n\nint set_union(Set *setu, const Set *set1, const Set *set2)\n{\n    ListElmt *member;\n    void *data;\n\n    set_init(setu, set1-&gt;match, NULL);\n    for (member = list_head(set1); member != NULL; member = list_next(member))\n    {\n        data = list_data(member);\n        if (list_ins_next(setu, list_tail(setu), data) != 0)\n        {\n            set_destroy(setu);\n            return -1;\n        }\n    }\n    for (member = list_head(set2); member != NULL; member = list_next(member))\n    {\n        if (set_is_member(set1, list_data(member)))\n        {\n            continue;\n        }\n        else\n        {\n            data = list_data(member);\n            if (list_ins_next(setu, list_tail(setu), data) != 0)\n            {\n                set_destroy(setu);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nint set_intersection(Set *seti, const Set *set1, const Set *set2)\n{\n    ListElmt * member;\n    void *data;\n\n    set_init(seti, set1-&gt;match, NULL);\n    for (member = list_head(set1); member != NULL; member = list_next(member))\n    {\n        if (set_is_member(set2, list_data(member)))\n        {\n            data = list_data(member);\n            if (list_ins_next(seti, list_tail(seti), data) != 0)\n            {\n                set_destroy(seti);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nint set_difference(Set *setd, const Set *set1, const Set *set2)\n{\n    ListElmt *member;\n    void *data;\n\n    set_init(setd, set1-&gt;match, NULL);\n\n    for (member = list_head(set1); member != NULL; member = list_next(member))\n    {\n        if (!set_is_member(set2, list_data(member)))\n        {\n            data = list_data(member);\n            if (list_ins_next(setd, list_tail(setd), data) != 0)\n            {\n                set_destroy(setd);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nint set_is_member(const Set *set, const void *data)\n{\n    ListElmt *member;\n    for (member = list_head(set); member != NULL; member = list_next(member))\n    {\n        if (set-&gt;match(data, list_data(member)))\n            return 1;\n    }\n    return 0;\n}\n\nint set_is_subset(const Set *set1, const Set *set2)\n{\n    ListElmt *member;\n    if (set_size(set1) &gt; set_size(set2))\n        return 0;\n    for (member = list_head(set1); member != NULL; list_next(member))\n    {\n        if (!set_is_member(set2, list_data(member)))\n            return 0;\n    }\n    return 1;\n}\n\nint set_is_equal(const Set *set1, const Set *set2)\n{\n    if (set_size(set1) != set_size(set2))\n        return 0;\n    return set_is_subset(set1, set2);\n}\n\n\n哈希表\n\n哈希表其实作为以后会更加频繁出现的数据结构一定要学习的非常深入。\n区块链等新的技术基本上也利用了如此的原理来实现。\n哈希表，通过唯一的哈希值保证每个元素都可以在O(1)的时间内被访问。\n\n//节点定义\ntypedef struct CHTbl_\n{\n    int buckets;\n    int(*h)(const void *key);\n    int(*match)(const void *key1, const void *key2);\n    void(*destroy)(void *data);\n\n    int size;\n    List *table;\n}CHTbl;\n\n\n//接口函数\nint chtbl_init(CHTbl *htbl, int buckets, int(*h)(const void *key),\n    int(*match)(const void *key1, const void *key2), void(*destroy)(void *data));\nvoid chtbl_destroy(CHTbl *htbl);\nint chtbl_insert(CHTbl * htbl, const void *data);\nint chtbl_remove(CHTbl*htbl, void *data);\nint chtbl_lookup(const CHTbl *htbl, void **data);\n\n#define chtbl_size(htbl) ((htbl)-&gt;size)\n\n\n//函数实现\nint chtbl_init(CHTbl *htbl, int buckets, int(*h)(const void *key),\n    int(*match)(const void *key1, const void *key2), void(*destroy)(void *data))\n{\n    int i;\n    if ((htbl-&gt;table = (List *)malloc(buckets * sizeof(List))) == NULL)\n        return -1;\n\n    htbl-&gt;buckets = buckets;\n\n    for (i = 0; i &lt; htbl-&gt;buckets; i++)\n        list_init(&amp;htbl-&gt;table[i], destroy);\n    htbl-&gt;h = h;\n    htbl-&gt;match = match;\n    htbl-&gt;destroy = destroy;\n\n    htbl-&gt;size = 0;\n\n    return 0;\n}\n\nvoid chtbl_destroy(CHTbl *htbl)\n{\n    int i;\n    for (i = 0; i &lt; htbl-&gt;buckets; i++)\n        list_destroy(&amp;htbl-&gt;table[i]);\n\n    free(htbl-&gt;table);\n    memset(htbl, 0, sizeof(CHTbl));\n}\n\nint chtbl_insert(CHTbl *htbl, const void *data)\n{\n    void *temp;\n    int bucket;\n    int retval;\n\n    temp = (void *)data;\n\n    if (chtbl_lookup(htbl, &amp;temp) == 0)\n        return 1;\n\n    bucket = htbl-&gt;h(data) % htbl-&gt;buckets;\n\n    if ((retval = list_ins_next(&amp;htbl-&gt;table[bucket], NULL, data)) == 0)\n        htbl-&gt;size++;\n    return retval;\n}\n\nint chtbl_remove(CHTbl *htbl, void **data)\n{\n    ListElmt *element,\n        *prev;\n\n    int bucket;\n\n    bucket = htbl-&gt;h(*data) % htbl-&gt;buckets;\n\n    prev = NULL;\n\n    for(element = list_head(&amp;htbl-&gt;table[bucket]); element != NULL;\n    element = list_next(element))\n    {\n        if (htbl-&gt;match(*data, list_data(element)))\n        {\n            if (list_rem_next(&amp;htbl-&gt;table[bucket], prev, data) == 0)\n            {\n                htbl-&gt;size--;\n                return 0;\n            }\n            else\n            {\n                return -1;\n            }\n        }\n        prev = element;\n    }\n    return -1;\n}\n\nint chtbl_lookup(const CHTbl *htbl, void **data)\n{\n    ListElmt *element;\n    int bucket;\n\n    bucket = htbl-&gt;h(*data) % htbl-&gt;buckets;\n\n    for (element = list_head(&amp;htbl-&gt;table[bucket]); element != NULL;\n        element = list_next(element))\n    {\n        if (htbl-&gt;match(*data, list_data(element)))\n        {\n            *data = list_data(element);\n            return 0;\n        }\n    }\n    return -1;\n\n}\n\n\n树系\n\n树是一定要熟练掌握的数据结构，包括相应的算法，比如，反转二叉树，最短路径等，一定要在理解的前提下，可以手写代码。\n\n//节点定义\ntypedef struct BiTreeNode_\n{\n    void *data;\n    struct BiTreeNode_ *left;\n    struct BiTreeNoed_ *right;\n} BiTreeNode;\n\ntypedef struct BiTree_\n{\n    int size;\n    int(*compare) (const void *key1, const void *key2);\n    void(*destroy)(void *data);\n\n    BiTreeNode *root;\n} BiTree;\n\n\n//接口函数\nvoid bitree_init(BiTree *tree, void(*destroy) (void *data));\nvoid bitree_destroy(BiTree *tree);\nint bitree_ins_left(BiTree *tree, BiTreeNode *node, const void *data);\nint bitree_ins_right(BiTree *tree, BiTreeNode *node, const void *data);\nvoid bitree_rem_left(BiTree *tree, BiTreeNode *node);\nvoid bitree_rem_right(BiTree *tree, BiTreeNode *node);\nint bitree_merge(BiTree *merge, BiTree *left, BiTree *right, const void *data);\n\n#define bitree_size(tree) ((tree)-&gt;size)\n#define bitree_root(tree) ((tree)-&gt;root)\n#define bitree_is_eob(node) ((node)==NULL)\n#define bitree_is_left(node) ((node)-&gt;left==NULL &amp;&amp; (node)-&gt;right==NULL)\n#define bitree_data(node) ((node)-&gt;data)\n#define bitree_left(node) ((node)-&gt;left)\n#define bitree_right(node) ((node)-&gt;right)\n\n\n//函数实现\n\n\n\n基本算法 （C）\n\n最大子序列和\n\nint max_sub_sequence(const int a[], int n) {\n    int this_sum, max_sum;\n    this_sum = max_sum = 0;\n    for(int i = 0; i &lt; N; i++) {\n        this_sum += a[i];\n        if(this_sum &gt; max_sum)\n            max_sum = this_sum;\n        else if(this_sum &lt; 0)\n            this_sum = 0;\n    }\n    return max_sum;\n}\n\n\n对分查找\n\n#define NOTFOUND -1\nint binary_search(const int a[], int x, int n) {\n    int low, mid, high;\n    low = 0;\n    high = n - 1;\n    while(low &lt;= high) {\n        mid = (low + high) / 2;\n        if(a[mid] &lt; x)\n            low = mid + 1;\n        else if(a[mid] &gt; x)\n                high = mid - 1;\n        else\n            return mid;\n    }\n    return -1;\n    //return NOTFOUND;\n}\n\n\n欧几里得算法（计算最大公约数）\n\nunsigned int gcd(unsigned int m, unsigned int n) {\n    unsigned int rem;\n    while(n &gt; 0) {\n        rem = m % n;\n        m = n;\n        n = rem;\n    }\n    return m;\n}\n\n\n求幂运算 (幂大于0)\n\nint is_even(int n) {\n    if(n % 2)\n        return 0;\n    else\n        return 1;\n}\nlong int my_pow(long int x, unsigned int n) {\n    if(n == 0)\n        return 1;\n    if(n == 1)\n        return x;\n    if(is_even(n))\n        return my_pow(x * x, n / 2);\n    else\n        return my_pow(x * x, n / 2) * x;\n}\n\n\n基本算法 （JAVA）\n\n使用java 语言进行实现\n\n二分查找\n\n递归实现\n\n    public static int rank(int key, int []a, int lo, int hi) {\n        if(lo &gt; hi)\n            return -1;\n        int mid = lo + (hi - lo) / 2;\n        if (key &lt; a[mid])\n            return rank(key, a, lo,mid -1);\n        else if (key &gt; a[mid])\n            return rank(key, a, mid+1, hi);\n        else\n            return mid;\n\n    }\n    public static int rank(int key, int []a) {\n        return rank(key, a, 0, a.length - 1);\n    }\n\n\n\n循环实现\n\n public static int rank(int key, int []a) {\n        int lo = 0;\n        int hi = a.length - 1;\n        while(lo &lt;= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (key &lt; a[mid])\n                hi = mid - 1;\n            else if (key &gt; a[mid])\n                lo = mid + 1;\n            else\n                return mid;\n        }\n        return -1;\n    }\n\n\nclass MySort {\n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) &lt; 0;\n    }\n    private static void exch(Comparable[] a, int i, int j) {\n        Comparable t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n    public static void sort(Comparable[] a) {\n        // 实现\n    }\n}\n\n\n选择排序\n\npublic static void sort(Comparable[] a) {\n        int N = a.length;\n        for(int i = 0; i &lt; N; i++) {\n            int min = i;\n            for (int j = i + 1; j &lt; N; j++) {\n                if (less(a[j], a[min]))\n                    min = j;\n            }\n            exch(a, i, min);\n        }\n}\n\n\n插入排序\n\npublic static void sort(Comparable[] a) {\n    int N = a.length;\n    for (int i = 0; i &lt; N; i++) {\n        for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) {\n            exch(a, j, j - 1);\n        }\n    }\n}\n\n\n希尔排序\n\npublic static void sort(Comparable[] a) {\n    int N = a.length;\n    int h = 1;\n    while(h &lt; N/3)\n        h = 3 * h + 1;\n    while(h &gt;= 1) {\n        for(int i = h; i &lt; N; i++) \n            for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) \n                exch(a, j, j - h);\n        h = h / 3;\n    }\n}\n\n",
        "content": "通过反复的练习，达到自己手写的程度（白板写代码），基本上为了理解好的代码，进行的代码摘抄。\n\n基本数据结构\n\n通过反复的练习，达到自己手写的程度（白板写代码）\n每个数据结构的实现必须熟悉（最为基本的实现）虽然C++或者其他语言都有这相应的的基本实现，可以直接调用使用，（调用库函数）但是还是应该能够直接手写出代码。以其获得更为具体的优化。（能所不能）\n相应的，要理解每个数据结构的优缺点。\n\n展开\n\n以后自己的代码也需要这样的设计。建立一个良好的接口，增加程序代码的复用。\n比如在上记得代码中，对链表这个数据结构进行了抽象，相同的结构如：\n\n\n  插入\n  删除\n  头节点\n  尾结点\n  链表长度\n  链表初始化\n  链表销毁\n\n\n这些地方这3种数据结构操作相似。可以进行抽象，在其他提供类的语言中，这些可以通过类进行继承，以期实现代码的复用。\n\n对于工作之中，使代码多结构化可以减少需求变更的情况下，尽可能的减少修改代码的行数。\n比如，链表实现的代码中，需要添加一个功能，那么可以只需要在list中实现这个功能，其他数据结构就可以通过相应的参数，return给相关的函数。\n另外比如需要修改插入函数，那么仅仅只需要在list函数中就行修改就可以保证，剩下的数据结构同时被修改。\n\n这里的数据结构可以替换成其他工作中需要实现的功能等。结果同样。\n\nC语言编程细节\n\n注意因为C语言没有bool类型。所以在返回值的时候，会出现 -1， 0， 1等多种情况。因为在C中True 是任意的非0数字，只有0是false, 所以在写自己的函数的时候，要注意自己的函数应该返回状态码（比如一些函数错误结束后的返回-1），还是用于if判断的（0，1）\n\n链表系\n\n单链表\n\n最为简单的数据结构，每个节点为一个自己定义的结构（包含数据，指针 指向下一个节点）\n因为只保存了下一个节点的地址，所以单链表是不可以倒序遍历的，也不能随机访问。必须由头节点逐个依次的访问。\n    如果每个下一个节点有重复则称之为循环链表 &lt;-判断是否成环也是相应的算法题之一，并且我觉得也是一些有用的算法题，需要特别记忆的。\n特别的：\n\n\n  每个节点的位置是离散的（后一个节点的内存位置并不是在节点内存的下一个） 这种分散的特性，相比数组的连续内存有些时候会更加高效。\n  如果发生删除操作一定要先获取以后节点的地址\n\n\n如果插入、删除的__位置为NULL__，则默认插入、删除的位置在表头。\n\n//节点定义\ntypedef struct ListElmt_\n{\n    void *data; // can use point to get the real data\n    struct ListElmt_ * next;\n} ListElmt;\n\ntypedef struct List_\n{\n    int size;\n    int(*match)(const void *key1, const void *key2);\n    void(*destroy)(void *data);\n    ListElmt *head;\n    ListElmt *tail;\n} List;\n\n\n然后定义相关的函数： 增删查改\n\n//接口函数\nvoid list_init(List *list, void(*destroy)(void *data));\nvoid list_destroy(List *list);\n\n// should use bool but C do not give bool before C99\nint list_ins_next(List *list, ListElmt *element, const void * data);\n/* when you want to remove a element, you should give the value to the programer\n/ because they want to use this data, you can not just delete the element and do nothing\n/ also the element can be return as return value, but in this way, you can not judge\n/ if it has been remove already */\nint list_rem_next(List *list, ListElmt *element, void **data);\n\n// in other language you should use inline function instead of using macro\n#define list_size(list) ((list)-&gt;size)\n#define list_head(list) ((list)-&gt;head)\n#define list_tail(list) ((list)-&gt;tail)\n#define list_is_head(list, element) ((element) == (list)-&gt;head ? 1 : 0)\n#define list_is_tail(element) ((element)-&gt;next == NULL ? 1 : 0)\n#define list_data(element) ((element)-&gt;data)\n#define list_next(element) ((element)-&gt;next)\n\n\n//函数实现\nvoid list_init(List *list, void(*destroy)(void *data))\n{\n    list-&gt;size = 0;\n    list-&gt;destroy = destroy;\n    list-&gt;head = NULL;\n    list-&gt;tail = NULL;\n}\n\nvoid list_destroy(List *list)\n{\n    void *data;\n    while (list_size(list) &gt; 0)\n    {\n        if (list_rem_next(list, NULL, (void **)&amp;data) == 0 &amp;&amp; list-&gt;destory != NULL)\n        {\n\n            list-&gt;destory(data);\n        }\n    }\n    memset(list, 0, sizeof(List));\n}\n\nint list_ins_next(List *list, ListElmt *element, const void * data)\n{\n    ListElmt * new_element;\n    if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL)\n        return -1;\n    new_element-&gt;data = (void *)data;\n    // if element is null insert the data in the head of list\n    if (element == NULL)\n    {\n        if (list_size(list) == 0)\n            list-&gt;tail = new_element;\n        new_element-&gt;next = list-&gt;head;\n        list-&gt;head = new_element;\n    }\n    else\n    {\n        if (element-&gt;next == NULL)\n            list-&gt;tail = new_element;\n        // here you can use new_element-&gt;next = NULL\n        new_element-&gt;next = element-&gt;next;\n        element-&gt;next = new_element;\n    }\n    list-&gt;size++;\n    return 0;\n}\n\nint list_rem_next(List *list, ListElmt *element, void **data)\n{\n    ListElmt *old_element;\n    if (list_size(list) == 0)\n        return -1;\n    // if element is null remove the data in the head of list\n    if (element == NULL)\n    {\n        *data = list-&gt;head-&gt;data;\n        old_element = list-&gt;head;\n        list-&gt;head = list-&gt;head-&gt;next;\n\n        if (list_size(list) == 1)\n            list-&gt;tail = NULL;\n    }\n    else\n    {\n        if (element-&gt;next == NULL)\n            return -1;\n        *data = element-&gt;next-&gt;data;\n        old_element = element-&gt;next;\n        // you can use element-&gt;next = old_element-&gt;next;\n        element-&gt;next = element-&gt;next-&gt;next;\n\n        if (element-&gt;next == NULL)\n            list-&gt;tail = NULL;\n    }\n    free(old_element);\n    list-&gt;size--;\n    return 0;\n}\n\n\n当然， 我们应该还要编写相应的find函数，destroy函数，来使得这个链表程序更加的完整。\n\n也可以类比其他书籍查看不同，比如\n\n  数据结构与算法分析 C语言描述\n\n\n就可以明白在不同的编程思路下，虽然是同一数据结构，但是代码可能会完全不同。具体喜欢哪种风格，那还是需要自己见仁见智了。\n\n栈\n\n栈的实现方式很简单，可以通过很多的方式来实现，栈只要保证操作只在头部就可以称之为栈。这里栈的实现是利用先前做出的假设，如果插入位置为空的话将操作位置设定为表的头部\n\n//节点定义\ntypedef List Stack;\n\n\n//接口函数\n#define stack_init list_init\n#define stack_destroy list_destroy\n\n#define stack_peek(stack) ((stack)-&gt;head == NULL ? NULL : (stack)-&gt;head-&gt;data)\n#define stack_size list_size\n\nint stack_push(Stack *stack, const void *data);\nint stack_pop(Stack *stack, void **data);\n\n\n//函数实现\nint stack_push(Stack *stack, const void *data)\n{\n    return list_ins_next(stack, NULL, data);\n}\n\nint stack_pop(Stack *stack, void **data)\n{\n    return list_rem_next(stack, NULL, data);\n}\n\n\n队列\n\n队列也可以看作特殊的链表，操作分别在头尾两端。在头部进行删除，在尾部进行插入。\n同栈一样，没有操作内部节点的接口。\n\n//节点定义\ntypedef List Queue;\n\n\n//接口函数\n#define queue_init list_init\n#define queue_destroy list_destroy\n\n#define queue_peek(queue) ((queue)-&gt;head == NULL ? NULL : (queue)-&gt;head-&gt;data)\n#define queue_size list_size\n\nint queue_enqueue(Queue *queue, const void *data);\nint queue_dequeue(Queue *queue, void **data);\n\n\n//函数实现\nint queue_enqueue(Queue *queue, const void *data)\n{\n    return list_ins_next(queue, list_tail(queue), data);\n}\nint queue_dequeue(Queue *queue, void **data)\n{\n    return list_rem_next(queue, NULL, data);\n}\n\n\n栈和队列可以使用不同的实现方式，比如链表，或者是可以增长的数组。简单的思路如下：\n如果对于数据的插入，删除的个数确定，可以简单的使用数组进行实现，（惰性删除即可，或直接在建立的初期为以后的插入位置进行预留等其他的实现方式），或者更进一步，使用其他语言提供的库函数进行封装。\n另外，数据量确定和可读性起见，可以直接在结构体中包含所需要的数据。这时，可以建立单独的带有类型的链表，如int类型的链表，char类型的链表等。\n\n上述实现是通过链表系作为接口，修改而成的。如果单纯只使用其中一种数据结构，可以针对这种结构单独写出。\n\n集合\n\n集合是一种很特殊的数据结构，（set），它所拥有的性质元素唯一性，可以为编程提供很大的便利。比如去重可以直接将数据存入到set就可以了。\n\n//节点定义\ntypedef List Set;\n\n\n//接口函数\nvoid set_init(Set *set, int(*match)(const void *key1, const void *key2), void(*destroy)(void *data));\nint set_insert(Set *set, const void *data);\nint set_remove(Set *set, void **data);\nint set_union(Set *setu, const Set *set1, const Set *set2);\nint set_intersction(Set *seti, const Set *set1, const Set *set2);\nint set_difference(Set *setd, const Set *set1, const Set *set2);\nint set_is_member(const Set *set, const void *data);\nint set_is_subset(const Set *set1, const Set *set2);\nint set_is_equal(const Set *set1, const Set *set2);\n\n#define set_size(set) ((set)-&gt;size)\n#define set_destroy list_destroy\n\n\n//函数实现\nvoid set_init(Set *set, int(*match)(const void *key1, const void *key2), void(*destroy)(void *data))\n{\n    list_init(set, destroy);\n    set-&gt;match = match;\n}\n\nint set_insert(Set *set, const void *data)\n{\n    if (set_is_member(set, data))\n        return 1;\n    return list_ins_next(set, list_tail(set), data);\n}\n\nint set_remove(Set *set, void **data)\n{\n    ListElmt *member;\n    ListElmt *prev;\n\n    prev = NULL;\n\n    for (member = list_head(set); member != NULL; member = list_next(member))\n    {\n        if (set-&gt;match(*data, list_data(member)))\n            break;\n        prev = member;\n    }\n    if (member == NULL)\n        return -1;\n\n    return list_rem_next(set, prev, data);\n}\n\nint set_union(Set *setu, const Set *set1, const Set *set2)\n{\n    ListElmt *member;\n    void *data;\n\n    set_init(setu, set1-&gt;match, NULL);\n    for (member = list_head(set1); member != NULL; member = list_next(member))\n    {\n        data = list_data(member);\n        if (list_ins_next(setu, list_tail(setu), data) != 0)\n        {\n            set_destroy(setu);\n            return -1;\n        }\n    }\n    for (member = list_head(set2); member != NULL; member = list_next(member))\n    {\n        if (set_is_member(set1, list_data(member)))\n        {\n            continue;\n        }\n        else\n        {\n            data = list_data(member);\n            if (list_ins_next(setu, list_tail(setu), data) != 0)\n            {\n                set_destroy(setu);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nint set_intersection(Set *seti, const Set *set1, const Set *set2)\n{\n    ListElmt * member;\n    void *data;\n\n    set_init(seti, set1-&gt;match, NULL);\n    for (member = list_head(set1); member != NULL; member = list_next(member))\n    {\n        if (set_is_member(set2, list_data(member)))\n        {\n            data = list_data(member);\n            if (list_ins_next(seti, list_tail(seti), data) != 0)\n            {\n                set_destroy(seti);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nint set_difference(Set *setd, const Set *set1, const Set *set2)\n{\n    ListElmt *member;\n    void *data;\n\n    set_init(setd, set1-&gt;match, NULL);\n\n    for (member = list_head(set1); member != NULL; member = list_next(member))\n    {\n        if (!set_is_member(set2, list_data(member)))\n        {\n            data = list_data(member);\n            if (list_ins_next(setd, list_tail(setd), data) != 0)\n            {\n                set_destroy(setd);\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nint set_is_member(const Set *set, const void *data)\n{\n    ListElmt *member;\n    for (member = list_head(set); member != NULL; member = list_next(member))\n    {\n        if (set-&gt;match(data, list_data(member)))\n            return 1;\n    }\n    return 0;\n}\n\nint set_is_subset(const Set *set1, const Set *set2)\n{\n    ListElmt *member;\n    if (set_size(set1) &gt; set_size(set2))\n        return 0;\n    for (member = list_head(set1); member != NULL; list_next(member))\n    {\n        if (!set_is_member(set2, list_data(member)))\n            return 0;\n    }\n    return 1;\n}\n\nint set_is_equal(const Set *set1, const Set *set2)\n{\n    if (set_size(set1) != set_size(set2))\n        return 0;\n    return set_is_subset(set1, set2);\n}\n\n\n哈希表\n\n哈希表其实作为以后会更加频繁出现的数据结构一定要学习的非常深入。\n区块链等新的技术基本上也利用了如此的原理来实现。\n哈希表，通过唯一的哈希值保证每个元素都可以在O(1)的时间内被访问。\n\n//节点定义\ntypedef struct CHTbl_\n{\n    int buckets;\n    int(*h)(const void *key);\n    int(*match)(const void *key1, const void *key2);\n    void(*destroy)(void *data);\n\n    int size;\n    List *table;\n}CHTbl;\n\n\n//接口函数\nint chtbl_init(CHTbl *htbl, int buckets, int(*h)(const void *key),\n    int(*match)(const void *key1, const void *key2), void(*destroy)(void *data));\nvoid chtbl_destroy(CHTbl *htbl);\nint chtbl_insert(CHTbl * htbl, const void *data);\nint chtbl_remove(CHTbl*htbl, void *data);\nint chtbl_lookup(const CHTbl *htbl, void **data);\n\n#define chtbl_size(htbl) ((htbl)-&gt;size)\n\n\n//函数实现\nint chtbl_init(CHTbl *htbl, int buckets, int(*h)(const void *key),\n    int(*match)(const void *key1, const void *key2), void(*destroy)(void *data))\n{\n    int i;\n    if ((htbl-&gt;table = (List *)malloc(buckets * sizeof(List))) == NULL)\n        return -1;\n\n    htbl-&gt;buckets = buckets;\n\n    for (i = 0; i &lt; htbl-&gt;buckets; i++)\n        list_init(&amp;htbl-&gt;table[i], destroy);\n    htbl-&gt;h = h;\n    htbl-&gt;match = match;\n    htbl-&gt;destroy = destroy;\n\n    htbl-&gt;size = 0;\n\n    return 0;\n}\n\nvoid chtbl_destroy(CHTbl *htbl)\n{\n    int i;\n    for (i = 0; i &lt; htbl-&gt;buckets; i++)\n        list_destroy(&amp;htbl-&gt;table[i]);\n\n    free(htbl-&gt;table);\n    memset(htbl, 0, sizeof(CHTbl));\n}\n\nint chtbl_insert(CHTbl *htbl, const void *data)\n{\n    void *temp;\n    int bucket;\n    int retval;\n\n    temp = (void *)data;\n\n    if (chtbl_lookup(htbl, &amp;temp) == 0)\n        return 1;\n\n    bucket = htbl-&gt;h(data) % htbl-&gt;buckets;\n\n    if ((retval = list_ins_next(&amp;htbl-&gt;table[bucket], NULL, data)) == 0)\n        htbl-&gt;size++;\n    return retval;\n}\n\nint chtbl_remove(CHTbl *htbl, void **data)\n{\n    ListElmt *element,\n        *prev;\n\n    int bucket;\n\n    bucket = htbl-&gt;h(*data) % htbl-&gt;buckets;\n\n    prev = NULL;\n\n    for(element = list_head(&amp;htbl-&gt;table[bucket]); element != NULL;\n    element = list_next(element))\n    {\n        if (htbl-&gt;match(*data, list_data(element)))\n        {\n            if (list_rem_next(&amp;htbl-&gt;table[bucket], prev, data) == 0)\n            {\n                htbl-&gt;size--;\n                return 0;\n            }\n            else\n            {\n                return -1;\n            }\n        }\n        prev = element;\n    }\n    return -1;\n}\n\nint chtbl_lookup(const CHTbl *htbl, void **data)\n{\n    ListElmt *element;\n    int bucket;\n\n    bucket = htbl-&gt;h(*data) % htbl-&gt;buckets;\n\n    for (element = list_head(&amp;htbl-&gt;table[bucket]); element != NULL;\n        element = list_next(element))\n    {\n        if (htbl-&gt;match(*data, list_data(element)))\n        {\n            *data = list_data(element);\n            return 0;\n        }\n    }\n    return -1;\n\n}\n\n\n树系\n\n树是一定要熟练掌握的数据结构，包括相应的算法，比如，反转二叉树，最短路径等，一定要在理解的前提下，可以手写代码。\n\n//节点定义\ntypedef struct BiTreeNode_\n{\n    void *data;\n    struct BiTreeNode_ *left;\n    struct BiTreeNoed_ *right;\n} BiTreeNode;\n\ntypedef struct BiTree_\n{\n    int size;\n    int(*compare) (const void *key1, const void *key2);\n    void(*destroy)(void *data);\n\n    BiTreeNode *root;\n} BiTree;\n\n\n//接口函数\nvoid bitree_init(BiTree *tree, void(*destroy) (void *data));\nvoid bitree_destroy(BiTree *tree);\nint bitree_ins_left(BiTree *tree, BiTreeNode *node, const void *data);\nint bitree_ins_right(BiTree *tree, BiTreeNode *node, const void *data);\nvoid bitree_rem_left(BiTree *tree, BiTreeNode *node);\nvoid bitree_rem_right(BiTree *tree, BiTreeNode *node);\nint bitree_merge(BiTree *merge, BiTree *left, BiTree *right, const void *data);\n\n#define bitree_size(tree) ((tree)-&gt;size)\n#define bitree_root(tree) ((tree)-&gt;root)\n#define bitree_is_eob(node) ((node)==NULL)\n#define bitree_is_left(node) ((node)-&gt;left==NULL &amp;&amp; (node)-&gt;right==NULL)\n#define bitree_data(node) ((node)-&gt;data)\n#define bitree_left(node) ((node)-&gt;left)\n#define bitree_right(node) ((node)-&gt;right)\n\n\n//函数实现\n\n\n\n基本算法 （C）\n\n最大子序列和\n\nint max_sub_sequence(const int a[], int n) {\n    int this_sum, max_sum;\n    this_sum = max_sum = 0;\n    for(int i = 0; i &lt; N; i++) {\n        this_sum += a[i];\n        if(this_sum &gt; max_sum)\n            max_sum = this_sum;\n        else if(this_sum &lt; 0)\n            this_sum = 0;\n    }\n    return max_sum;\n}\n\n\n对分查找\n\n#define NOTFOUND -1\nint binary_search(const int a[], int x, int n) {\n    int low, mid, high;\n    low = 0;\n    high = n - 1;\n    while(low &lt;= high) {\n        mid = (low + high) / 2;\n        if(a[mid] &lt; x)\n            low = mid + 1;\n        else if(a[mid] &gt; x)\n                high = mid - 1;\n        else\n            return mid;\n    }\n    return -1;\n    //return NOTFOUND;\n}\n\n\n欧几里得算法（计算最大公约数）\n\nunsigned int gcd(unsigned int m, unsigned int n) {\n    unsigned int rem;\n    while(n &gt; 0) {\n        rem = m % n;\n        m = n;\n        n = rem;\n    }\n    return m;\n}\n\n\n求幂运算 (幂大于0)\n\nint is_even(int n) {\n    if(n % 2)\n        return 0;\n    else\n        return 1;\n}\nlong int my_pow(long int x, unsigned int n) {\n    if(n == 0)\n        return 1;\n    if(n == 1)\n        return x;\n    if(is_even(n))\n        return my_pow(x * x, n / 2);\n    else\n        return my_pow(x * x, n / 2) * x;\n}\n\n\n基本算法 （JAVA）\n\n使用java 语言进行实现\n\n二分查找\n\n递归实现\n\n    public static int rank(int key, int []a, int lo, int hi) {\n        if(lo &gt; hi)\n            return -1;\n        int mid = lo + (hi - lo) / 2;\n        if (key &lt; a[mid])\n            return rank(key, a, lo,mid -1);\n        else if (key &gt; a[mid])\n            return rank(key, a, mid+1, hi);\n        else\n            return mid;\n\n    }\n    public static int rank(int key, int []a) {\n        return rank(key, a, 0, a.length - 1);\n    }\n\n\n\n循环实现\n\n public static int rank(int key, int []a) {\n        int lo = 0;\n        int hi = a.length - 1;\n        while(lo &lt;= hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (key &lt; a[mid])\n                hi = mid - 1;\n            else if (key &gt; a[mid])\n                lo = mid + 1;\n            else\n                return mid;\n        }\n        return -1;\n    }\n\n\nclass MySort {\n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) &lt; 0;\n    }\n    private static void exch(Comparable[] a, int i, int j) {\n        Comparable t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n    public static void sort(Comparable[] a) {\n        // 实现\n    }\n}\n\n\n选择排序\n\npublic static void sort(Comparable[] a) {\n        int N = a.length;\n        for(int i = 0; i &lt; N; i++) {\n            int min = i;\n            for (int j = i + 1; j &lt; N; j++) {\n                if (less(a[j], a[min]))\n                    min = j;\n            }\n            exch(a, i, min);\n        }\n}\n\n\n插入排序\n\npublic static void sort(Comparable[] a) {\n    int N = a.length;\n    for (int i = 0; i &lt; N; i++) {\n        for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) {\n            exch(a, j, j - 1);\n        }\n    }\n}\n\n\n希尔排序\n\npublic static void sort(Comparable[] a) {\n    int N = a.length;\n    int h = 1;\n    while(h &lt; N/3)\n        h = 3 * h + 1;\n    while(h &gt;= 1) {\n        for(int i = h; i &lt; N; i++) \n            for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) \n                exch(a, j, j - h);\n        h = h / 3;\n    }\n}\n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/02/Algorithms/"
      },
    
      {
        "title": "Leetcode",
        "excerpt": "2020年 02 月 26 日更新\n\n&lt;-E&gt; Two Sum 286ms 2.67%\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n    vector &lt;int&gt; answer;\n    for (auto i = 0; i != nums.size(); i++) {\n        for (auto j = i + 1; j != nums.size(); j++) {\n            if (nums[i] + nums[j] == target) {\n                answer.push_back(i);\n                answer.push_back(j);\n            }\n        }\n    }\n    return answer;\n}\n\n\n大佬的解法：\n利用hashmap的无序性。 hash.find(numberToFind) != hash.end() 如果没有找到，则将元素的值作为hash的key， 元素的位数为值添加到map中。以此类推直到找到该元素为止。\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {\n    //Key is the number and value is its index in the vector.\n    unordered_map&lt;int, int&gt; hash;\n    vector&lt;int&gt; result;\n    for (int i = 0; i &lt; numbers.size(); i++) {\n        int numberToFind = target - numbers[i];\n        // if numberToFind is found in map, return them\n        if (hash.find(numberToFind) != hash.end()) {\n            result.push_back(hash[numberToFind]);\n            result.push_back(i);\n            return result;\n        }\n        // number was not found. Put it in the map.\n        hash[numbers[i]] = i;\n    }\n    return result;\n}\n\n\n展开\n\n使用unordered_map来做。 该数据结构被定义在unordered_map 库中。\n\n\n  unordered_map 内部实现为哈希表。（所以是无序的）\n  map 内部实现为红黑树（所以map内部的元素都是有序的）\n\n\nmap\n\n优点：\n\n\n  有序性\n  内部由红黑树实现（使用红黑树特性的时候，效率快）\n\n\n缺点：\n\n\n  空间占用率高（节点）\n\n\nunordered_map\n\n优点：\n\n\n  查找快\n\n\n缺点：\n\n\n  建立hash表的时候，消耗大量时间\n\n\n&lt;-M&gt; Add Two Numbers 56ms 27.5%\n\n(l1 ? l1-&gt;val : 0)\nl1 = l1 ? l1-&gt;next : l1;\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int remainder = 0;\n        ListNode answer(0);\n        ListNode *p = &amp;answer;\n        while (l1 || l2 || remainder) {\n            int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + remainder;\n            remainder = sum / 10;\n            p-&gt;next = new ListNode(sum % 10);\n            p = p-&gt;next;\n            l1 = l1 ? l1-&gt;next : l1;\n            l2 = l2 ? l2-&gt;next : l2;\n        }\n        return answer.next;\n    }\n};\n\n\n&lt;-M&gt; Longest Substring Without Repeating Characters\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        vector&lt;-char&gt; check;\n        for (auto i = s.begin(); i != s.end(); i++) {\n            for (auto j = i; j != s.end(); j++) {\n                if (find(check.begin(), check.end(), *j) == check.end())\n                    check.push_back(*j);\n                else\n                    break;\n            }\n            if (ans &lt;- check.size()) {\n                ans = check.size();\n                check.clear();\n            }\n            else {\n                check.clear();\n            }\n        }\n        return ans;\n    }\n};\n\n\n&lt;-H&gt; Median of Two Sorted Arrays 62ms\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;-int&gt;&amp; nums1, vector&lt;-int&gt;&amp; nums2) {\n        vector&lt;-int&gt; Temp;\n        for (int i = 0; i != nums1.size(); i++) {\n            Temp.push_back(nums1[i]);\n        }\n        for (int i = 0; i != nums2.size(); i++) {\n            Temp.push_back(nums2[i]);\n        }\n        sort(Temp.begin(), Temp.end());\n        if (Temp.size() % 2 == 0)\n            return (Temp[Temp.size() / 2 - 1] + Temp[Temp.size() / 2]) / 2.0;\n        else\n            return  Temp[Temp.size() / 2];\n    }\n};\n\n\n&lt;-M&gt; Longest Palindromic Substring 9ms\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n    if (s.empty()) return \"\";\n    if (s.size() == 1) return s;\n    int min_start = 0, max_len = 1;\n    for (int i = 0; i &lt;- s.size();) {\n        if (s.size() - i &lt;-= max_len / 2) break;\n        int j = i, k = i;\n        while (k &lt;- s.size()-1 &amp;&amp; s[k+1] == s[k]) \n            ++k; \n      \n        // Skip duplicate characters.\n        \n        i = k+1;\n        while (k &lt;- s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) {\n            ++k; --j; \n        } \n        \n        // Expand.\n        int new_len = k - j + 1;\n        if (new_len &gt; max_len) { \n            min_start = j; max_len = new_len; \n        }\n    }\n    return s.substr(min_start, max_len);\n}\n};\n\n\n&lt;-M&gt; ZigZag Conversion 16ms\n\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n       if (numRows &lt;-= 1 || s.size() &lt;-= 1)\n        return s;\n        string result;\n        for (int i = 0; i &lt;- numRows; i++) {\n            for (int j = 0, index = i; index &lt;- s.size();j++, index = (2 * numRows - 2) * j + i) {\n                result.append(1, s[index]);\n                if (i == 0 || i == numRows - 1) \n                    continue;\n                if (index + (numRows - i - 1) * 2 &lt;- s.size())\n                    result.append(1, s[index + (numRows - i - 1) * 2]);\n            }\n        }\n        return result;\n    }\n};\n\n\n&lt;-E&gt; Reverse Integer 15ms 77.99%\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        int ans = 0;\n        while (x) {\n            int temp = ans * 10 + x % 10;\n            if (temp / 10 != ans)\n                return 0;\n            ans = temp;\n            x /= 10;\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n   int reverse(int x){\n        int n = 0;\n        while(x != 0) {\n            if(n &gt; INT_MAX / 10 || n &lt; INT_MIN / 10 || \n               (n == INT_MAX / 10 &amp;&amp; x % 10 &gt; INT_MAX % 10) ||\n               (n == INT_MIN / 10 &amp;&amp; x % 10 &lt; INT_MIN % 10))\n                return 0;\n            n = 10 * n + x % 10;\n            x /= 10;\n        }\n    return n;\n    }\n};\n\n\n&lt;-Bad Question -M&gt; String to Integer (atoi)\n\nclass Solution {\npublic:\n    int myAtoi(string str) {\n        int ans = 0;\n        int times = 1;\n        int checkflag = 1;\n        int end = 0;\n        if (str[0] == '+') {\n            end = 1;\n        }\n        if (str[0] == '-') {\n            end = 1;\n            checkflag = -1;\n        }\n        for (int i = str.size() - 1; i &gt;= end; i--) {\n            ans = (str[i] - '0') * times + ans;\n            times *= 10;\n        }\n        return ans * checkflag;\n    }\n};\n\n&lt; -E&gt; Palindrome Number\n\nbool isPalindrome(int x) {\n        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;\n        int sum=0;\n        while(x&gt;sum) {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n}\n\nbool isPalindrome(int x){\n    if(x &lt; 0)\n        return false;\n    else {\n        long int m = 0;\n        int n = x;\n        while(n != 0) {\n            m = m * 10 + n % 10;\n            n /= 10;\n        }\n        if(x == m)\n            return true;\n    }\n    return false;\n}\n\n\n\n&lt;-E&gt; Palindrome Number\n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;\n        int sum=0;\n        while(x&gt;sum) {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n\n    }\n};\n\n\n&lt;-E&gt; Longest Common Prefix\n\n求出最长的公共字串。这题有些歧义，根据Disucuss中的内容，增加条件如下：\n\n  {“a”,”a”,”b”} should give “” as there is nothing common in all the 3 strings.\n{“a”, “a”} should give “a” as a is longest common prefix in all the strings.\n{“abca”, “abc”} as abc\n{“ac”, “ac”, “a”, “a”} as a.\n\n\n有了该条件后，可以使用双重循环进行求解，在一般的操作中，需要注重边界值的问题。\n\nstring longestCommonPrefix(vector&lt;string&gt;&amp; strs) {\n    string prefix = \"\";\n    for(int idx=0; strs.size()&gt;0; prefix+=strs[0][idx], idx++)\n        for(int i=0; i&lt;strs.size(); i++)\n            if(idx &gt;= strs[i].size() ||(i &gt; 0 &amp;&amp; strs[i][idx] != strs[i-1][idx]))\n                return prefix;\n    return prefix;\n    }\n\n&lt;-E&gt; Subtract the Product and Sum of Digits of an Integer\n\nclass Solution {\npublic:\n    \n    int subtractProductAndSum(int n) {\n        int a = 1;\n        int b = 0;\n        int x;\n        while (n != 0) {\n            x = n % 10;\n            a *= x;\n            b += x;\n            n = n / 10;\n        }\n        return a - b;\n    }\n    \n};\n\n\n&lt;-E&gt; Convert Integer to the Sum of Two No-Zero Integers\n\nclass Solution {\npublic:\n    bool checkzero(int n) {\n        int x;\n        while (n != 0) {\n            x = n % 10;\n            if (x == 0)\n                return false;\n            n = n / 10;\n        }\n        return true;\n    }\n    vector&lt;int&gt; getNoZeroIntegers(int n) {\n        vector&lt;int&gt; a;\n        for (int i = 1; i != n; i++) {\n            if (checkzero(n - i) &amp;&amp; checkzero(i)) {\n                a.push_back(i);\n                a.push_back(n - i);\n                return a;\n            }\n            \n        }   \n       \n    }\n};\n\n\n&lt;-E&gt; Decompress Run-Length Encoded List\n\nclass Solution {\npublic:\n    vector&lt;int&gt; decompressRLElist(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i &lt; nums.size(); i+=2) {\n            for(int j = nums[i]; j != 0; j--) {\n                ans.push_back(nums[i + 1]);\n            }\n        }\n    return ans;    \n    }\n};\n\n\n&lt;-E&gt; Decrypt String from Alphabet to Integer Mapping\n\nclass Solution {\npublic:\n    string freqAlphabets(string s) {\n        string a = \"\";\n        int b;\n        for(int i = s.size() - 1; i &gt;= 0; i--) {\n            if(s[i] != '#')\n                b = s[i] - '0' + 96;\n            else {\n                b =   (s[i - 2] - '0' )* 10 +  (s[i - 1] - '0' ) + 96;\n                i -= 2;\n            }\n            a = (char)b + a;\n        }\n        return a;\n    }\n};\n\n\n&lt;-E&gt;  Find N Unique Integers Sum up to Zero\n\nclass Solution {\npublic:\n    vector&lt;int&gt; sumZero(int n) {\n        vector&lt;int&gt; ans;\n        if(n % 2) {\n            ans.push_back(0);\n            \n        }\n        else ;\n        for(int i = 1; i &lt;= n / 2; i++) {\n            ans.push_back(i);\n            ans.push_back(-i);\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;  Replace Elements with Greatest Element on Right Side\n\nclass Solution {\npublic:\n    vector&lt;int&gt; replaceElements(vector&lt;int&gt;&amp; arr) {\n        int temp = -1;\n        arr.push_back(-1);\n        for(int i = arr.size() - 2; i &gt;= 0; i--) {\n            if(arr[i] &gt; temp)\n                temp = arr[i];\n            else\n                arr[i] = temp;\n        }\n        arr.erase(arr.begin());\n        return arr;\n    }\n};\n\n\n&lt;-E&gt;  Find Numbers with Even Number of Digits\n\nclass Solution {\npublic:\n    bool checkEvenDights(int n) {\n        int dights = 0;\n        while(n != 0) {\n            n /= 10;\n            dights++;\n        }\n        if(dights % 2)\n            return false;\n        else\n            return true;\n    }\n    int findNumbers(vector&lt;int&gt;&amp; nums) {\n        int ans = 0;\n        for(auto i : nums) {\n            if(checkEvenDights(i))\n                ans++;\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;  Convert Binary Number in a Linked List to Integer\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        int ans = 0;\n        while(head != NULL) {\n            ans = ans * 2 + head-&gt;val;\n            head = head-&gt;next;\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;  Element Appearing More Than 25% In Sorted Array\n\nclass Solution {\npublic:\n    \n    int findSpecialInteger(vector&lt;int&gt;&amp; arr) {\n        int count = arr.size()  / 4;\n        int temp = arr[0];\n        int index = 0;\n        for(int i = 1; i &lt; arr.size(); i++) {\n            index++;\n            if(arr[i] != temp) {\n                temp = arr[i];\n                index = 0;\n            }\n            if(index &gt;= count)\n                return arr[i];\n        }\n        return arr[0];\n    }\n};\n\n\n&lt;-E&gt;  Jewels and Stones\n\n// 1\nclass Solution {\npublic:\n    int numJewelsInStones(string J, string S) {\n        int ans = 0;\n        for (auto i : S) {\n            if (find(J.begin(), J.end(), i) != J.end())\n                ans++;\n        }\n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n  int numJewelsInStones(string J, string S) {\n        int check[128] = {0};\n        for (int i = 0; i != S.size(); i++) {\n            check[S[i]]++;\n        }\n        \n        for (int i = 0; i != J.size(); i++) {\n            check[J[i]] = -check[J[i]];\n        }\n        int ans = 0;\n        for (int i = 0; i != 128; i++) {\n            if (check[i] &lt; 0)\n                ans = ans - check[i];\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;  Find Winner on a Tic Tac Toe Game\n\nclass Solution {\npublic:\n    string tictactoe(vector&lt;vector&lt;int&gt;&gt;&amp; moves) {\n        vector&lt;int&gt; aRow(3);\n        vector&lt;int&gt; bRow(3);\n        vector&lt;int&gt; aCol(3);\n        vector&lt;int&gt; bCol(3);\n        int aIndex_1 = 0;\n        int aIndex_2 = 0;\n        int bIndex_1 = 0;\n        int bIndex_2 = 0;\n        for (int i = 0; i &lt; moves.size(); i++) {\n            int x = moves[i][0];\n            int y = moves[i][1];   \n            if (i % 2) {\n                if (++aRow[x] == 3 || ++aCol[y] == 3 || (x == y &amp;&amp; ++aIndex_1 == 3) || (x + y == 2 &amp;&amp; ++aIndex_2 == 3))\n                    return \"B\";\n            }\n            else {\n                if (++bRow[x] == 3 || ++bCol[y] == 3 || (x == y &amp;&amp; ++bIndex_1 == 3) || (x + y == 2 &amp;&amp; ++bIndex_2 == 3))\n                    return \"A\";\n            }\n        }     \n        if (moves.size() == 9)\n            return \"Draw\";\n        else\n            return \"Pending\";\n    }\n};\n\n\n&lt;-E&gt; Minimum Time Visiting All Points\n\nclass Solution {\npublic:\n\n        int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n            int ans = 0;\n            for (int i = 1; i &lt; points.size(); i++) {\n                int x = points[i][0] - points[i - 1][0];\n                int y = points[i][1] - points[i - 1][1];\n                \n                if(x &lt; 0) x *= -1;\n                if(y &lt; 0) y *= -1;\n                \n                if(x == y) \n                    ans += x;\n                else\n                    ans += max(x,y);\n            }\n            return ans;\n        }\n};\n\n\n&lt;-E&gt; Shift 2D Grid\n\n// 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n       int row = grid.size();\n        int col = grid[0].size();\n        int n = row * col;\n        vector&lt;vector&lt;int&gt;&gt; ans = grid;\n        for(int i = 0; i &lt; n; i++) {\n            int j = (i + k) % n;\n            int ri = i / col;\n            int ci = i % col;\n            int rj = j / col;\n            int cj = j % col;\n            ans[rj][cj] = grid[ri][ci];\n        }\n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n       int row = grid.size();\n        int col = grid[0].size();\n        int n = row * col;\n        vector&lt;vector&lt;int&gt;&gt; ans = grid;\n        vector&lt;int&gt; tempArray;\n        for(auto i : grid)\n            for(auto j : i)\n                tempArray.push_back(j);\n        \n        for(int i = 0; i != k; i++) {\n            \n            tempArray.insert(tempArray.begin(), tempArray[n - 1]);\n            tempArray.pop_back();\n        }\n        \n        int index = 0;\n        for(int i = 0; i &lt; row; i++) {\n            for(int j = 0; j &lt; col; j++) {\n                ans[i][j] = tempArray[index];\n                index++;\n            }          \n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Check If It Is a Straight Line\n\nclass Solution {\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) {\n        bool temp = true;\n        \n        int a = coordinates[1][0] - coordinates[0][0];\n        int b = coordinates[1][1] - coordinates[0][1];\n        \n        for(int i = 2; i &lt; coordinates.size(); i++) {\n            int x = coordinates[i][0] - coordinates[0][0];\n            int y = coordinates[i][1] - coordinates[0][1];\n            if(a * y != x * b) \n                return false;\n        }            \n       return true;\n    }\n};\n\n\n&lt;-E&gt; Maximum 69 Number\n\nclass Solution {\npublic:\n    \n    int maximum69Number (int num) {\n        int ans = 0;\n        vector&lt;int&gt; temp;\n        while(num != 0) {\n            temp.push_back(num % 10);\n             num /= 10;\n        }\n        \n        for (int i = temp.size() - 1;  i &gt;= 0; i--) {\n            if (temp[i] == 6) {\n                temp[i] = 9;\n                break;\n            }\n        }\n        for (int i = temp.size() - 1; i &gt;= 0; i--) {\n            ans = ans * 10 + temp[i];\n        }\n        \n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n\n    int maximum69Number (int num) {\n        string temp = to_string(num);\n        for(int i = 0; i != temp.size(); i++)\n            if(temp[i] == '6') {\n                temp[i] = '9';\n                break;\n            }\n        int ans = 0;\n        for(int i = 0; i != temp.size(); i++)\n            ans =  ans * 10  + (temp[i]  - '0');\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Cells with Odd Values in a Matrix\n\nclass Solution {\npublic:\n    int oddCells(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; indices) {\n        int rowValue, colValue;\n        int a = 1;\n        int b = 1;\n        for(int i = 1; i != indices.size(); i++) {\n            rowValue = colValue = 0;\n            for(int j = i ; j &gt;= 0; j--) {\n                if(indices[i][0] == indices[j][0])\n                    rowValue++;\n                if(indices[i][1] == indices[j][1])\n                    colValue++;\n            }\n            if(rowValue % 2)\n                a++;\n            else\n                a--;\n            if(colValue % 2)\n                b++;\n            else\n                b--;\n        }\n        return a * m + b * n - 2 * a * b;\n    }\n};\n\n\n&lt;-E&gt; Split a String in Balanced Strings\n\nclass Solution {\npublic:\n    int balancedStringSplit(string s) {\n        int index = 1;\n        int ans = 0;\n        char temp = s[0];\n        for(int i = 1; i &lt; s.size(); i++) {\n            if(s[i] != temp) {\n                index--;\n            }\n            else\n                index++;\n            if(index == 0) {\n                ans++;\n                temp = s[i + 1];\n                index = 1;\n                i++;\n            }\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Play with Chips\n\nclass Solution {\npublic:\n    int minCostToMoveChips(vector&lt;int&gt;&amp; chips) {\n        int temp[2] = {0};\n        for(int a : chips){\n            temp[a%2]++;\n        }\n        return min(temp[0], temp[1]);\n    }\n};\n\n\n&lt;-E&gt;  Unique Number of Occurrences\n\nclass Solution {\npublic:\n    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {\n        int temp[2000] = {0};\n        for(int i = 0; i &lt; arr.size(); i++) {\n            temp[arr[i] + 1000]++;\n        }\n        \n        for(int i = 0; i &lt; 2000; i++) {\n            if(temp[i] != 0)\n                for(int j = i + 1; j &lt; 2000; j++) {\n                    if(temp[j] != 0)\n                        if(temp[i] == temp[j])\n                            return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n&lt;-E&gt; Minimum Absolute Difference\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) {\n        sort(arr.begin(), arr.end());\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        int temp = arr[1] - arr[0];\n        for(int i = 1; i &lt; arr.size(); i++) {\n            int n = abs(arr[i] - arr[i - 1]);\n            if(n &lt; temp) {\n                ans.clear();\n                temp = n;\n                ans.push_back({arr[i - 1], arr[i]});\n            }\n            else if(n == temp)\n                ans.push_back({arr[i - 1], arr[i]});\n                \n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Maximum Number of Balloons\n\nclass Solution {\npublic:       \n    int maxNumberOfBalloons(string text) {\n        int temp[5] = {0};\n        \n        for(int i = 0; i &lt; text.size(); i++) {\n            if(text[i] == 'a')\n                temp[0]++;\n            else if(text[i] == 'b')\n                temp[1]++;\n            else if(text[i] == 'l')\n                temp[2]++;\n            else if(text[i] == 'o')\n                temp[3]++;\n            else if(text[i] == 'n')\n                temp[4]++;\n        }\n        temp[2] /= 2;\n        temp[3] /= 2;\n\n        int ans = temp[0];\n        for(int i= 0; i &lt; 5; i++ )\n            if(ans &gt; temp[i]) {\n                ans = temp[i];\n            }    \n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Valid Parentheses\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        if (s.size() % 2)\n            return false;\n    \n        stack&lt;char&gt; st;\n        for (auto i = s.begin(); i != s.end(); i++) {\n            if (s.empty() &amp;&amp; (*i == ')' || *i == ']' || *i == '}')) {\n                return false;\n            }\n            if (!st.empty() &amp;&amp; (st.top() == '(' &amp;&amp; (*i == ']' || *i == '}'))) {\n                return false;\n            }\n            if (!st.empty() &amp;&amp; (st.top() == '[' &amp;&amp; (*i == ')' || *i == '}'))) {\n                return false;\n            }\n\n            if (!st.empty() &amp;&amp; (st.top() == '{' &amp;&amp; (*i == ')' || *i == ']'))) {\n                return false;\n            }\n\n            if (st.empty()) {\n                st.push(*i);\n                continue;\n            }\n            if ((st.top() == '(' &amp;&amp; *i == ')') || (st.top() == '[' &amp;&amp; *i == ']') || (st.top() == '{' &amp;&amp; *i == '}')) {\n                st.pop();\n                continue;\n            }\n            st.push(*i);\n        }\n\n        return st.empty();\n    }\n};\n\n\n&lt;-E&gt; Remove Duplicates from Sorted Array\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() == 0) return 0;\n        int index = 1;\n        int check = nums[0];\n        int set = 0;\n        for(int i = 1; i != nums.size(); i++) {\n            if(nums[i] != check) {\n                check = nums[i];\n                index++; \n                set ++;\n                nums[set] = nums[i];\n            }\n            \n            \n        }\n        return index;\n    }\n};\n\n\n&lt;-E&gt; Lucky Numbers in a Matrix\n\nclass Solution {\npublic:\n    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        vector&lt;int&gt; temp_min;\n        vector&lt;int&gt; temp_max;\n        vector&lt;int&gt; ans;\n        \n        for(int i = 0; i != matrix.size(); i++) {\n            int check_min = matrix[i][0];\n           for(int j = 0; j != matrix[0].size(); j++) {\n              if(check_min &gt; matrix[i][j])\n                  check_min = matrix[i][j];\n           }\n            temp_min.push_back(check_min);\n        }\n        for(int i = 0; i != matrix[0].size(); i++) {\n            int check_max = matrix[0][i];\n           for(int j = 0; j != matrix.size(); j++) {\n              if(check_max &lt; matrix[j][i])\n                  check_max = matrix[j][i];\n           }\n            temp_max.push_back(check_max);\n        }\n       \n        for(int i = 0; i != temp_min.size(); i++) {\n            if(find(temp_max.begin(), temp_max.end(), temp_min[i]) != temp_max.end())\n                ans.push_back(temp_min[i]);\n        }\n        \n        return ans;\n    }\n};\n\n// 解法2\nclass Solution {\npublic:\n    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        \n        vector&lt;int&gt; ans;\n        \n        int liRow = -1;\n        int liCol = -1;\n        \n        for( int i = 0; i &lt; matrix.size(); ++i ) {\n            int col = 0;\n            for( int j = 1; j &lt; matrix[i].size(); ++j ) {\n                if ( matrix[i][j] &lt; matrix[i][col])\n                    col = j;\n            }\n            \n            if ( liRow == -1 || matrix[liRow][liCol] &lt; matrix[i][col]) {\n                liRow = i;\n                liCol = col;\n            }\n        }\n        \n        for( int i = 0; i &lt; matrix.size(); ++i ) {\n            if ( matrix[i][liCol] &gt; matrix[liRow][liCol])\n                return ans;\n        }\n        ans.push_back(matrix[liRow][liCol]);\n        return  ans;\n        \n        \n    }\n};\n\n\n&lt;-E&gt; Non-decreasing Array\n\nclass Solution {\npublic:\n\tbool checkPossibility(vector&lt;int&gt;&amp; nums) {\n\t\tint cnt=0;\n\t\tfor(int i=1;i&lt;nums.size();i++){\n\t\t\tif(nums[i]&lt;nums[i-1]){\n\t\t\t\tcnt++;\n\t\t\t\tif(i-2 &gt;= 0 &amp;&amp; nums[i-2]&gt;nums[i]){\n\t\t\t\t\tnums[i]=nums[i-1];\n\t\t\t\t}\n\t\t\t\tif(cnt==2) break;\n\t\t\t}\n\t\t}\n\t\treturn cnt&lt;2;\n\n\t}\n};\n\n\n&lt;-E&gt; Defanging an IP Address\n\nclass Solution {\npublic:\n    string defangIPaddr(string address) {\n        string ans = \"\";\n        \n        for(auto i : address) \n            ans = ((i == '.') ? ans + \"[.]\": ans + i);\n        return ans;\n    }\n    \n};\n\n\n&lt;-E&gt; Number of Steps to Reduce a Number to Zero\n\nclass Solution {\npublic:\n    int numberOfSteps (int num) {\n        int i = 0;\n        while(num != 0) {\n            if(num % 2) \n                num -= 1;\n            else\n                num /= 2;\n            i++;\n        }\n        return i;\n    }\n};\n\n\n&lt;-E&gt; How Many Numbers Are Smaller Than the Current Number\n\nclass Solution {\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) {\n        int bucket[101] = {0};\n        for(auto i : nums)\n            bucket[i]++;\n        int index = 0;\n        for(int i = 0; i != 101; i++) {\n            if(bucket[i] != 0) {\n                if(bucket[i] == 1) {\n                    bucket[i] = index;\n                    index++;\n                }\n                else {\n                    int temp = bucket[i];\n                    bucket[i] = index;\n                    index += temp;\n                }\n            }\n        }\n        vector&lt;int&gt; ans(0, nums.size());\n        for(auto i : nums) {\n            ans.push_back(bucket[i]);\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Create Target Array in the Given Order\n\nclass Solution {\npublic:\n    vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != nums.size(); i++) \n            ans.insert(ans.begin() + index[i], nums[i]);\n        return ans;\n    }\n    \n};\n\n\n&lt;-E&gt; To Lower Case\n\nclass Solution {\npublic:\n    string toLowerCase(string str) {\n        for(auto &amp;i: str) {\n            if(i &gt;= 'A' &amp;&amp; i &lt;= 'Z')\n                i = i + 32;\n        }\n        return str;\n    }\n};\n\n\n&lt;-E&gt; Increasing Decreasing String\n\nclass Solution {\npublic:\n    string sortString(string s) {\n        int temp_letters[26] = {0};\n        for (auto i:s) {\n            temp_letters[ i - 'a']++;\n        }\n        string ans = \"\";\n        int i = 0;\n        while(true) {\n            if(ans.size() == s.size())\n                break;\n            i = 0;\n        \n            while(true) {\n                if(temp_letters[i] &gt; 0 ) {\n                    ans += i + 'a';\n                    temp_letters[i]--;\n                }\n                i++;\n                if(i == 26)\n                    break;;\n            }\n            i = 0;\n            while(true) {\n                if(temp_letters[25  - i] &gt; 0 ) {\n                    ans += 'z' - i;\n                    temp_letters[25 - i]--;\n                }\n                i++;\n                if(i == 26)\n                    break;;\n            }\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Self Dividing Numbers\n\nclass Solution {\npublic:\n    \n    bool f(int n) {\n        int temp = n;\n        int digit;\n         while(n != 0) {\n            digit = n % 10;\n            if(digit == 0 || temp % digit != 0 )\n                return false;\n            n /= 10;\n        }\n        return true;\n    }\n    \n    \n    vector&lt;int&gt; selfDividingNumbers(int left, int right) {\n        vector&lt;int&gt; ans;\n        for(int i = left; i &lt;= right; i++) {\n            if(i &lt; 10)\n                ans.push_back(i);\n            else {\n                if(f(i))\n                    ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n",
        "content": "2020年 02 月 26 日更新\n\n&lt;-E&gt; Two Sum 286ms 2.67%\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n    vector &lt;int&gt; answer;\n    for (auto i = 0; i != nums.size(); i++) {\n        for (auto j = i + 1; j != nums.size(); j++) {\n            if (nums[i] + nums[j] == target) {\n                answer.push_back(i);\n                answer.push_back(j);\n            }\n        }\n    }\n    return answer;\n}\n\n\n大佬的解法：\n利用hashmap的无序性。 hash.find(numberToFind) != hash.end() 如果没有找到，则将元素的值作为hash的key， 元素的位数为值添加到map中。以此类推直到找到该元素为止。\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {\n    //Key is the number and value is its index in the vector.\n    unordered_map&lt;int, int&gt; hash;\n    vector&lt;int&gt; result;\n    for (int i = 0; i &lt; numbers.size(); i++) {\n        int numberToFind = target - numbers[i];\n        // if numberToFind is found in map, return them\n        if (hash.find(numberToFind) != hash.end()) {\n            result.push_back(hash[numberToFind]);\n            result.push_back(i);\n            return result;\n        }\n        // number was not found. Put it in the map.\n        hash[numbers[i]] = i;\n    }\n    return result;\n}\n\n\n展开\n\n使用unordered_map来做。 该数据结构被定义在unordered_map 库中。\n\n\n  unordered_map 内部实现为哈希表。（所以是无序的）\n  map 内部实现为红黑树（所以map内部的元素都是有序的）\n\n\nmap\n\n优点：\n\n\n  有序性\n  内部由红黑树实现（使用红黑树特性的时候，效率快）\n\n\n缺点：\n\n\n  空间占用率高（节点）\n\n\nunordered_map\n\n优点：\n\n\n  查找快\n\n\n缺点：\n\n\n  建立hash表的时候，消耗大量时间\n\n\n&lt;-M&gt; Add Two Numbers 56ms 27.5%\n\n(l1 ? l1-&gt;val : 0)\nl1 = l1 ? l1-&gt;next : l1;\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int remainder = 0;\n        ListNode answer(0);\n        ListNode *p = &amp;answer;\n        while (l1 || l2 || remainder) {\n            int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + remainder;\n            remainder = sum / 10;\n            p-&gt;next = new ListNode(sum % 10);\n            p = p-&gt;next;\n            l1 = l1 ? l1-&gt;next : l1;\n            l2 = l2 ? l2-&gt;next : l2;\n        }\n        return answer.next;\n    }\n};\n\n\n&lt;-M&gt; Longest Substring Without Repeating Characters\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        vector&lt;-char&gt; check;\n        for (auto i = s.begin(); i != s.end(); i++) {\n            for (auto j = i; j != s.end(); j++) {\n                if (find(check.begin(), check.end(), *j) == check.end())\n                    check.push_back(*j);\n                else\n                    break;\n            }\n            if (ans &lt;- check.size()) {\n                ans = check.size();\n                check.clear();\n            }\n            else {\n                check.clear();\n            }\n        }\n        return ans;\n    }\n};\n\n\n&lt;-H&gt; Median of Two Sorted Arrays 62ms\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;-int&gt;&amp; nums1, vector&lt;-int&gt;&amp; nums2) {\n        vector&lt;-int&gt; Temp;\n        for (int i = 0; i != nums1.size(); i++) {\n            Temp.push_back(nums1[i]);\n        }\n        for (int i = 0; i != nums2.size(); i++) {\n            Temp.push_back(nums2[i]);\n        }\n        sort(Temp.begin(), Temp.end());\n        if (Temp.size() % 2 == 0)\n            return (Temp[Temp.size() / 2 - 1] + Temp[Temp.size() / 2]) / 2.0;\n        else\n            return  Temp[Temp.size() / 2];\n    }\n};\n\n\n&lt;-M&gt; Longest Palindromic Substring 9ms\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n    if (s.empty()) return \"\";\n    if (s.size() == 1) return s;\n    int min_start = 0, max_len = 1;\n    for (int i = 0; i &lt;- s.size();) {\n        if (s.size() - i &lt;-= max_len / 2) break;\n        int j = i, k = i;\n        while (k &lt;- s.size()-1 &amp;&amp; s[k+1] == s[k]) \n            ++k; \n      \n        // Skip duplicate characters.\n        \n        i = k+1;\n        while (k &lt;- s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) {\n            ++k; --j; \n        } \n        \n        // Expand.\n        int new_len = k - j + 1;\n        if (new_len &gt; max_len) { \n            min_start = j; max_len = new_len; \n        }\n    }\n    return s.substr(min_start, max_len);\n}\n};\n\n\n&lt;-M&gt; ZigZag Conversion 16ms\n\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n       if (numRows &lt;-= 1 || s.size() &lt;-= 1)\n        return s;\n        string result;\n        for (int i = 0; i &lt;- numRows; i++) {\n            for (int j = 0, index = i; index &lt;- s.size();j++, index = (2 * numRows - 2) * j + i) {\n                result.append(1, s[index]);\n                if (i == 0 || i == numRows - 1) \n                    continue;\n                if (index + (numRows - i - 1) * 2 &lt;- s.size())\n                    result.append(1, s[index + (numRows - i - 1) * 2]);\n            }\n        }\n        return result;\n    }\n};\n\n\n&lt;-E&gt; Reverse Integer 15ms 77.99%\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        int ans = 0;\n        while (x) {\n            int temp = ans * 10 + x % 10;\n            if (temp / 10 != ans)\n                return 0;\n            ans = temp;\n            x /= 10;\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n   int reverse(int x){\n        int n = 0;\n        while(x != 0) {\n            if(n &gt; INT_MAX / 10 || n &lt; INT_MIN / 10 || \n               (n == INT_MAX / 10 &amp;&amp; x % 10 &gt; INT_MAX % 10) ||\n               (n == INT_MIN / 10 &amp;&amp; x % 10 &lt; INT_MIN % 10))\n                return 0;\n            n = 10 * n + x % 10;\n            x /= 10;\n        }\n    return n;\n    }\n};\n\n\n&lt;-Bad Question -M&gt; String to Integer (atoi)\n\nclass Solution {\npublic:\n    int myAtoi(string str) {\n        int ans = 0;\n        int times = 1;\n        int checkflag = 1;\n        int end = 0;\n        if (str[0] == '+') {\n            end = 1;\n        }\n        if (str[0] == '-') {\n            end = 1;\n            checkflag = -1;\n        }\n        for (int i = str.size() - 1; i &gt;= end; i--) {\n            ans = (str[i] - '0') * times + ans;\n            times *= 10;\n        }\n        return ans * checkflag;\n    }\n};\n\n&lt; -E&gt; Palindrome Number\n\nbool isPalindrome(int x) {\n        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;\n        int sum=0;\n        while(x&gt;sum) {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n}\n\nbool isPalindrome(int x){\n    if(x &lt; 0)\n        return false;\n    else {\n        long int m = 0;\n        int n = x;\n        while(n != 0) {\n            m = m * 10 + n % 10;\n            n /= 10;\n        }\n        if(x == m)\n            return true;\n    }\n    return false;\n}\n\n\n\n&lt;-E&gt; Palindrome Number\n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;\n        int sum=0;\n        while(x&gt;sum) {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n\n    }\n};\n\n\n&lt;-E&gt; Longest Common Prefix\n\n求出最长的公共字串。这题有些歧义，根据Disucuss中的内容，增加条件如下：\n\n  {“a”,”a”,”b”} should give “” as there is nothing common in all the 3 strings.\n{“a”, “a”} should give “a” as a is longest common prefix in all the strings.\n{“abca”, “abc”} as abc\n{“ac”, “ac”, “a”, “a”} as a.\n\n\n有了该条件后，可以使用双重循环进行求解，在一般的操作中，需要注重边界值的问题。\n\nstring longestCommonPrefix(vector&lt;string&gt;&amp; strs) {\n    string prefix = \"\";\n    for(int idx=0; strs.size()&gt;0; prefix+=strs[0][idx], idx++)\n        for(int i=0; i&lt;strs.size(); i++)\n            if(idx &gt;= strs[i].size() ||(i &gt; 0 &amp;&amp; strs[i][idx] != strs[i-1][idx]))\n                return prefix;\n    return prefix;\n    }\n\n&lt;-E&gt; Subtract the Product and Sum of Digits of an Integer\n\nclass Solution {\npublic:\n    \n    int subtractProductAndSum(int n) {\n        int a = 1;\n        int b = 0;\n        int x;\n        while (n != 0) {\n            x = n % 10;\n            a *= x;\n            b += x;\n            n = n / 10;\n        }\n        return a - b;\n    }\n    \n};\n\n\n&lt;-E&gt; Convert Integer to the Sum of Two No-Zero Integers\n\nclass Solution {\npublic:\n    bool checkzero(int n) {\n        int x;\n        while (n != 0) {\n            x = n % 10;\n            if (x == 0)\n                return false;\n            n = n / 10;\n        }\n        return true;\n    }\n    vector&lt;int&gt; getNoZeroIntegers(int n) {\n        vector&lt;int&gt; a;\n        for (int i = 1; i != n; i++) {\n            if (checkzero(n - i) &amp;&amp; checkzero(i)) {\n                a.push_back(i);\n                a.push_back(n - i);\n                return a;\n            }\n            \n        }   \n       \n    }\n};\n\n\n&lt;-E&gt; Decompress Run-Length Encoded List\n\nclass Solution {\npublic:\n    vector&lt;int&gt; decompressRLElist(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i &lt; nums.size(); i+=2) {\n            for(int j = nums[i]; j != 0; j--) {\n                ans.push_back(nums[i + 1]);\n            }\n        }\n    return ans;    \n    }\n};\n\n\n&lt;-E&gt; Decrypt String from Alphabet to Integer Mapping\n\nclass Solution {\npublic:\n    string freqAlphabets(string s) {\n        string a = \"\";\n        int b;\n        for(int i = s.size() - 1; i &gt;= 0; i--) {\n            if(s[i] != '#')\n                b = s[i] - '0' + 96;\n            else {\n                b =   (s[i - 2] - '0' )* 10 +  (s[i - 1] - '0' ) + 96;\n                i -= 2;\n            }\n            a = (char)b + a;\n        }\n        return a;\n    }\n};\n\n\n&lt;-E&gt;  Find N Unique Integers Sum up to Zero\n\nclass Solution {\npublic:\n    vector&lt;int&gt; sumZero(int n) {\n        vector&lt;int&gt; ans;\n        if(n % 2) {\n            ans.push_back(0);\n            \n        }\n        else ;\n        for(int i = 1; i &lt;= n / 2; i++) {\n            ans.push_back(i);\n            ans.push_back(-i);\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;  Replace Elements with Greatest Element on Right Side\n\nclass Solution {\npublic:\n    vector&lt;int&gt; replaceElements(vector&lt;int&gt;&amp; arr) {\n        int temp = -1;\n        arr.push_back(-1);\n        for(int i = arr.size() - 2; i &gt;= 0; i--) {\n            if(arr[i] &gt; temp)\n                temp = arr[i];\n            else\n                arr[i] = temp;\n        }\n        arr.erase(arr.begin());\n        return arr;\n    }\n};\n\n\n&lt;-E&gt;  Find Numbers with Even Number of Digits\n\nclass Solution {\npublic:\n    bool checkEvenDights(int n) {\n        int dights = 0;\n        while(n != 0) {\n            n /= 10;\n            dights++;\n        }\n        if(dights % 2)\n            return false;\n        else\n            return true;\n    }\n    int findNumbers(vector&lt;int&gt;&amp; nums) {\n        int ans = 0;\n        for(auto i : nums) {\n            if(checkEvenDights(i))\n                ans++;\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;  Convert Binary Number in a Linked List to Integer\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        int ans = 0;\n        while(head != NULL) {\n            ans = ans * 2 + head-&gt;val;\n            head = head-&gt;next;\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;  Element Appearing More Than 25% In Sorted Array\n\nclass Solution {\npublic:\n    \n    int findSpecialInteger(vector&lt;int&gt;&amp; arr) {\n        int count = arr.size()  / 4;\n        int temp = arr[0];\n        int index = 0;\n        for(int i = 1; i &lt; arr.size(); i++) {\n            index++;\n            if(arr[i] != temp) {\n                temp = arr[i];\n                index = 0;\n            }\n            if(index &gt;= count)\n                return arr[i];\n        }\n        return arr[0];\n    }\n};\n\n\n&lt;-E&gt;  Jewels and Stones\n\n// 1\nclass Solution {\npublic:\n    int numJewelsInStones(string J, string S) {\n        int ans = 0;\n        for (auto i : S) {\n            if (find(J.begin(), J.end(), i) != J.end())\n                ans++;\n        }\n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n  int numJewelsInStones(string J, string S) {\n        int check[128] = {0};\n        for (int i = 0; i != S.size(); i++) {\n            check[S[i]]++;\n        }\n        \n        for (int i = 0; i != J.size(); i++) {\n            check[J[i]] = -check[J[i]];\n        }\n        int ans = 0;\n        for (int i = 0; i != 128; i++) {\n            if (check[i] &lt; 0)\n                ans = ans - check[i];\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;  Find Winner on a Tic Tac Toe Game\n\nclass Solution {\npublic:\n    string tictactoe(vector&lt;vector&lt;int&gt;&gt;&amp; moves) {\n        vector&lt;int&gt; aRow(3);\n        vector&lt;int&gt; bRow(3);\n        vector&lt;int&gt; aCol(3);\n        vector&lt;int&gt; bCol(3);\n        int aIndex_1 = 0;\n        int aIndex_2 = 0;\n        int bIndex_1 = 0;\n        int bIndex_2 = 0;\n        for (int i = 0; i &lt; moves.size(); i++) {\n            int x = moves[i][0];\n            int y = moves[i][1];   \n            if (i % 2) {\n                if (++aRow[x] == 3 || ++aCol[y] == 3 || (x == y &amp;&amp; ++aIndex_1 == 3) || (x + y == 2 &amp;&amp; ++aIndex_2 == 3))\n                    return \"B\";\n            }\n            else {\n                if (++bRow[x] == 3 || ++bCol[y] == 3 || (x == y &amp;&amp; ++bIndex_1 == 3) || (x + y == 2 &amp;&amp; ++bIndex_2 == 3))\n                    return \"A\";\n            }\n        }     \n        if (moves.size() == 9)\n            return \"Draw\";\n        else\n            return \"Pending\";\n    }\n};\n\n\n&lt;-E&gt; Minimum Time Visiting All Points\n\nclass Solution {\npublic:\n\n        int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n            int ans = 0;\n            for (int i = 1; i &lt; points.size(); i++) {\n                int x = points[i][0] - points[i - 1][0];\n                int y = points[i][1] - points[i - 1][1];\n                \n                if(x &lt; 0) x *= -1;\n                if(y &lt; 0) y *= -1;\n                \n                if(x == y) \n                    ans += x;\n                else\n                    ans += max(x,y);\n            }\n            return ans;\n        }\n};\n\n\n&lt;-E&gt; Shift 2D Grid\n\n// 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n       int row = grid.size();\n        int col = grid[0].size();\n        int n = row * col;\n        vector&lt;vector&lt;int&gt;&gt; ans = grid;\n        for(int i = 0; i &lt; n; i++) {\n            int j = (i + k) % n;\n            int ri = i / col;\n            int ci = i % col;\n            int rj = j / col;\n            int cj = j % col;\n            ans[rj][cj] = grid[ri][ci];\n        }\n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n       int row = grid.size();\n        int col = grid[0].size();\n        int n = row * col;\n        vector&lt;vector&lt;int&gt;&gt; ans = grid;\n        vector&lt;int&gt; tempArray;\n        for(auto i : grid)\n            for(auto j : i)\n                tempArray.push_back(j);\n        \n        for(int i = 0; i != k; i++) {\n            \n            tempArray.insert(tempArray.begin(), tempArray[n - 1]);\n            tempArray.pop_back();\n        }\n        \n        int index = 0;\n        for(int i = 0; i &lt; row; i++) {\n            for(int j = 0; j &lt; col; j++) {\n                ans[i][j] = tempArray[index];\n                index++;\n            }          \n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Check If It Is a Straight Line\n\nclass Solution {\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) {\n        bool temp = true;\n        \n        int a = coordinates[1][0] - coordinates[0][0];\n        int b = coordinates[1][1] - coordinates[0][1];\n        \n        for(int i = 2; i &lt; coordinates.size(); i++) {\n            int x = coordinates[i][0] - coordinates[0][0];\n            int y = coordinates[i][1] - coordinates[0][1];\n            if(a * y != x * b) \n                return false;\n        }            \n       return true;\n    }\n};\n\n\n&lt;-E&gt; Maximum 69 Number\n\nclass Solution {\npublic:\n    \n    int maximum69Number (int num) {\n        int ans = 0;\n        vector&lt;int&gt; temp;\n        while(num != 0) {\n            temp.push_back(num % 10);\n             num /= 10;\n        }\n        \n        for (int i = temp.size() - 1;  i &gt;= 0; i--) {\n            if (temp[i] == 6) {\n                temp[i] = 9;\n                break;\n            }\n        }\n        for (int i = temp.size() - 1; i &gt;= 0; i--) {\n            ans = ans * 10 + temp[i];\n        }\n        \n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n\n    int maximum69Number (int num) {\n        string temp = to_string(num);\n        for(int i = 0; i != temp.size(); i++)\n            if(temp[i] == '6') {\n                temp[i] = '9';\n                break;\n            }\n        int ans = 0;\n        for(int i = 0; i != temp.size(); i++)\n            ans =  ans * 10  + (temp[i]  - '0');\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Cells with Odd Values in a Matrix\n\nclass Solution {\npublic:\n    int oddCells(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; indices) {\n        int rowValue, colValue;\n        int a = 1;\n        int b = 1;\n        for(int i = 1; i != indices.size(); i++) {\n            rowValue = colValue = 0;\n            for(int j = i ; j &gt;= 0; j--) {\n                if(indices[i][0] == indices[j][0])\n                    rowValue++;\n                if(indices[i][1] == indices[j][1])\n                    colValue++;\n            }\n            if(rowValue % 2)\n                a++;\n            else\n                a--;\n            if(colValue % 2)\n                b++;\n            else\n                b--;\n        }\n        return a * m + b * n - 2 * a * b;\n    }\n};\n\n\n&lt;-E&gt; Split a String in Balanced Strings\n\nclass Solution {\npublic:\n    int balancedStringSplit(string s) {\n        int index = 1;\n        int ans = 0;\n        char temp = s[0];\n        for(int i = 1; i &lt; s.size(); i++) {\n            if(s[i] != temp) {\n                index--;\n            }\n            else\n                index++;\n            if(index == 0) {\n                ans++;\n                temp = s[i + 1];\n                index = 1;\n                i++;\n            }\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Play with Chips\n\nclass Solution {\npublic:\n    int minCostToMoveChips(vector&lt;int&gt;&amp; chips) {\n        int temp[2] = {0};\n        for(int a : chips){\n            temp[a%2]++;\n        }\n        return min(temp[0], temp[1]);\n    }\n};\n\n\n&lt;-E&gt;  Unique Number of Occurrences\n\nclass Solution {\npublic:\n    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {\n        int temp[2000] = {0};\n        for(int i = 0; i &lt; arr.size(); i++) {\n            temp[arr[i] + 1000]++;\n        }\n        \n        for(int i = 0; i &lt; 2000; i++) {\n            if(temp[i] != 0)\n                for(int j = i + 1; j &lt; 2000; j++) {\n                    if(temp[j] != 0)\n                        if(temp[i] == temp[j])\n                            return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n&lt;-E&gt; Minimum Absolute Difference\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) {\n        sort(arr.begin(), arr.end());\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        int temp = arr[1] - arr[0];\n        for(int i = 1; i &lt; arr.size(); i++) {\n            int n = abs(arr[i] - arr[i - 1]);\n            if(n &lt; temp) {\n                ans.clear();\n                temp = n;\n                ans.push_back({arr[i - 1], arr[i]});\n            }\n            else if(n == temp)\n                ans.push_back({arr[i - 1], arr[i]});\n                \n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Maximum Number of Balloons\n\nclass Solution {\npublic:       \n    int maxNumberOfBalloons(string text) {\n        int temp[5] = {0};\n        \n        for(int i = 0; i &lt; text.size(); i++) {\n            if(text[i] == 'a')\n                temp[0]++;\n            else if(text[i] == 'b')\n                temp[1]++;\n            else if(text[i] == 'l')\n                temp[2]++;\n            else if(text[i] == 'o')\n                temp[3]++;\n            else if(text[i] == 'n')\n                temp[4]++;\n        }\n        temp[2] /= 2;\n        temp[3] /= 2;\n\n        int ans = temp[0];\n        for(int i= 0; i &lt; 5; i++ )\n            if(ans &gt; temp[i]) {\n                ans = temp[i];\n            }    \n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Valid Parentheses\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        if (s.size() % 2)\n            return false;\n    \n        stack&lt;char&gt; st;\n        for (auto i = s.begin(); i != s.end(); i++) {\n            if (s.empty() &amp;&amp; (*i == ')' || *i == ']' || *i == '}')) {\n                return false;\n            }\n            if (!st.empty() &amp;&amp; (st.top() == '(' &amp;&amp; (*i == ']' || *i == '}'))) {\n                return false;\n            }\n            if (!st.empty() &amp;&amp; (st.top() == '[' &amp;&amp; (*i == ')' || *i == '}'))) {\n                return false;\n            }\n\n            if (!st.empty() &amp;&amp; (st.top() == '{' &amp;&amp; (*i == ')' || *i == ']'))) {\n                return false;\n            }\n\n            if (st.empty()) {\n                st.push(*i);\n                continue;\n            }\n            if ((st.top() == '(' &amp;&amp; *i == ')') || (st.top() == '[' &amp;&amp; *i == ']') || (st.top() == '{' &amp;&amp; *i == '}')) {\n                st.pop();\n                continue;\n            }\n            st.push(*i);\n        }\n\n        return st.empty();\n    }\n};\n\n\n&lt;-E&gt; Remove Duplicates from Sorted Array\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() == 0) return 0;\n        int index = 1;\n        int check = nums[0];\n        int set = 0;\n        for(int i = 1; i != nums.size(); i++) {\n            if(nums[i] != check) {\n                check = nums[i];\n                index++; \n                set ++;\n                nums[set] = nums[i];\n            }\n            \n            \n        }\n        return index;\n    }\n};\n\n\n&lt;-E&gt; Lucky Numbers in a Matrix\n\nclass Solution {\npublic:\n    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        vector&lt;int&gt; temp_min;\n        vector&lt;int&gt; temp_max;\n        vector&lt;int&gt; ans;\n        \n        for(int i = 0; i != matrix.size(); i++) {\n            int check_min = matrix[i][0];\n           for(int j = 0; j != matrix[0].size(); j++) {\n              if(check_min &gt; matrix[i][j])\n                  check_min = matrix[i][j];\n           }\n            temp_min.push_back(check_min);\n        }\n        for(int i = 0; i != matrix[0].size(); i++) {\n            int check_max = matrix[0][i];\n           for(int j = 0; j != matrix.size(); j++) {\n              if(check_max &lt; matrix[j][i])\n                  check_max = matrix[j][i];\n           }\n            temp_max.push_back(check_max);\n        }\n       \n        for(int i = 0; i != temp_min.size(); i++) {\n            if(find(temp_max.begin(), temp_max.end(), temp_min[i]) != temp_max.end())\n                ans.push_back(temp_min[i]);\n        }\n        \n        return ans;\n    }\n};\n\n// 解法2\nclass Solution {\npublic:\n    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        \n        vector&lt;int&gt; ans;\n        \n        int liRow = -1;\n        int liCol = -1;\n        \n        for( int i = 0; i &lt; matrix.size(); ++i ) {\n            int col = 0;\n            for( int j = 1; j &lt; matrix[i].size(); ++j ) {\n                if ( matrix[i][j] &lt; matrix[i][col])\n                    col = j;\n            }\n            \n            if ( liRow == -1 || matrix[liRow][liCol] &lt; matrix[i][col]) {\n                liRow = i;\n                liCol = col;\n            }\n        }\n        \n        for( int i = 0; i &lt; matrix.size(); ++i ) {\n            if ( matrix[i][liCol] &gt; matrix[liRow][liCol])\n                return ans;\n        }\n        ans.push_back(matrix[liRow][liCol]);\n        return  ans;\n        \n        \n    }\n};\n\n\n&lt;-E&gt; Non-decreasing Array\n\nclass Solution {\npublic:\n\tbool checkPossibility(vector&lt;int&gt;&amp; nums) {\n\t\tint cnt=0;\n\t\tfor(int i=1;i&lt;nums.size();i++){\n\t\t\tif(nums[i]&lt;nums[i-1]){\n\t\t\t\tcnt++;\n\t\t\t\tif(i-2 &gt;= 0 &amp;&amp; nums[i-2]&gt;nums[i]){\n\t\t\t\t\tnums[i]=nums[i-1];\n\t\t\t\t}\n\t\t\t\tif(cnt==2) break;\n\t\t\t}\n\t\t}\n\t\treturn cnt&lt;2;\n\n\t}\n};\n\n\n&lt;-E&gt; Defanging an IP Address\n\nclass Solution {\npublic:\n    string defangIPaddr(string address) {\n        string ans = \"\";\n        \n        for(auto i : address) \n            ans = ((i == '.') ? ans + \"[.]\": ans + i);\n        return ans;\n    }\n    \n};\n\n\n&lt;-E&gt; Number of Steps to Reduce a Number to Zero\n\nclass Solution {\npublic:\n    int numberOfSteps (int num) {\n        int i = 0;\n        while(num != 0) {\n            if(num % 2) \n                num -= 1;\n            else\n                num /= 2;\n            i++;\n        }\n        return i;\n    }\n};\n\n\n&lt;-E&gt; How Many Numbers Are Smaller Than the Current Number\n\nclass Solution {\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) {\n        int bucket[101] = {0};\n        for(auto i : nums)\n            bucket[i]++;\n        int index = 0;\n        for(int i = 0; i != 101; i++) {\n            if(bucket[i] != 0) {\n                if(bucket[i] == 1) {\n                    bucket[i] = index;\n                    index++;\n                }\n                else {\n                    int temp = bucket[i];\n                    bucket[i] = index;\n                    index += temp;\n                }\n            }\n        }\n        vector&lt;int&gt; ans(0, nums.size());\n        for(auto i : nums) {\n            ans.push_back(bucket[i]);\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Create Target Array in the Given Order\n\nclass Solution {\npublic:\n    vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != nums.size(); i++) \n            ans.insert(ans.begin() + index[i], nums[i]);\n        return ans;\n    }\n    \n};\n\n\n&lt;-E&gt; To Lower Case\n\nclass Solution {\npublic:\n    string toLowerCase(string str) {\n        for(auto &amp;i: str) {\n            if(i &gt;= 'A' &amp;&amp; i &lt;= 'Z')\n                i = i + 32;\n        }\n        return str;\n    }\n};\n\n\n&lt;-E&gt; Increasing Decreasing String\n\nclass Solution {\npublic:\n    string sortString(string s) {\n        int temp_letters[26] = {0};\n        for (auto i:s) {\n            temp_letters[ i - 'a']++;\n        }\n        string ans = \"\";\n        int i = 0;\n        while(true) {\n            if(ans.size() == s.size())\n                break;\n            i = 0;\n        \n            while(true) {\n                if(temp_letters[i] &gt; 0 ) {\n                    ans += i + 'a';\n                    temp_letters[i]--;\n                }\n                i++;\n                if(i == 26)\n                    break;;\n            }\n            i = 0;\n            while(true) {\n                if(temp_letters[25  - i] &gt; 0 ) {\n                    ans += 'z' - i;\n                    temp_letters[25 - i]--;\n                }\n                i++;\n                if(i == 26)\n                    break;;\n            }\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt; Self Dividing Numbers\n\nclass Solution {\npublic:\n    \n    bool f(int n) {\n        int temp = n;\n        int digit;\n         while(n != 0) {\n            digit = n % 10;\n            if(digit == 0 || temp % digit != 0 )\n                return false;\n            n /= 10;\n        }\n        return true;\n    }\n    \n    \n    vector&lt;int&gt; selfDividingNumbers(int left, int right) {\n        vector&lt;int&gt; ans;\n        for(int i = left; i &lt;= right; i++) {\n            if(i &lt; 10)\n                ans.push_back(i);\n            else {\n                if(f(i))\n                    ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n\n&lt;-E&gt;\n\n\n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/02/leetcode/"
      },
    
      {
        "title": "Study of R",
        "excerpt": "I think this notes may help me to get better understanding of R.\n\nhelp\n\nYou can type these codes to help you to understand the function which R is provided\n\n# get the help of function\nhelp(functionName)\n# get the args of one function\nargs(functionName)\n# get example of one function\nexample(functionName)\n\n# Or you can use opeaator '?' which is same as help\n?functionname\n\n\nOr perhaps you don’t know the exactly name of function, you can use these:\n\nhelp.search(partOfFunctionName)\n# Or\n??partOfFunctionName\n\n\nIf you want some details, or your computer dosen’t have the document of R. you can type this code:\n\nRSiteSearch(functionName)\n\nR\n\nIn fact, some constant values or functions you can type the name at will:\n\npi\n[1] 3.141593\nsqrt(2)\n[1] 1.414214\n\n\n  When you enter expressions like that, R evaluates the expression and then implicitly calls the print function\nBy the way, you can also write down the code print() to print the value of variable.\n\n\nVector\n\nIn your task, maybe you will find your sometime, data has miss one or two value,\nyou can use NA to replace it. if you do this. be sure to use na.rm=TRUE\nFor example, When you use the function to calculate the average\n\nx &lt;- c(0,1,1,2,3,NA)\nmean(x, na.rm=TRUE)\n\n\nSequence\n\nTo create the simple sequence n, n+1, n+2, …, m.\nYou can use two different way to initialize a sequence:\n\n\n  use operator : with two numbers. the first one means the begin of the sequence, the last one means the end of this sequence.\n  or you can type all this function name seq to build a sequence. using from as the begin, and to as the end of the sequence.\n\n\nThe sequence default the step is 1, if you want to change special step, use by to change it.\n\n1:5\n# [1] 1 2 3 4 5\nseq(from=1, to=5, by=2)\n# [1] 1 3 5\n\n\nIn some time you don’t know the exactly the step which you need. you can use length.out = #step# #step# you can replace it as the count Which you want get in Vector or Sequence. The R will calculate the step.\n\nseq(from=0, to=20, length.out=5)\n# [1] 0 5 10 15 20\n\n\nIf you want to create repeated sequence, you must use req to initialize\n\nrep(1, times=5)\n# [1] 1 1 1 1 1\n\n\nCompare\n\nThe R can compare between numbers, squence or vector. even number and squence.\nIn that case the only number will compare the value from vector, one by one. \nand the operator is same as C. using the &lt;, &gt;, &gt;=, &lt;=, ==, !=.\nfor example:\n\nx &lt;- c(3,4,4)\nv &lt;- 2\nx == v\n# [1] FALSE FALSE FALSE\n\n\nGet the value\n\nThe way to get value from Vector or Squence is same as C.\n\nx &lt;- seq(from=1, to=5)\nx[1]\n# [1] 1\n\n\nSelecting Vector Elements\n\nIt’s same as python.\n\nfib &lt;- c(0,1,1,2,3,5,8,13,21,34)\nfib[c(1,2,4,8)]\n# [1] 0 1 2 13\n\n\nBe care How to deal with [-1] R is different from Python.\nCheak the different:\n\nfib[1:3]\n# [1] 0 1 1\nfib[-(1:3)] \n# [1] 2 3 5 8 13 21 34\n\n\nIn python -index, means that is a value, which The penultimate index of  Vector or Sequence.\nBut In R, -index, means the index in Vector or Sequence will be ignored.\n\nOperator\n\n&lt;-\n\nassign a value to name\nsyntax:\n\n# These are same\nname &lt;- value\nvalue -&gt; name\n\nAnd &lt;- means the local variable, when you want to use the global variable, you should use &lt;&lt;-\n\nc\n\nUse the c() to initialize a vector.\nYou can not use C.\n\nc(1,1,2,3,5,8,13,21)\n# [1] 1 1 2 3 5 8 13 21\nv1 &lt;- c(1,2,3)\nv3 &lt;- c(\"A\",\"B\",\"C\")\nc(v1,v3)\n# [1] \"1\" \"2\" \"3\" \"A\" \"B\" \"C\"\n\n\nBe Care\n\nwhen you give different type in one vector, R will change some types, to make all the types are same.\nfor example is case below, the vector has two different types, numeric, character. Before creating the vector, thereby(从而) making the data elements\ncompatible(兼容).\n\nmode(3.1415)\n# [1] \"numeric\"\nmode(\"foo\")\n# [1] \"character\"\nc(3.1415, \"foo\")\n# [1] \"3.1415\" \"foo\"\nmode(c(3.1415, \"foo\"))\n# \"character\"\n\n\nfunction\n\ncat\n\nUse this funcation to combine multiple items into one string.\nBe noticed that the cat put one space between each items. for example:\n\ncat(\"The zero occurs at\", 2*pi, \"radians.\", \"\\n\")\n# The zero occurs at 6.283185 radians.\n\n\n  You must provide a newline character (\\n) to terminate the line.\n  A serious limitation is that it cannot print compound(夝坈) data structures such as matrices and lists.\n\n\nls()\n\nThe function displays the name of object in workspace.\nor you can yuo ls.str() to show more details.\n\n# if you workspace is empty\nls()\n# character(0)\nx &lt;- 3\nls()\n# [1] \"x\"\n# use ls.str() to get more details\nls.str()\n# x :  num 3\n\nAddSomeThing\n\nThe variables which begins with a dot(.) name are considered hidden and are not and are not normally of interest to users\n\n.x &lt;-10\nls()\n# character(0)\n\nbut you can use ls(all.name=TRUE) to show all variables include the hiddened one. R is Case sensitive\n\nrm()\n\nRemove the variables.\nfor example\n\nx &lt;- 10\nrm(x)\nls()\n# character(0)\n\nif you want to remove all variables, use rm(list=ls())\n\n\n  Never put rm(list=ls()) into code you share with others, such as a library function or sample code sent to a mailing list. Deleting all the variables in someone else’s workspace is worse than rude and will make you extremely unpopular.\n\n\nmode()\n\nTo cheak the type of variables.\nmode(3.14)\n# [1] \"numeric\"\n\n\nVector Math Function\n\n\n  mean (average value)\n  median\n  standard deviation\n  variance (方差)\n  correlation (相关系数)\n  covariance (坝方差)\nuse these function below:\n• mean(x)\n• median(x)\n• sd(x)\n• var(x)\n• cor(x, y)\n• cov(x, y)\n\n\nnames()\n\nGive the squence or vector every column a name.\nif you do not give enough names, R will give that column named  &lt;NA&gt;\nThen you can just use name to get the value.\n\nv &lt;- c(\"123\", \"123\", \"123\")\nnames(v)&lt;-c(\"test1\")\nv\n# test1  &lt;NA&gt;  &lt;NA&gt; \n# \"123\" \"123\" \"123\" \n\n\nv[\"test1\"]\n# test1 \n# \"123\" \n\n\nPackages\n\nYou can use Packages to help you finish a lot of things more easily.\n\n# This funcation will show all the function support in the libray\nlibray()\n# Or you can use the code below\ninstall.packages()[,c(\"Package\", \"Version\")]\n\n",
        "content": "I think this notes may help me to get better understanding of R.\n\nhelp\n\nYou can type these codes to help you to understand the function which R is provided\n\n# get the help of function\nhelp(functionName)\n# get the args of one function\nargs(functionName)\n# get example of one function\nexample(functionName)\n\n# Or you can use opeaator '?' which is same as help\n?functionname\n\n\nOr perhaps you don’t know the exactly name of function, you can use these:\n\nhelp.search(partOfFunctionName)\n# Or\n??partOfFunctionName\n\n\nIf you want some details, or your computer dosen’t have the document of R. you can type this code:\n\nRSiteSearch(functionName)\n\nR\n\nIn fact, some constant values or functions you can type the name at will:\n\npi\n[1] 3.141593\nsqrt(2)\n[1] 1.414214\n\n\n  When you enter expressions like that, R evaluates the expression and then implicitly calls the print function\nBy the way, you can also write down the code print() to print the value of variable.\n\n\nVector\n\nIn your task, maybe you will find your sometime, data has miss one or two value,\nyou can use NA to replace it. if you do this. be sure to use na.rm=TRUE\nFor example, When you use the function to calculate the average\n\nx &lt;- c(0,1,1,2,3,NA)\nmean(x, na.rm=TRUE)\n\n\nSequence\n\nTo create the simple sequence n, n+1, n+2, …, m.\nYou can use two different way to initialize a sequence:\n\n\n  use operator : with two numbers. the first one means the begin of the sequence, the last one means the end of this sequence.\n  or you can type all this function name seq to build a sequence. using from as the begin, and to as the end of the sequence.\n\n\nThe sequence default the step is 1, if you want to change special step, use by to change it.\n\n1:5\n# [1] 1 2 3 4 5\nseq(from=1, to=5, by=2)\n# [1] 1 3 5\n\n\nIn some time you don’t know the exactly the step which you need. you can use length.out = #step# #step# you can replace it as the count Which you want get in Vector or Sequence. The R will calculate the step.\n\nseq(from=0, to=20, length.out=5)\n# [1] 0 5 10 15 20\n\n\nIf you want to create repeated sequence, you must use req to initialize\n\nrep(1, times=5)\n# [1] 1 1 1 1 1\n\n\nCompare\n\nThe R can compare between numbers, squence or vector. even number and squence.\nIn that case the only number will compare the value from vector, one by one. \nand the operator is same as C. using the &lt;, &gt;, &gt;=, &lt;=, ==, !=.\nfor example:\n\nx &lt;- c(3,4,4)\nv &lt;- 2\nx == v\n# [1] FALSE FALSE FALSE\n\n\nGet the value\n\nThe way to get value from Vector or Squence is same as C.\n\nx &lt;- seq(from=1, to=5)\nx[1]\n# [1] 1\n\n\nSelecting Vector Elements\n\nIt’s same as python.\n\nfib &lt;- c(0,1,1,2,3,5,8,13,21,34)\nfib[c(1,2,4,8)]\n# [1] 0 1 2 13\n\n\nBe care How to deal with [-1] R is different from Python.\nCheak the different:\n\nfib[1:3]\n# [1] 0 1 1\nfib[-(1:3)] \n# [1] 2 3 5 8 13 21 34\n\n\nIn python -index, means that is a value, which The penultimate index of  Vector or Sequence.\nBut In R, -index, means the index in Vector or Sequence will be ignored.\n\nOperator\n\n&lt;-\n\nassign a value to name\nsyntax:\n\n# These are same\nname &lt;- value\nvalue -&gt; name\n\nAnd &lt;- means the local variable, when you want to use the global variable, you should use &lt;&lt;-\n\nc\n\nUse the c() to initialize a vector.\nYou can not use C.\n\nc(1,1,2,3,5,8,13,21)\n# [1] 1 1 2 3 5 8 13 21\nv1 &lt;- c(1,2,3)\nv3 &lt;- c(\"A\",\"B\",\"C\")\nc(v1,v3)\n# [1] \"1\" \"2\" \"3\" \"A\" \"B\" \"C\"\n\n\nBe Care\n\nwhen you give different type in one vector, R will change some types, to make all the types are same.\nfor example is case below, the vector has two different types, numeric, character. Before creating the vector, thereby(从而) making the data elements\ncompatible(兼容).\n\nmode(3.1415)\n# [1] \"numeric\"\nmode(\"foo\")\n# [1] \"character\"\nc(3.1415, \"foo\")\n# [1] \"3.1415\" \"foo\"\nmode(c(3.1415, \"foo\"))\n# \"character\"\n\n\nfunction\n\ncat\n\nUse this funcation to combine multiple items into one string.\nBe noticed that the cat put one space between each items. for example:\n\ncat(\"The zero occurs at\", 2*pi, \"radians.\", \"\\n\")\n# The zero occurs at 6.283185 radians.\n\n\n  You must provide a newline character (\\n) to terminate the line.\n  A serious limitation is that it cannot print compound(夝坈) data structures such as matrices and lists.\n\n\nls()\n\nThe function displays the name of object in workspace.\nor you can yuo ls.str() to show more details.\n\n# if you workspace is empty\nls()\n# character(0)\nx &lt;- 3\nls()\n# [1] \"x\"\n# use ls.str() to get more details\nls.str()\n# x :  num 3\n\nAddSomeThing\n\nThe variables which begins with a dot(.) name are considered hidden and are not and are not normally of interest to users\n\n.x &lt;-10\nls()\n# character(0)\n\nbut you can use ls(all.name=TRUE) to show all variables include the hiddened one. R is Case sensitive\n\nrm()\n\nRemove the variables.\nfor example\n\nx &lt;- 10\nrm(x)\nls()\n# character(0)\n\nif you want to remove all variables, use rm(list=ls())\n\n\n  Never put rm(list=ls()) into code you share with others, such as a library function or sample code sent to a mailing list. Deleting all the variables in someone else’s workspace is worse than rude and will make you extremely unpopular.\n\n\nmode()\n\nTo cheak the type of variables.\nmode(3.14)\n# [1] \"numeric\"\n\n\nVector Math Function\n\n\n  mean (average value)\n  median\n  standard deviation\n  variance (方差)\n  correlation (相关系数)\n  covariance (坝方差)\nuse these function below:\n• mean(x)\n• median(x)\n• sd(x)\n• var(x)\n• cor(x, y)\n• cov(x, y)\n\n\nnames()\n\nGive the squence or vector every column a name.\nif you do not give enough names, R will give that column named  &lt;NA&gt;\nThen you can just use name to get the value.\n\nv &lt;- c(\"123\", \"123\", \"123\")\nnames(v)&lt;-c(\"test1\")\nv\n# test1  &lt;NA&gt;  &lt;NA&gt; \n# \"123\" \"123\" \"123\" \n\n\nv[\"test1\"]\n# test1 \n# \"123\" \n\n\nPackages\n\nYou can use Packages to help you finish a lot of things more easily.\n\n# This funcation will show all the function support in the libray\nlibray()\n# Or you can use the code below\ninstall.packages()[,c(\"Package\", \"Version\")]\n\n",
        "url": "/notes/2019/11/02/stduy-of-R/"
      },
    
      {
        "title": "算法竞赛入门经典章节练习",
        "excerpt": "算法竞赛入门经典的习题，变种题是自己想的和自己添加的，其他的题目则为书本上选取\n\n第二章\n\n水仙花数\n\n输出100-999 中所有的水仙花数, ABC 满足 ABC = A^3 + B^3 + C^3 则称之为水仙花数\n\n适合穷举法\n\nvoid f_1(void) {\n    for (int i = 100; i &lt;= 999; i++) {\n        int a, b, c;\n        a = i / 100;\n        b = i / 10 % 10;\n        c = i % 100 % 10;\n        if (i == a * a * a + b * b * b + c * c * c)\n            printf(\"%d\\n\", i);\n    }\n}\n\n\n韩信点兵\n\n利用队尾剩余人数求出队伍总人数(人数大于10, 小于100)\n\ninput: 2 1 6\ninput: 2 1 3\noutput: 41\noutput: No answer\n\n适合穷举法\n\nvoid f_1(int a, int b, int c) {\n   for (int i = 10; i &lt;= 100; i++) {\n       if ((i % 3 == a) &amp;&amp; (i % 5 == b) &amp;&amp; (i % 7) == c) {\n           printf(\"%d\\n\", i);\n           return;\n       }\n   }\n   printf(\"No answer.\\n\");\n}\n\n\n倒三角形\n\n输出n层的倒三角形\n\nvoid f_1(int n) {\n    for (int i = n; i 0; i--) {\n        for (int j = n - i; j 0; j--)\n            printf(\" \");\n        for (int j = i * 2; j 1; j--)\n            printf(\"#\");\n        printf(\"\\n\");\n    }\n}\n\n\n计算子序列\n\n计算 1/n^2 + 1/(n + 1)^2 + … 1/m^2\n\ndouble f_1(long long n, long long m) {\n    double ans = 0;\n    while (n &lt;= m) {\n        ans = 1.0 / (n * n) + ans;\n        n++;\n    }\n    return ans;\n}\n\n\n分数化小数\n\n输入a,b,c 计算a/b, 精确到c位\n\n自己实现除法\nint division(int a, int b)\n{\n    int quotient;\n    quotient = 0;\n    while (a b) {\n        quotient++;\n        a -= b;\n    }\n    return quotient;\n}\n\nvoid f_1_1(int a, int b, int c) {\n    int quotient, remainder;\n    quotient = division(a, b);\n    remainder = a - quotient * b;\n    remainder *= pow(10, c);\n    int decimal;\n    decimal = division(remainder, b);\n    if ((remainder - decimal * b) % 100000 5)\n        decimal++;\n    char buffer[200] = { '0' };\n    sprintf(buffer, \"%d.%d\", quotient, decimal);\n        printf(\"%s\", buffer);\n}\n\n\n利用系统除法, 转换为string, 取出c位\n\nvoid f_1_2(int a, int b, int c) {\n    char buffer[200] = { '0' };\n    sprintf(buffer, \"%.100f\", (float)a / (float)b);\n    int temp;\n    int flag = 0;\n    for (int i = 0;; i++) {       \n        if (buffer[i] == '.') {\n            flag = 1;\n            temp = i;\n        }\n        if (flag == 1 &amp;&amp; (i - temp) == c) {\n            if(buffer[i + 1] - '0' 5)\n                printf(\"%c\", buffer[i] + 1);\n            else\n                printf(\"%c\", buffer[i]);\n            break;\n        }          \n        printf(\"%c\", buffer[i]);\n    }\n}\n\n\n分数化小数\n\n用1-9组成 3位数abc, def, ghi,每个数字恰好一次, 使得abc : def : ghi = 1 : 2: 3\n\n穷举法\n\nint check(int i) {\n    char buffer[10];\n    sprintf(buffer, \"%d%d%d\", i, i * 2, i * 3);\n    int flag = 0;\n    char a[10] = {0};\n    for (int i = 1; i &lt;= 9; i++) {\n        if (a[buffer[i] - '0'] != 'Q')\n            a[buffer[i] - '0'] = 'Q';\n        else\n            return 0;\n    }\n    return 1;\n}\nvoid f_1(void) {\n    for (int i = 101; i &lt; 333; i++) {\n        if (check(i))\n            printf(\"%d, %d, %d\\n\", i, i * 2, i * 3);\n    }\n}\n\n\n第三章\n",
        "content": "算法竞赛入门经典的习题，变种题是自己想的和自己添加的，其他的题目则为书本上选取\n\n第二章\n\n水仙花数\n\n输出100-999 中所有的水仙花数, ABC 满足 ABC = A^3 + B^3 + C^3 则称之为水仙花数\n\n适合穷举法\n\nvoid f_1(void) {\n    for (int i = 100; i &lt;= 999; i++) {\n        int a, b, c;\n        a = i / 100;\n        b = i / 10 % 10;\n        c = i % 100 % 10;\n        if (i == a * a * a + b * b * b + c * c * c)\n            printf(\"%d\\n\", i);\n    }\n}\n\n\n韩信点兵\n\n利用队尾剩余人数求出队伍总人数(人数大于10, 小于100)\n\ninput: 2 1 6\ninput: 2 1 3\noutput: 41\noutput: No answer\n\n适合穷举法\n\nvoid f_1(int a, int b, int c) {\n   for (int i = 10; i &lt;= 100; i++) {\n       if ((i % 3 == a) &amp;&amp; (i % 5 == b) &amp;&amp; (i % 7) == c) {\n           printf(\"%d\\n\", i);\n           return;\n       }\n   }\n   printf(\"No answer.\\n\");\n}\n\n\n倒三角形\n\n输出n层的倒三角形\n\nvoid f_1(int n) {\n    for (int i = n; i 0; i--) {\n        for (int j = n - i; j 0; j--)\n            printf(\" \");\n        for (int j = i * 2; j 1; j--)\n            printf(\"#\");\n        printf(\"\\n\");\n    }\n}\n\n\n计算子序列\n\n计算 1/n^2 + 1/(n + 1)^2 + … 1/m^2\n\ndouble f_1(long long n, long long m) {\n    double ans = 0;\n    while (n &lt;= m) {\n        ans = 1.0 / (n * n) + ans;\n        n++;\n    }\n    return ans;\n}\n\n\n分数化小数\n\n输入a,b,c 计算a/b, 精确到c位\n\n自己实现除法\nint division(int a, int b)\n{\n    int quotient;\n    quotient = 0;\n    while (a b) {\n        quotient++;\n        a -= b;\n    }\n    return quotient;\n}\n\nvoid f_1_1(int a, int b, int c) {\n    int quotient, remainder;\n    quotient = division(a, b);\n    remainder = a - quotient * b;\n    remainder *= pow(10, c);\n    int decimal;\n    decimal = division(remainder, b);\n    if ((remainder - decimal * b) % 100000 5)\n        decimal++;\n    char buffer[200] = { '0' };\n    sprintf(buffer, \"%d.%d\", quotient, decimal);\n        printf(\"%s\", buffer);\n}\n\n\n利用系统除法, 转换为string, 取出c位\n\nvoid f_1_2(int a, int b, int c) {\n    char buffer[200] = { '0' };\n    sprintf(buffer, \"%.100f\", (float)a / (float)b);\n    int temp;\n    int flag = 0;\n    for (int i = 0;; i++) {       \n        if (buffer[i] == '.') {\n            flag = 1;\n            temp = i;\n        }\n        if (flag == 1 &amp;&amp; (i - temp) == c) {\n            if(buffer[i + 1] - '0' 5)\n                printf(\"%c\", buffer[i] + 1);\n            else\n                printf(\"%c\", buffer[i]);\n            break;\n        }          \n        printf(\"%c\", buffer[i]);\n    }\n}\n\n\n分数化小数\n\n用1-9组成 3位数abc, def, ghi,每个数字恰好一次, 使得abc : def : ghi = 1 : 2: 3\n\n穷举法\n\nint check(int i) {\n    char buffer[10];\n    sprintf(buffer, \"%d%d%d\", i, i * 2, i * 3);\n    int flag = 0;\n    char a[10] = {0};\n    for (int i = 1; i &lt;= 9; i++) {\n        if (a[buffer[i] - '0'] != 'Q')\n            a[buffer[i] - '0'] = 'Q';\n        else\n            return 0;\n    }\n    return 1;\n}\nvoid f_1(void) {\n    for (int i = 101; i &lt; 333; i++) {\n        if (check(i))\n            printf(\"%d, %d, %d\\n\", i, i * 2, i * 3);\n    }\n}\n\n\n第三章\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/14/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AB%A0%E8%8A%82%E7%BB%83%E4%B9%A0/"
      },
    
      {
        "title": "看书疑问点",
        "excerpt": "看书的时候出现的各种问题\n\n算法竞赛入门经典\n\nP105\n\nsstream很慢, 比string 还慢 是否可以随便任意使用, 还是会有什么限制?\n\nC 语言\n\nc99的变长数组是线程安全的么\n\n是, 不安全的写法是语法错.\n\nJava\n\nfinal 关键字用来干啥的\n\n\n  修饰变量\n  final成员变量表示常量，只能被赋值一次，赋值后值不再改变。\n  修饰方法\n  final方法不能被子类方法覆盖，但可以被继承。\n  修饰类\n  final类不能被继承，没有子类，final类中所有方法都是final的。\n\n\nstatic final 和 final\n\nstatic final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。\n\nComparable 类怎么使用\n\n是个比较器, 此接口强行对实现它的每个类的对象进行整体排序. 如果非基本类型,需要自己实现compareTo() 方法.\n",
        "content": "看书的时候出现的各种问题\n\n算法竞赛入门经典\n\nP105\n\nsstream很慢, 比string 还慢 是否可以随便任意使用, 还是会有什么限制?\n\nC 语言\n\nc99的变长数组是线程安全的么\n\n是, 不安全的写法是语法错.\n\nJava\n\nfinal 关键字用来干啥的\n\n\n  修饰变量\n  final成员变量表示常量，只能被赋值一次，赋值后值不再改变。\n  修饰方法\n  final方法不能被子类方法覆盖，但可以被继承。\n  修饰类\n  final类不能被继承，没有子类，final类中所有方法都是final的。\n\n\nstatic final 和 final\n\nstatic final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。\n\nComparable 类怎么使用\n\n是个比较器, 此接口强行对实现它的每个类的对象进行整体排序. 如果非基本类型,需要自己实现compareTo() 方法.\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2019/11/18/%E7%9C%8B%E4%B9%A6%E7%96%91%E9%97%AE%E7%82%B9/"
      },
    
      {
        "title": "Two Sum 286ms 2.67%",
        "excerpt": "&lt;-E&gt; Two Sum 286ms 2.67%\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n    vector &lt;int&gt; answer;\n    for (auto i = 0; i != nums.size(); i++) {\n        for (auto j = i + 1; j != nums.size(); j++) {\n            if (nums[i] + nums[j] == target) {\n                answer.push_back(i);\n                answer.push_back(j);\n            }\n        }\n    }\n    return answer;\n}\n\n\n大佬的解法：\n利用hashmap的无序性。 hash.find(numberToFind) != hash.end() 如果没有找到，则将元素的值作为hash的key， 元素的位数为值添加到map中。以此类推直到找到该元素为止。\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {\n    //Key is the number and value is its index in the vector.\n    unordered_map&lt;int, int&gt; hash;\n    vector&lt;int&gt; result;\n    for (int i = 0; i &lt; numbers.size(); i++) {\n        int numberToFind = target - numbers[i];\n        // if numberToFind is found in map, return them\n        if (hash.find(numberToFind) != hash.end()) {\n            result.push_back(hash[numberToFind]);\n            result.push_back(i);\n            return result;\n        }\n        // number was not found. Put it in the map.\n        hash[numbers[i]] = i;\n    }\n    return result;\n}\n\n\n展开\n\n使用unordered_map来做。 该数据结构被定义在unordered_map 库中。\n\n\n  unordered_map 内部实现为哈希表。（所以是无序的）\n  map 内部实现为红黑树（所以map内部的元素都是有序的）\n\n\nmap\n\n优点：\n\n\n  有序性\n  内部由红黑树实现（使用红黑树特性的时候，效率快）\n\n\n缺点：\n\n\n  空间占用率高（节点）\n\n\nunordered_map\n\n优点：\n\n\n  查找快\n\n\n缺点：\n\n\n  建立hash表的时候，消耗大量时间\n\n\n",
        "content": "&lt;-E&gt; Two Sum 286ms 2.67%\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n    vector &lt;int&gt; answer;\n    for (auto i = 0; i != nums.size(); i++) {\n        for (auto j = i + 1; j != nums.size(); j++) {\n            if (nums[i] + nums[j] == target) {\n                answer.push_back(i);\n                answer.push_back(j);\n            }\n        }\n    }\n    return answer;\n}\n\n\n大佬的解法：\n利用hashmap的无序性。 hash.find(numberToFind) != hash.end() 如果没有找到，则将元素的值作为hash的key， 元素的位数为值添加到map中。以此类推直到找到该元素为止。\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {\n    //Key is the number and value is its index in the vector.\n    unordered_map&lt;int, int&gt; hash;\n    vector&lt;int&gt; result;\n    for (int i = 0; i &lt; numbers.size(); i++) {\n        int numberToFind = target - numbers[i];\n        // if numberToFind is found in map, return them\n        if (hash.find(numberToFind) != hash.end()) {\n            result.push_back(hash[numberToFind]);\n            result.push_back(i);\n            return result;\n        }\n        // number was not found. Put it in the map.\n        hash[numbers[i]] = i;\n    }\n    return result;\n}\n\n\n展开\n\n使用unordered_map来做。 该数据结构被定义在unordered_map 库中。\n\n\n  unordered_map 内部实现为哈希表。（所以是无序的）\n  map 内部实现为红黑树（所以map内部的元素都是有序的）\n\n\nmap\n\n优点：\n\n\n  有序性\n  内部由红黑树实现（使用红黑树特性的时候，效率快）\n\n\n缺点：\n\n\n  空间占用率高（节点）\n\n\nunordered_map\n\n优点：\n\n\n  查找快\n\n\n缺点：\n\n\n  建立hash表的时候，消耗大量时间\n\n\n",
        "url": "/2020/01/01/Two-Sum-286ms-2.67/"
      },
    
      {
        "title": "Add Two Numbers 56ms 27.5%",
        "excerpt": "&lt;-M&gt; Add Two Numbers 56ms 27.5%\n\n(l1 ? l1-&gt;val : 0)\nl1 = l1 ? l1-&gt;next : l1;\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int remainder = 0;\n        ListNode answer(0);\n        ListNode *p = &amp;answer;\n        while (l1 || l2 || remainder) {\n            int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + remainder;\n            remainder = sum / 10;\n            p-&gt;next = new ListNode(sum % 10);\n            p = p-&gt;next;\n            l1 = l1 ? l1-&gt;next : l1;\n            l2 = l2 ? l2-&gt;next : l2;\n        }\n        return answer.next;\n    }\n};\n\n\n",
        "content": "&lt;-M&gt; Add Two Numbers 56ms 27.5%\n\n(l1 ? l1-&gt;val : 0)\nl1 = l1 ? l1-&gt;next : l1;\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int remainder = 0;\n        ListNode answer(0);\n        ListNode *p = &amp;answer;\n        while (l1 || l2 || remainder) {\n            int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + remainder;\n            remainder = sum / 10;\n            p-&gt;next = new ListNode(sum % 10);\n            p = p-&gt;next;\n            l1 = l1 ? l1-&gt;next : l1;\n            l2 = l2 ? l2-&gt;next : l2;\n        }\n        return answer.next;\n    }\n};\n\n\n",
        "url": "/2020/01/02/Add-Two-Numbers-56ms-27.5/"
      },
    
      {
        "title": "Longest Substring Without Repeating Characters",
        "excerpt": "&lt;-M&gt; Longest Substring Without Repeating Characters\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        vector&lt;-char&gt; check;\n        for (auto i = s.begin(); i != s.end(); i++) {\n            for (auto j = i; j != s.end(); j++) {\n                if (find(check.begin(), check.end(), *j) == check.end())\n                    check.push_back(*j);\n                else\n                    break;\n            }\n            if (ans &lt;- check.size()) {\n                ans = check.size();\n                check.clear();\n            }\n            else {\n                check.clear();\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-M&gt; Longest Substring Without Repeating Characters\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        vector&lt;-char&gt; check;\n        for (auto i = s.begin(); i != s.end(); i++) {\n            for (auto j = i; j != s.end(); j++) {\n                if (find(check.begin(), check.end(), *j) == check.end())\n                    check.push_back(*j);\n                else\n                    break;\n            }\n            if (ans &lt;- check.size()) {\n                ans = check.size();\n                check.clear();\n            }\n            else {\n                check.clear();\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/01/03/Longest-Substring-Without-Repeating-Characters/"
      },
    
      {
        "title": "Median of Two Sorted Arrays 62ms",
        "excerpt": "&lt;-H&gt; Median of Two Sorted Arrays 62ms\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;-int&gt;&amp; nums1, vector&lt;-int&gt;&amp; nums2) {\n        vector&lt;-int&gt; Temp;\n        for (int i = 0; i != nums1.size(); i++) {\n            Temp.push_back(nums1[i]);\n        }\n        for (int i = 0; i != nums2.size(); i++) {\n            Temp.push_back(nums2[i]);\n        }\n        sort(Temp.begin(), Temp.end());\n        if (Temp.size() % 2 == 0)\n            return (Temp[Temp.size() / 2 - 1] + Temp[Temp.size() / 2]) / 2.0;\n        else\n            return  Temp[Temp.size() / 2];\n    }\n};\n\n\n",
        "content": "&lt;-H&gt; Median of Two Sorted Arrays 62ms\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;-int&gt;&amp; nums1, vector&lt;-int&gt;&amp; nums2) {\n        vector&lt;-int&gt; Temp;\n        for (int i = 0; i != nums1.size(); i++) {\n            Temp.push_back(nums1[i]);\n        }\n        for (int i = 0; i != nums2.size(); i++) {\n            Temp.push_back(nums2[i]);\n        }\n        sort(Temp.begin(), Temp.end());\n        if (Temp.size() % 2 == 0)\n            return (Temp[Temp.size() / 2 - 1] + Temp[Temp.size() / 2]) / 2.0;\n        else\n            return  Temp[Temp.size() / 2];\n    }\n};\n\n\n",
        "url": "/2020/01/04/Median-of-Two-Sorted-Arrays-62ms/"
      },
    
      {
        "title": "Longest Palindromic Substring 9ms",
        "excerpt": "&lt;-M&gt; Longest Palindromic Substring 9ms\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n    if (s.empty()) return \"\";\n    if (s.size() == 1) return s;\n    int min_start = 0, max_len = 1;\n    for (int i = 0; i &lt;- s.size();) {\n        if (s.size() - i &lt;-= max_len / 2) break;\n        int j = i, k = i;\n        while (k &lt;- s.size()-1 &amp;&amp; s[k+1] == s[k]) \n            ++k; \n      \n        // Skip duplicate characters.\n        \n        i = k+1;\n        while (k &lt;- s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) {\n            ++k; --j; \n        } \n        \n        // Expand.\n        int new_len = k - j + 1;\n        if (new_len &gt; max_len) { \n            min_start = j; max_len = new_len; \n        }\n    }\n    return s.substr(min_start, max_len);\n}\n};\n\n\n",
        "content": "&lt;-M&gt; Longest Palindromic Substring 9ms\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n    if (s.empty()) return \"\";\n    if (s.size() == 1) return s;\n    int min_start = 0, max_len = 1;\n    for (int i = 0; i &lt;- s.size();) {\n        if (s.size() - i &lt;-= max_len / 2) break;\n        int j = i, k = i;\n        while (k &lt;- s.size()-1 &amp;&amp; s[k+1] == s[k]) \n            ++k; \n      \n        // Skip duplicate characters.\n        \n        i = k+1;\n        while (k &lt;- s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) {\n            ++k; --j; \n        } \n        \n        // Expand.\n        int new_len = k - j + 1;\n        if (new_len &gt; max_len) { \n            min_start = j; max_len = new_len; \n        }\n    }\n    return s.substr(min_start, max_len);\n}\n};\n\n\n",
        "url": "/2020/01/05/Longest-Palindromic-Substring-9ms/"
      },
    
      {
        "title": "ZigZag Conversion 16ms",
        "excerpt": "&lt;-M&gt; ZigZag Conversion 16ms\n\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n       if (numRows &lt;-= 1 || s.size() &lt;-= 1)\n        return s;\n        string result;\n        for (int i = 0; i &lt;- numRows; i++) {\n            for (int j = 0, index = i; index &lt;- s.size();j++, index = (2 * numRows - 2) * j + i) {\n                result.append(1, s[index]);\n                if (i == 0 || i == numRows - 1) \n                    continue;\n                if (index + (numRows - i - 1) * 2 &lt;- s.size())\n                    result.append(1, s[index + (numRows - i - 1) * 2]);\n            }\n        }\n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-M&gt; ZigZag Conversion 16ms\n\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n       if (numRows &lt;-= 1 || s.size() &lt;-= 1)\n        return s;\n        string result;\n        for (int i = 0; i &lt;- numRows; i++) {\n            for (int j = 0, index = i; index &lt;- s.size();j++, index = (2 * numRows - 2) * j + i) {\n                result.append(1, s[index]);\n                if (i == 0 || i == numRows - 1) \n                    continue;\n                if (index + (numRows - i - 1) * 2 &lt;- s.size())\n                    result.append(1, s[index + (numRows - i - 1) * 2]);\n            }\n        }\n        return result;\n    }\n};\n\n\n",
        "url": "/2020/01/06/ZigZag-Conversion-16ms/"
      },
    
      {
        "title": "Reverse Integer 15ms 77.99%",
        "excerpt": "&lt;-E&gt; Reverse Integer 15ms 77.99%\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        int ans = 0;\n        while (x) {\n            int temp = ans * 10 + x % 10;\n            if (temp / 10 != ans)\n                return 0;\n            ans = temp;\n            x /= 10;\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n   int reverse(int x){\n        int n = 0;\n        while(x != 0) {\n            if(n &gt; INT_MAX / 10 || n &lt; INT_MIN / 10 || \n               (n == INT_MAX / 10 &amp;&amp; x % 10 &gt; INT_MAX % 10) ||\n               (n == INT_MIN / 10 &amp;&amp; x % 10 &lt; INT_MIN % 10))\n                return 0;\n            n = 10 * n + x % 10;\n            x /= 10;\n        }\n    return n;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Reverse Integer 15ms 77.99%\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        int ans = 0;\n        while (x) {\n            int temp = ans * 10 + x % 10;\n            if (temp / 10 != ans)\n                return 0;\n            ans = temp;\n            x /= 10;\n        }\n        return ans;\n    }\n};\n\nclass Solution {\npublic:\n   int reverse(int x){\n        int n = 0;\n        while(x != 0) {\n            if(n &gt; INT_MAX / 10 || n &lt; INT_MIN / 10 || \n               (n == INT_MAX / 10 &amp;&amp; x % 10 &gt; INT_MAX % 10) ||\n               (n == INT_MIN / 10 &amp;&amp; x % 10 &lt; INT_MIN % 10))\n                return 0;\n            n = 10 * n + x % 10;\n            x /= 10;\n        }\n    return n;\n    }\n};\n\n\n",
        "url": "/2020/01/07/Reverse-Integer-15ms-77.99/"
      },
    
      {
        "title": "Palindrome Number",
        "excerpt": "&lt; -E&gt; Palindrome Number\n\nbool isPalindrome(int x) {\n        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;\n        int sum=0;\n        while(x&gt;sum) {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n}\n\nbool isPalindrome(int x){\n    if(x &lt; 0)\n        return false;\n    else {\n        long int m = 0;\n        int n = x;\n        while(n != 0) {\n            m = m * 10 + n % 10;\n            n /= 10;\n        }\n        if(x == m)\n            return true;\n    }\n    return false;\n}\n\n\n\n",
        "content": "&lt; -E&gt; Palindrome Number\n\nbool isPalindrome(int x) {\n        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;\n        int sum=0;\n        while(x&gt;sum) {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n}\n\nbool isPalindrome(int x){\n    if(x &lt; 0)\n        return false;\n    else {\n        long int m = 0;\n        int n = x;\n        while(n != 0) {\n            m = m * 10 + n % 10;\n            n /= 10;\n        }\n        if(x == m)\n            return true;\n    }\n    return false;\n}\n\n\n\n",
        "url": "/2020/01/09/Palindrome-Number/"
      },
    
      {
        "title": "Palindrome Number",
        "excerpt": "&lt;-E&gt; Palindrome Number\n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;\n        int sum=0;\n        while(x&gt;sum) {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Palindrome Number\n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;\n        int sum=0;\n        while(x&gt;sum) {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n\n    }\n};\n\n\n",
        "url": "/2020/01/10/Palindrome-Number/"
      },
    
      {
        "title": "Longest Common Prefix",
        "excerpt": "&lt;-E&gt; Longest Common Prefix\n\n求出最长的公共字串。这题有些歧义，根据Disucuss中的内容，增加条件如下：\n\n  {“a”,”a”,”b”} should give “” as there is nothing common in all the 3 strings.\n{“a”, “a”} should give “a” as a is longest common prefix in all the strings.\n{“abca”, “abc”} as abc\n{“ac”, “ac”, “a”, “a”} as a.\n\n\n有了该条件后，可以使用双重循环进行求解，在一般的操作中，需要注重边界值的问题。\n\nstring longestCommonPrefix(vector&lt;string&gt;&amp; strs) {\n    string prefix = \"\";\n    for(int idx=0; strs.size()&gt;0; prefix+=strs[0][idx], idx++)\n        for(int i=0; i&lt;strs.size(); i++)\n            if(idx &gt;= strs[i].size() ||(i &gt; 0 &amp;&amp; strs[i][idx] != strs[i-1][idx]))\n                return prefix;\n    return prefix;\n    }\n\n",
        "content": "&lt;-E&gt; Longest Common Prefix\n\n求出最长的公共字串。这题有些歧义，根据Disucuss中的内容，增加条件如下：\n\n  {“a”,”a”,”b”} should give “” as there is nothing common in all the 3 strings.\n{“a”, “a”} should give “a” as a is longest common prefix in all the strings.\n{“abca”, “abc”} as abc\n{“ac”, “ac”, “a”, “a”} as a.\n\n\n有了该条件后，可以使用双重循环进行求解，在一般的操作中，需要注重边界值的问题。\n\nstring longestCommonPrefix(vector&lt;string&gt;&amp; strs) {\n    string prefix = \"\";\n    for(int idx=0; strs.size()&gt;0; prefix+=strs[0][idx], idx++)\n        for(int i=0; i&lt;strs.size(); i++)\n            if(idx &gt;= strs[i].size() ||(i &gt; 0 &amp;&amp; strs[i][idx] != strs[i-1][idx]))\n                return prefix;\n    return prefix;\n    }\n\n",
        "url": "/2020/01/11/Longest-Common-Prefix/"
      },
    
      {
        "title": "Subtract the Product and Sum of Digits of an Integer",
        "excerpt": "&lt;-E&gt; Subtract the Product and Sum of Digits of an Integer\n\nclass Solution {\npublic:\n    \n    int subtractProductAndSum(int n) {\n        int a = 1;\n        int b = 0;\n        int x;\n        while (n != 0) {\n            x = n % 10;\n            a *= x;\n            b += x;\n            n = n / 10;\n        }\n        return a - b;\n    }\n    \n};\n\n\n",
        "content": "&lt;-E&gt; Subtract the Product and Sum of Digits of an Integer\n\nclass Solution {\npublic:\n    \n    int subtractProductAndSum(int n) {\n        int a = 1;\n        int b = 0;\n        int x;\n        while (n != 0) {\n            x = n % 10;\n            a *= x;\n            b += x;\n            n = n / 10;\n        }\n        return a - b;\n    }\n    \n};\n\n\n",
        "url": "/2020/01/12/Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/"
      },
    
      {
        "title": "Convert Integer to the Sum of Two No-Zero Integers",
        "excerpt": "&lt;-E&gt; Convert Integer to the Sum of Two No-Zero Integers\n\nclass Solution {\npublic:\n    bool checkzero(int n) {\n        int x;\n        while (n != 0) {\n            x = n % 10;\n            if (x == 0)\n                return false;\n            n = n / 10;\n        }\n        return true;\n    }\n    vector&lt;int&gt; getNoZeroIntegers(int n) {\n        vector&lt;int&gt; a;\n        for (int i = 1; i != n; i++) {\n            if (checkzero(n - i) &amp;&amp; checkzero(i)) {\n                a.push_back(i);\n                a.push_back(n - i);\n                return a;\n            }\n            \n        }   \n       \n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Convert Integer to the Sum of Two No-Zero Integers\n\nclass Solution {\npublic:\n    bool checkzero(int n) {\n        int x;\n        while (n != 0) {\n            x = n % 10;\n            if (x == 0)\n                return false;\n            n = n / 10;\n        }\n        return true;\n    }\n    vector&lt;int&gt; getNoZeroIntegers(int n) {\n        vector&lt;int&gt; a;\n        for (int i = 1; i != n; i++) {\n            if (checkzero(n - i) &amp;&amp; checkzero(i)) {\n                a.push_back(i);\n                a.push_back(n - i);\n                return a;\n            }\n            \n        }   \n       \n    }\n};\n\n\n",
        "url": "/2020/01/13/Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers/"
      },
    
      {
        "title": "Decompress Run-Length Encoded List",
        "excerpt": "&lt;-E&gt; Decompress Run-Length Encoded List\n\nclass Solution {\npublic:\n    vector&lt;int&gt; decompressRLElist(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i &lt; nums.size(); i+=2) {\n            for(int j = nums[i]; j != 0; j--) {\n                ans.push_back(nums[i + 1]);\n            }\n        }\n    return ans;    \n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Decompress Run-Length Encoded List\n\nclass Solution {\npublic:\n    vector&lt;int&gt; decompressRLElist(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i &lt; nums.size(); i+=2) {\n            for(int j = nums[i]; j != 0; j--) {\n                ans.push_back(nums[i + 1]);\n            }\n        }\n    return ans;    \n    }\n};\n\n\n",
        "url": "/2020/01/14/Decompress-Run-Length-Encoded-List/"
      },
    
      {
        "title": "Decrypt String from Alphabet to Integer Mapping",
        "excerpt": "&lt;-E&gt; Decrypt String from Alphabet to Integer Mapping\n\nclass Solution {\npublic:\n    string freqAlphabets(string s) {\n        string a = \"\";\n        int b;\n        for(int i = s.size() - 1; i &gt;= 0; i--) {\n            if(s[i] != '#')\n                b = s[i] - '0' + 96;\n            else {\n                b =   (s[i - 2] - '0' )* 10 +  (s[i - 1] - '0' ) + 96;\n                i -= 2;\n            }\n            a = (char)b + a;\n        }\n        return a;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Decrypt String from Alphabet to Integer Mapping\n\nclass Solution {\npublic:\n    string freqAlphabets(string s) {\n        string a = \"\";\n        int b;\n        for(int i = s.size() - 1; i &gt;= 0; i--) {\n            if(s[i] != '#')\n                b = s[i] - '0' + 96;\n            else {\n                b =   (s[i - 2] - '0' )* 10 +  (s[i - 1] - '0' ) + 96;\n                i -= 2;\n            }\n            a = (char)b + a;\n        }\n        return a;\n    }\n};\n\n\n",
        "url": "/2020/01/15/Decrypt-String-from-Alphabet-to-Integer-Mapping/"
      },
    
      {
        "title": "Find N Unique Integers Sum up to Zero",
        "excerpt": "&lt;-E&gt;  Find N Unique Integers Sum up to Zero\n\nclass Solution {\npublic:\n    vector&lt;int&gt; sumZero(int n) {\n        vector&lt;int&gt; ans;\n        if(n % 2) {\n            ans.push_back(0);\n            \n        }\n        else ;\n        for(int i = 1; i &lt;= n / 2; i++) {\n            ans.push_back(i);\n            ans.push_back(-i);\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt;  Find N Unique Integers Sum up to Zero\n\nclass Solution {\npublic:\n    vector&lt;int&gt; sumZero(int n) {\n        vector&lt;int&gt; ans;\n        if(n % 2) {\n            ans.push_back(0);\n            \n        }\n        else ;\n        for(int i = 1; i &lt;= n / 2; i++) {\n            ans.push_back(i);\n            ans.push_back(-i);\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/01/16/Find-N-Unique-Integers-Sum-up-to-Zero/"
      },
    
      {
        "title": "Replace Elements with Greatest Element on Right Side",
        "excerpt": "&lt;-E&gt;  Replace Elements with Greatest Element on Right Side\n\nclass Solution {\npublic:\n    vector&lt;int&gt; replaceElements(vector&lt;int&gt;&amp; arr) {\n        int temp = -1;\n        arr.push_back(-1);\n        for(int i = arr.size() - 2; i &gt;= 0; i--) {\n            if(arr[i] &gt; temp)\n                temp = arr[i];\n            else\n                arr[i] = temp;\n        }\n        arr.erase(arr.begin());\n        return arr;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt;  Replace Elements with Greatest Element on Right Side\n\nclass Solution {\npublic:\n    vector&lt;int&gt; replaceElements(vector&lt;int&gt;&amp; arr) {\n        int temp = -1;\n        arr.push_back(-1);\n        for(int i = arr.size() - 2; i &gt;= 0; i--) {\n            if(arr[i] &gt; temp)\n                temp = arr[i];\n            else\n                arr[i] = temp;\n        }\n        arr.erase(arr.begin());\n        return arr;\n    }\n};\n\n\n",
        "url": "/2020/01/17/Replace-Elements-with-Greatest-Element-on-Right-Side/"
      },
    
      {
        "title": "Find Numbers with Even Number of Digits",
        "excerpt": "&lt;-E&gt;  Find Numbers with Even Number of Digits\n\nclass Solution {\npublic:\n    bool checkEvenDights(int n) {\n        int dights = 0;\n        while(n != 0) {\n            n /= 10;\n            dights++;\n        }\n        if(dights % 2)\n            return false;\n        else\n            return true;\n    }\n    int findNumbers(vector&lt;int&gt;&amp; nums) {\n        int ans = 0;\n        for(auto i : nums) {\n            if(checkEvenDights(i))\n                ans++;\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt;  Find Numbers with Even Number of Digits\n\nclass Solution {\npublic:\n    bool checkEvenDights(int n) {\n        int dights = 0;\n        while(n != 0) {\n            n /= 10;\n            dights++;\n        }\n        if(dights % 2)\n            return false;\n        else\n            return true;\n    }\n    int findNumbers(vector&lt;int&gt;&amp; nums) {\n        int ans = 0;\n        for(auto i : nums) {\n            if(checkEvenDights(i))\n                ans++;\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/01/18/Find-Numbers-with-Even-Number-of-Digits/"
      },
    
      {
        "title": "Convert Binary Number in a Linked List to Integer",
        "excerpt": "&lt;-E&gt;  Convert Binary Number in a Linked List to Integer\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        int ans = 0;\n        while(head != NULL) {\n            ans = ans * 2 + head-&gt;val;\n            head = head-&gt;next;\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt;  Convert Binary Number in a Linked List to Integer\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        int ans = 0;\n        while(head != NULL) {\n            ans = ans * 2 + head-&gt;val;\n            head = head-&gt;next;\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/01/19/Convert-Binary-Number-in-a-Linked-List-to-Integer/"
      },
    
      {
        "title": "Element Appearing More Than 25% In Sorted Array",
        "excerpt": "&lt;-E&gt;  Element Appearing More Than 25% In Sorted Array\n\nclass Solution {\npublic:\n    \n    int findSpecialInteger(vector&lt;int&gt;&amp; arr) {\n        int count = arr.size()  / 4;\n        int temp = arr[0];\n        int index = 0;\n        for(int i = 1; i &lt; arr.size(); i++) {\n            index++;\n            if(arr[i] != temp) {\n                temp = arr[i];\n                index = 0;\n            }\n            if(index &gt;= count)\n                return arr[i];\n        }\n        return arr[0];\n    }\n};\n\n\n",
        "content": "&lt;-E&gt;  Element Appearing More Than 25% In Sorted Array\n\nclass Solution {\npublic:\n    \n    int findSpecialInteger(vector&lt;int&gt;&amp; arr) {\n        int count = arr.size()  / 4;\n        int temp = arr[0];\n        int index = 0;\n        for(int i = 1; i &lt; arr.size(); i++) {\n            index++;\n            if(arr[i] != temp) {\n                temp = arr[i];\n                index = 0;\n            }\n            if(index &gt;= count)\n                return arr[i];\n        }\n        return arr[0];\n    }\n};\n\n\n",
        "url": "/2020/01/20/Element-Appearing-More-Than-25-In-Sorted-Array/"
      },
    
      {
        "title": "Jewels and Stones",
        "excerpt": "&lt;-E&gt;  Jewels and Stones\n\n// 1\nclass Solution {\npublic:\n    int numJewelsInStones(string J, string S) {\n        int ans = 0;\n        for (auto i : S) {\n            if (find(J.begin(), J.end(), i) != J.end())\n                ans++;\n        }\n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n  int numJewelsInStones(string J, string S) {\n        int check[128] = {0};\n        for (int i = 0; i != S.size(); i++) {\n            check[S[i]]++;\n        }\n        \n        for (int i = 0; i != J.size(); i++) {\n            check[J[i]] = -check[J[i]];\n        }\n        int ans = 0;\n        for (int i = 0; i != 128; i++) {\n            if (check[i] &lt; 0)\n                ans = ans - check[i];\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt;  Jewels and Stones\n\n// 1\nclass Solution {\npublic:\n    int numJewelsInStones(string J, string S) {\n        int ans = 0;\n        for (auto i : S) {\n            if (find(J.begin(), J.end(), i) != J.end())\n                ans++;\n        }\n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n  int numJewelsInStones(string J, string S) {\n        int check[128] = {0};\n        for (int i = 0; i != S.size(); i++) {\n            check[S[i]]++;\n        }\n        \n        for (int i = 0; i != J.size(); i++) {\n            check[J[i]] = -check[J[i]];\n        }\n        int ans = 0;\n        for (int i = 0; i != 128; i++) {\n            if (check[i] &lt; 0)\n                ans = ans - check[i];\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/01/21/Jewels-and-Stones/"
      },
    
      {
        "title": "Find Winner on a Tic Tac Toe Game",
        "excerpt": "&lt;-E&gt;  Find Winner on a Tic Tac Toe Game\n\nclass Solution {\npublic:\n    string tictactoe(vector&lt;vector&lt;int&gt;&gt;&amp; moves) {\n        vector&lt;int&gt; aRow(3);\n        vector&lt;int&gt; bRow(3);\n        vector&lt;int&gt; aCol(3);\n        vector&lt;int&gt; bCol(3);\n        int aIndex_1 = 0;\n        int aIndex_2 = 0;\n        int bIndex_1 = 0;\n        int bIndex_2 = 0;\n        for (int i = 0; i &lt; moves.size(); i++) {\n            int x = moves[i][0];\n            int y = moves[i][1];   \n            if (i % 2) {\n                if (++aRow[x] == 3 || ++aCol[y] == 3 || (x == y &amp;&amp; ++aIndex_1 == 3) || (x + y == 2 &amp;&amp; ++aIndex_2 == 3))\n                    return \"B\";\n            }\n            else {\n                if (++bRow[x] == 3 || ++bCol[y] == 3 || (x == y &amp;&amp; ++bIndex_1 == 3) || (x + y == 2 &amp;&amp; ++bIndex_2 == 3))\n                    return \"A\";\n            }\n        }     \n        if (moves.size() == 9)\n            return \"Draw\";\n        else\n            return \"Pending\";\n    }\n};\n\n\n",
        "content": "&lt;-E&gt;  Find Winner on a Tic Tac Toe Game\n\nclass Solution {\npublic:\n    string tictactoe(vector&lt;vector&lt;int&gt;&gt;&amp; moves) {\n        vector&lt;int&gt; aRow(3);\n        vector&lt;int&gt; bRow(3);\n        vector&lt;int&gt; aCol(3);\n        vector&lt;int&gt; bCol(3);\n        int aIndex_1 = 0;\n        int aIndex_2 = 0;\n        int bIndex_1 = 0;\n        int bIndex_2 = 0;\n        for (int i = 0; i &lt; moves.size(); i++) {\n            int x = moves[i][0];\n            int y = moves[i][1];   \n            if (i % 2) {\n                if (++aRow[x] == 3 || ++aCol[y] == 3 || (x == y &amp;&amp; ++aIndex_1 == 3) || (x + y == 2 &amp;&amp; ++aIndex_2 == 3))\n                    return \"B\";\n            }\n            else {\n                if (++bRow[x] == 3 || ++bCol[y] == 3 || (x == y &amp;&amp; ++bIndex_1 == 3) || (x + y == 2 &amp;&amp; ++bIndex_2 == 3))\n                    return \"A\";\n            }\n        }     \n        if (moves.size() == 9)\n            return \"Draw\";\n        else\n            return \"Pending\";\n    }\n};\n\n\n",
        "url": "/2020/01/22/Find-Winner-on-a-Tic-Tac-Toe-Game/"
      },
    
      {
        "title": "Minimum Time Visiting All Points",
        "excerpt": "&lt;-E&gt; Minimum Time Visiting All Points\n\nclass Solution {\npublic:\n\n        int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n            int ans = 0;\n            for (int i = 1; i &lt; points.size(); i++) {\n                int x = points[i][0] - points[i - 1][0];\n                int y = points[i][1] - points[i - 1][1];\n                \n                if(x &lt; 0) x *= -1;\n                if(y &lt; 0) y *= -1;\n                \n                if(x == y) \n                    ans += x;\n                else\n                    ans += max(x,y);\n            }\n            return ans;\n        }\n};\n\n\n",
        "content": "&lt;-E&gt; Minimum Time Visiting All Points\n\nclass Solution {\npublic:\n\n        int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n            int ans = 0;\n            for (int i = 1; i &lt; points.size(); i++) {\n                int x = points[i][0] - points[i - 1][0];\n                int y = points[i][1] - points[i - 1][1];\n                \n                if(x &lt; 0) x *= -1;\n                if(y &lt; 0) y *= -1;\n                \n                if(x == y) \n                    ans += x;\n                else\n                    ans += max(x,y);\n            }\n            return ans;\n        }\n};\n\n\n",
        "url": "/2020/01/23/Minimum-Time-Visiting-All-Points/"
      },
    
      {
        "title": "Shift 2D Grid",
        "excerpt": "&lt;-E&gt; Shift 2D Grid\n\n// 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n       int row = grid.size();\n        int col = grid[0].size();\n        int n = row * col;\n        vector&lt;vector&lt;int&gt;&gt; ans = grid;\n        for(int i = 0; i &lt; n; i++) {\n            int j = (i + k) % n;\n            int ri = i / col;\n            int ci = i % col;\n            int rj = j / col;\n            int cj = j % col;\n            ans[rj][cj] = grid[ri][ci];\n        }\n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n       int row = grid.size();\n        int col = grid[0].size();\n        int n = row * col;\n        vector&lt;vector&lt;int&gt;&gt; ans = grid;\n        vector&lt;int&gt; tempArray;\n        for(auto i : grid)\n            for(auto j : i)\n                tempArray.push_back(j);\n        \n        for(int i = 0; i != k; i++) {\n            \n            tempArray.insert(tempArray.begin(), tempArray[n - 1]);\n            tempArray.pop_back();\n        }\n        \n        int index = 0;\n        for(int i = 0; i &lt; row; i++) {\n            for(int j = 0; j &lt; col; j++) {\n                ans[i][j] = tempArray[index];\n                index++;\n            }          \n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Shift 2D Grid\n\n// 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n       int row = grid.size();\n        int col = grid[0].size();\n        int n = row * col;\n        vector&lt;vector&lt;int&gt;&gt; ans = grid;\n        for(int i = 0; i &lt; n; i++) {\n            int j = (i + k) % n;\n            int ri = i / col;\n            int ci = i % col;\n            int rj = j / col;\n            int cj = j % col;\n            ans[rj][cj] = grid[ri][ci];\n        }\n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n       int row = grid.size();\n        int col = grid[0].size();\n        int n = row * col;\n        vector&lt;vector&lt;int&gt;&gt; ans = grid;\n        vector&lt;int&gt; tempArray;\n        for(auto i : grid)\n            for(auto j : i)\n                tempArray.push_back(j);\n        \n        for(int i = 0; i != k; i++) {\n            \n            tempArray.insert(tempArray.begin(), tempArray[n - 1]);\n            tempArray.pop_back();\n        }\n        \n        int index = 0;\n        for(int i = 0; i &lt; row; i++) {\n            for(int j = 0; j &lt; col; j++) {\n                ans[i][j] = tempArray[index];\n                index++;\n            }          \n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/01/24/Shift-2D-Grid/"
      },
    
      {
        "title": "Check If It Is a Straight Line",
        "excerpt": "&lt;-E&gt; Check If It Is a Straight Line\n\nclass Solution {\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) {\n        bool temp = true;\n        \n        int a = coordinates[1][0] - coordinates[0][0];\n        int b = coordinates[1][1] - coordinates[0][1];\n        \n        for(int i = 2; i &lt; coordinates.size(); i++) {\n            int x = coordinates[i][0] - coordinates[0][0];\n            int y = coordinates[i][1] - coordinates[0][1];\n            if(a * y != x * b) \n                return false;\n        }            \n       return true;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Check If It Is a Straight Line\n\nclass Solution {\npublic:\n    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) {\n        bool temp = true;\n        \n        int a = coordinates[1][0] - coordinates[0][0];\n        int b = coordinates[1][1] - coordinates[0][1];\n        \n        for(int i = 2; i &lt; coordinates.size(); i++) {\n            int x = coordinates[i][0] - coordinates[0][0];\n            int y = coordinates[i][1] - coordinates[0][1];\n            if(a * y != x * b) \n                return false;\n        }            \n       return true;\n    }\n};\n\n\n",
        "url": "/2020/01/25/Check-If-It-Is-a-Straight-Line/"
      },
    
      {
        "title": "Maximum 69 Number",
        "excerpt": "&lt;-E&gt; Maximum 69 Number\n\nclass Solution {\npublic:\n    \n    int maximum69Number (int num) {\n        int ans = 0;\n        vector&lt;int&gt; temp;\n        while(num != 0) {\n            temp.push_back(num % 10);\n             num /= 10;\n        }\n        \n        for (int i = temp.size() - 1;  i &gt;= 0; i--) {\n            if (temp[i] == 6) {\n                temp[i] = 9;\n                break;\n            }\n        }\n        for (int i = temp.size() - 1; i &gt;= 0; i--) {\n            ans = ans * 10 + temp[i];\n        }\n        \n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n\n    int maximum69Number (int num) {\n        string temp = to_string(num);\n        for(int i = 0; i != temp.size(); i++)\n            if(temp[i] == '6') {\n                temp[i] = '9';\n                break;\n            }\n        int ans = 0;\n        for(int i = 0; i != temp.size(); i++)\n            ans =  ans * 10  + (temp[i]  - '0');\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Maximum 69 Number\n\nclass Solution {\npublic:\n    \n    int maximum69Number (int num) {\n        int ans = 0;\n        vector&lt;int&gt; temp;\n        while(num != 0) {\n            temp.push_back(num % 10);\n             num /= 10;\n        }\n        \n        for (int i = temp.size() - 1;  i &gt;= 0; i--) {\n            if (temp[i] == 6) {\n                temp[i] = 9;\n                break;\n            }\n        }\n        for (int i = temp.size() - 1; i &gt;= 0; i--) {\n            ans = ans * 10 + temp[i];\n        }\n        \n        return ans;\n    }\n};\n\n// 2\nclass Solution {\npublic:\n\n    int maximum69Number (int num) {\n        string temp = to_string(num);\n        for(int i = 0; i != temp.size(); i++)\n            if(temp[i] == '6') {\n                temp[i] = '9';\n                break;\n            }\n        int ans = 0;\n        for(int i = 0; i != temp.size(); i++)\n            ans =  ans * 10  + (temp[i]  - '0');\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/01/26/Maximum-69-Number/"
      },
    
      {
        "title": "Cells with Odd Values in a Matrix",
        "excerpt": "&lt;-E&gt; Cells with Odd Values in a Matrix\n\nclass Solution {\npublic:\n    int oddCells(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; indices) {\n        int rowValue, colValue;\n        int a = 1;\n        int b = 1;\n        for(int i = 1; i != indices.size(); i++) {\n            rowValue = colValue = 0;\n            for(int j = i ; j &gt;= 0; j--) {\n                if(indices[i][0] == indices[j][0])\n                    rowValue++;\n                if(indices[i][1] == indices[j][1])\n                    colValue++;\n            }\n            if(rowValue % 2)\n                a++;\n            else\n                a--;\n            if(colValue % 2)\n                b++;\n            else\n                b--;\n        }\n        return a * m + b * n - 2 * a * b;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Cells with Odd Values in a Matrix\n\nclass Solution {\npublic:\n    int oddCells(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; indices) {\n        int rowValue, colValue;\n        int a = 1;\n        int b = 1;\n        for(int i = 1; i != indices.size(); i++) {\n            rowValue = colValue = 0;\n            for(int j = i ; j &gt;= 0; j--) {\n                if(indices[i][0] == indices[j][0])\n                    rowValue++;\n                if(indices[i][1] == indices[j][1])\n                    colValue++;\n            }\n            if(rowValue % 2)\n                a++;\n            else\n                a--;\n            if(colValue % 2)\n                b++;\n            else\n                b--;\n        }\n        return a * m + b * n - 2 * a * b;\n    }\n};\n\n\n",
        "url": "/2020/01/27/Cells-with-Odd-Values-in-a-Matrix/"
      },
    
      {
        "title": "Split a String in Balanced Strings",
        "excerpt": "&lt;-E&gt; Split a String in Balanced Strings\n\nclass Solution {\npublic:\n    int balancedStringSplit(string s) {\n        int index = 1;\n        int ans = 0;\n        char temp = s[0];\n        for(int i = 1; i &lt; s.size(); i++) {\n            if(s[i] != temp) {\n                index--;\n            }\n            else\n                index++;\n            if(index == 0) {\n                ans++;\n                temp = s[i + 1];\n                index = 1;\n                i++;\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Split a String in Balanced Strings\n\nclass Solution {\npublic:\n    int balancedStringSplit(string s) {\n        int index = 1;\n        int ans = 0;\n        char temp = s[0];\n        for(int i = 1; i &lt; s.size(); i++) {\n            if(s[i] != temp) {\n                index--;\n            }\n            else\n                index++;\n            if(index == 0) {\n                ans++;\n                temp = s[i + 1];\n                index = 1;\n                i++;\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/01/28/Split-a-String-in-Balanced-Strings/"
      },
    
      {
        "title": "Play with Chips",
        "excerpt": "&lt;-E&gt; Play with Chips\n\nclass Solution {\npublic:\n    int minCostToMoveChips(vector&lt;int&gt;&amp; chips) {\n        int temp[2] = {0};\n        for(int a : chips){\n            temp[a%2]++;\n        }\n        return min(temp[0], temp[1]);\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Play with Chips\n\nclass Solution {\npublic:\n    int minCostToMoveChips(vector&lt;int&gt;&amp; chips) {\n        int temp[2] = {0};\n        for(int a : chips){\n            temp[a%2]++;\n        }\n        return min(temp[0], temp[1]);\n    }\n};\n\n\n",
        "url": "/2020/01/29/Play-with-Chips/"
      },
    
      {
        "title": "Unique Number of Occurrences",
        "excerpt": "&lt;-E&gt;  Unique Number of Occurrences\n\nclass Solution {\npublic:\n    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {\n        int temp[2000] = {0};\n        for(int i = 0; i &lt; arr.size(); i++) {\n            temp[arr[i] + 1000]++;\n        }\n        \n        for(int i = 0; i &lt; 2000; i++) {\n            if(temp[i] != 0)\n                for(int j = i + 1; j &lt; 2000; j++) {\n                    if(temp[j] != 0)\n                        if(temp[i] == temp[j])\n                            return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt;  Unique Number of Occurrences\n\nclass Solution {\npublic:\n    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) {\n        int temp[2000] = {0};\n        for(int i = 0; i &lt; arr.size(); i++) {\n            temp[arr[i] + 1000]++;\n        }\n        \n        for(int i = 0; i &lt; 2000; i++) {\n            if(temp[i] != 0)\n                for(int j = i + 1; j &lt; 2000; j++) {\n                    if(temp[j] != 0)\n                        if(temp[i] == temp[j])\n                            return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2020/02/01/Unique-Number-of-Occurrences/"
      },
    
      {
        "title": "新年新计划",
        "excerpt": "2020年 02 月 09 日更新\n\n已看\n\n读书程度超过70%, 但是还需要看英文原版, 并整理笔记的. 标注 完 的不需要整理笔记和再看英文原版.\n\nC\n\n算法精解C语言版\n\n有遗忘\n\n(完)C语言程序设计\n\n完\n\n(完)C prime plus 5th edition\n\n完\n\n数据结构和算法分析 C\n\n有遗忘, 存在不懂的地方, 对树和图的代码还不能自己实现\n\nC++\n\nThink in C++\n\n有遗忘\n\nC++程序设计\n\n有遗忘\n\n数据结构和算法分析 C++\n\n有遗忘, 存在不懂的地方, 对树和图的代码还不能自己实现\n\nC++ prime\n\n有遗忘\n\nJAVA\n\n算法\n\n不懂的地方还有很多, 最后一章没有完成\n\nPYTHON\n\n(完)python 基础教程\n\npython2 的教学书, 有遗忘, 不准备继续看\n\nEnglish\n\n(完)English Grammar in use (middle)\n\n完, 还需要相对应的整理笔记\n",
        "content": "2020年 02 月 09 日更新\n\n已看\n\n读书程度超过70%, 但是还需要看英文原版, 并整理笔记的. 标注 完 的不需要整理笔记和再看英文原版.\n\nC\n\n算法精解C语言版\n\n有遗忘\n\n(完)C语言程序设计\n\n完\n\n(完)C prime plus 5th edition\n\n完\n\n数据结构和算法分析 C\n\n有遗忘, 存在不懂的地方, 对树和图的代码还不能自己实现\n\nC++\n\nThink in C++\n\n有遗忘\n\nC++程序设计\n\n有遗忘\n\n数据结构和算法分析 C++\n\n有遗忘, 存在不懂的地方, 对树和图的代码还不能自己实现\n\nC++ prime\n\n有遗忘\n\nJAVA\n\n算法\n\n不懂的地方还有很多, 最后一章没有完成\n\nPYTHON\n\n(完)python 基础教程\n\npython2 的教学书, 有遗忘, 不准备继续看\n\nEnglish\n\n(完)English Grammar in use (middle)\n\n完, 还需要相对应的整理笔记\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2020/02/01/%E6%96%B0%E5%B9%B4%E6%96%B0%E8%AE%A1%E5%88%92/"
      },
    
      {
        "title": "Minimum Absolute Difference",
        "excerpt": "&lt;-E&gt; Minimum Absolute Difference\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) {\n        sort(arr.begin(), arr.end());\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        int temp = arr[1] - arr[0];\n        for(int i = 1; i &lt; arr.size(); i++) {\n            int n = abs(arr[i] - arr[i - 1]);\n            if(n &lt; temp) {\n                ans.clear();\n                temp = n;\n                ans.push_back({arr[i - 1], arr[i]});\n            }\n            else if(n == temp)\n                ans.push_back({arr[i - 1], arr[i]});\n                \n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Minimum Absolute Difference\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) {\n        sort(arr.begin(), arr.end());\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        int temp = arr[1] - arr[0];\n        for(int i = 1; i &lt; arr.size(); i++) {\n            int n = abs(arr[i] - arr[i - 1]);\n            if(n &lt; temp) {\n                ans.clear();\n                temp = n;\n                ans.push_back({arr[i - 1], arr[i]});\n            }\n            else if(n == temp)\n                ans.push_back({arr[i - 1], arr[i]});\n                \n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/02/02/Minimum-Absolute-Difference/"
      },
    
      {
        "title": "Maximum Number of Balloons",
        "excerpt": "&lt;-E&gt; Maximum Number of Balloons\n\nclass Solution {\npublic:       \n    int maxNumberOfBalloons(string text) {\n        int temp[5] = {0};\n        \n        for(int i = 0; i &lt; text.size(); i++) {\n            if(text[i] == 'a')\n                temp[0]++;\n            else if(text[i] == 'b')\n                temp[1]++;\n            else if(text[i] == 'l')\n                temp[2]++;\n            else if(text[i] == 'o')\n                temp[3]++;\n            else if(text[i] == 'n')\n                temp[4]++;\n        }\n        temp[2] /= 2;\n        temp[3] /= 2;\n\n        int ans = temp[0];\n        for(int i= 0; i &lt; 5; i++ )\n            if(ans &gt; temp[i]) {\n                ans = temp[i];\n            }    \n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Maximum Number of Balloons\n\nclass Solution {\npublic:       \n    int maxNumberOfBalloons(string text) {\n        int temp[5] = {0};\n        \n        for(int i = 0; i &lt; text.size(); i++) {\n            if(text[i] == 'a')\n                temp[0]++;\n            else if(text[i] == 'b')\n                temp[1]++;\n            else if(text[i] == 'l')\n                temp[2]++;\n            else if(text[i] == 'o')\n                temp[3]++;\n            else if(text[i] == 'n')\n                temp[4]++;\n        }\n        temp[2] /= 2;\n        temp[3] /= 2;\n\n        int ans = temp[0];\n        for(int i= 0; i &lt; 5; i++ )\n            if(ans &gt; temp[i]) {\n                ans = temp[i];\n            }    \n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/02/03/Maximum-Number-of-Balloons/"
      },
    
      {
        "title": "Valid Parentheses",
        "excerpt": "&lt;-E&gt; Valid Parentheses\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        if (s.size() % 2)\n            return false;\n    \n        stack&lt;char&gt; st;\n        for (auto i = s.begin(); i != s.end(); i++) {\n            if (s.empty() &amp;&amp; (*i == ')' || *i == ']' || *i == '}')) {\n                return false;\n            }\n            if (!st.empty() &amp;&amp; (st.top() == '(' &amp;&amp; (*i == ']' || *i == '}'))) {\n                return false;\n            }\n            if (!st.empty() &amp;&amp; (st.top() == '[' &amp;&amp; (*i == ')' || *i == '}'))) {\n                return false;\n            }\n\n            if (!st.empty() &amp;&amp; (st.top() == '{' &amp;&amp; (*i == ')' || *i == ']'))) {\n                return false;\n            }\n\n            if (st.empty()) {\n                st.push(*i);\n                continue;\n            }\n            if ((st.top() == '(' &amp;&amp; *i == ')') || (st.top() == '[' &amp;&amp; *i == ']') || (st.top() == '{' &amp;&amp; *i == '}')) {\n                st.pop();\n                continue;\n            }\n            st.push(*i);\n        }\n\n        return st.empty();\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Valid Parentheses\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        if (s.size() % 2)\n            return false;\n    \n        stack&lt;char&gt; st;\n        for (auto i = s.begin(); i != s.end(); i++) {\n            if (s.empty() &amp;&amp; (*i == ')' || *i == ']' || *i == '}')) {\n                return false;\n            }\n            if (!st.empty() &amp;&amp; (st.top() == '(' &amp;&amp; (*i == ']' || *i == '}'))) {\n                return false;\n            }\n            if (!st.empty() &amp;&amp; (st.top() == '[' &amp;&amp; (*i == ')' || *i == '}'))) {\n                return false;\n            }\n\n            if (!st.empty() &amp;&amp; (st.top() == '{' &amp;&amp; (*i == ')' || *i == ']'))) {\n                return false;\n            }\n\n            if (st.empty()) {\n                st.push(*i);\n                continue;\n            }\n            if ((st.top() == '(' &amp;&amp; *i == ')') || (st.top() == '[' &amp;&amp; *i == ']') || (st.top() == '{' &amp;&amp; *i == '}')) {\n                st.pop();\n                continue;\n            }\n            st.push(*i);\n        }\n\n        return st.empty();\n    }\n};\n\n\n",
        "url": "/2020/02/04/Valid-Parentheses/"
      },
    
      {
        "title": "Remove Duplicates from Sorted Array",
        "excerpt": "&lt;-E&gt; Remove Duplicates from Sorted Array\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() == 0) return 0;\n        int index = 1;\n        int check = nums[0];\n        int set = 0;\n        for(int i = 1; i != nums.size(); i++) {\n            if(nums[i] != check) {\n                check = nums[i];\n                index++; \n                set ++;\n                nums[set] = nums[i];\n            }\n            \n            \n        }\n        return index;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Remove Duplicates from Sorted Array\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() == 0) return 0;\n        int index = 1;\n        int check = nums[0];\n        int set = 0;\n        for(int i = 1; i != nums.size(); i++) {\n            if(nums[i] != check) {\n                check = nums[i];\n                index++; \n                set ++;\n                nums[set] = nums[i];\n            }\n            \n            \n        }\n        return index;\n    }\n};\n\n\n",
        "url": "/2020/02/05/Remove-Duplicates-from-Sorted-Array/"
      },
    
      {
        "title": "Lucky Numbers in a Matrix",
        "excerpt": "&lt;-E&gt; Lucky Numbers in a Matrix\n\nclass Solution {\npublic:\n    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        vector&lt;int&gt; temp_min;\n        vector&lt;int&gt; temp_max;\n        vector&lt;int&gt; ans;\n        \n        for(int i = 0; i != matrix.size(); i++) {\n            int check_min = matrix[i][0];\n           for(int j = 0; j != matrix[0].size(); j++) {\n              if(check_min &gt; matrix[i][j])\n                  check_min = matrix[i][j];\n           }\n            temp_min.push_back(check_min);\n        }\n        for(int i = 0; i != matrix[0].size(); i++) {\n            int check_max = matrix[0][i];\n           for(int j = 0; j != matrix.size(); j++) {\n              if(check_max &lt; matrix[j][i])\n                  check_max = matrix[j][i];\n           }\n            temp_max.push_back(check_max);\n        }\n       \n        for(int i = 0; i != temp_min.size(); i++) {\n            if(find(temp_max.begin(), temp_max.end(), temp_min[i]) != temp_max.end())\n                ans.push_back(temp_min[i]);\n        }\n        \n        return ans;\n    }\n};\n\n// 解法2\nclass Solution {\npublic:\n    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        \n        vector&lt;int&gt; ans;\n        \n        int liRow = -1;\n        int liCol = -1;\n        \n        for( int i = 0; i &lt; matrix.size(); ++i ) {\n            int col = 0;\n            for( int j = 1; j &lt; matrix[i].size(); ++j ) {\n                if ( matrix[i][j] &lt; matrix[i][col])\n                    col = j;\n            }\n            \n            if ( liRow == -1 || matrix[liRow][liCol] &lt; matrix[i][col]) {\n                liRow = i;\n                liCol = col;\n            }\n        }\n        \n        for( int i = 0; i &lt; matrix.size(); ++i ) {\n            if ( matrix[i][liCol] &gt; matrix[liRow][liCol])\n                return ans;\n        }\n        ans.push_back(matrix[liRow][liCol]);\n        return  ans;\n        \n        \n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Lucky Numbers in a Matrix\n\nclass Solution {\npublic:\n    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        vector&lt;int&gt; temp_min;\n        vector&lt;int&gt; temp_max;\n        vector&lt;int&gt; ans;\n        \n        for(int i = 0; i != matrix.size(); i++) {\n            int check_min = matrix[i][0];\n           for(int j = 0; j != matrix[0].size(); j++) {\n              if(check_min &gt; matrix[i][j])\n                  check_min = matrix[i][j];\n           }\n            temp_min.push_back(check_min);\n        }\n        for(int i = 0; i != matrix[0].size(); i++) {\n            int check_max = matrix[0][i];\n           for(int j = 0; j != matrix.size(); j++) {\n              if(check_max &lt; matrix[j][i])\n                  check_max = matrix[j][i];\n           }\n            temp_max.push_back(check_max);\n        }\n       \n        for(int i = 0; i != temp_min.size(); i++) {\n            if(find(temp_max.begin(), temp_max.end(), temp_min[i]) != temp_max.end())\n                ans.push_back(temp_min[i]);\n        }\n        \n        return ans;\n    }\n};\n\n// 解法2\nclass Solution {\npublic:\n    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        \n        vector&lt;int&gt; ans;\n        \n        int liRow = -1;\n        int liCol = -1;\n        \n        for( int i = 0; i &lt; matrix.size(); ++i ) {\n            int col = 0;\n            for( int j = 1; j &lt; matrix[i].size(); ++j ) {\n                if ( matrix[i][j] &lt; matrix[i][col])\n                    col = j;\n            }\n            \n            if ( liRow == -1 || matrix[liRow][liCol] &lt; matrix[i][col]) {\n                liRow = i;\n                liCol = col;\n            }\n        }\n        \n        for( int i = 0; i &lt; matrix.size(); ++i ) {\n            if ( matrix[i][liCol] &gt; matrix[liRow][liCol])\n                return ans;\n        }\n        ans.push_back(matrix[liRow][liCol]);\n        return  ans;\n        \n        \n    }\n};\n\n\n",
        "url": "/2020/02/06/Lucky-Numbers-in-a-Matrix/"
      },
    
      {
        "title": "Non-decreasing Array",
        "excerpt": "&lt;-E&gt; Non-decreasing Array\n\nclass Solution {\npublic:\n\tbool checkPossibility(vector&lt;int&gt;&amp; nums) {\n\t\tint cnt=0;\n\t\tfor(int i=1;i&lt;nums.size();i++){\n\t\t\tif(nums[i]&lt;nums[i-1]){\n\t\t\t\tcnt++;\n\t\t\t\tif(i-2 &gt;= 0 &amp;&amp; nums[i-2]&gt;nums[i]){\n\t\t\t\t\tnums[i]=nums[i-1];\n\t\t\t\t}\n\t\t\t\tif(cnt==2) break;\n\t\t\t}\n\t\t}\n\t\treturn cnt&lt;2;\n\n\t}\n};\n\n\n",
        "content": "&lt;-E&gt; Non-decreasing Array\n\nclass Solution {\npublic:\n\tbool checkPossibility(vector&lt;int&gt;&amp; nums) {\n\t\tint cnt=0;\n\t\tfor(int i=1;i&lt;nums.size();i++){\n\t\t\tif(nums[i]&lt;nums[i-1]){\n\t\t\t\tcnt++;\n\t\t\t\tif(i-2 &gt;= 0 &amp;&amp; nums[i-2]&gt;nums[i]){\n\t\t\t\t\tnums[i]=nums[i-1];\n\t\t\t\t}\n\t\t\t\tif(cnt==2) break;\n\t\t\t}\n\t\t}\n\t\treturn cnt&lt;2;\n\n\t}\n};\n\n\n",
        "url": "/2020/02/07/Non-decreasing-Array/"
      },
    
      {
        "title": "Defanging an IP Address",
        "excerpt": "&lt;-E&gt; Defanging an IP Address\n\nclass Solution {\npublic:\n    string defangIPaddr(string address) {\n        string ans = \"\";\n        \n        for(auto i : address) \n            ans = ((i == '.') ? ans + \"[.]\": ans + i);\n        return ans;\n    }\n    \n};\n\n\n",
        "content": "&lt;-E&gt; Defanging an IP Address\n\nclass Solution {\npublic:\n    string defangIPaddr(string address) {\n        string ans = \"\";\n        \n        for(auto i : address) \n            ans = ((i == '.') ? ans + \"[.]\": ans + i);\n        return ans;\n    }\n    \n};\n\n\n",
        "url": "/2020/02/08/Defanging-an-IP-Address/"
      },
    
      {
        "title": "Number of Steps to Reduce a Number to Zero",
        "excerpt": "&lt;-E&gt; Number of Steps to Reduce a Number to Zero\n\nclass Solution {\npublic:\n    int numberOfSteps (int num) {\n        int i = 0;\n        while(num != 0) {\n            if(num % 2) \n                num -= 1;\n            else\n                num /= 2;\n            i++;\n        }\n        return i;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Number of Steps to Reduce a Number to Zero\n\nclass Solution {\npublic:\n    int numberOfSteps (int num) {\n        int i = 0;\n        while(num != 0) {\n            if(num % 2) \n                num -= 1;\n            else\n                num /= 2;\n            i++;\n        }\n        return i;\n    }\n};\n\n\n",
        "url": "/2020/02/09/Number-of-Steps-to-Reduce-a-Number-to-Zero/"
      },
    
      {
        "title": "How Many Numbers Are Smaller Than the Current Number",
        "excerpt": "&lt;-E&gt; How Many Numbers Are Smaller Than the Current Number\n\nclass Solution {\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) {\n        int bucket[101] = {0};\n        for(auto i : nums)\n            bucket[i]++;\n        int index = 0;\n        for(int i = 0; i != 101; i++) {\n            if(bucket[i] != 0) {\n                if(bucket[i] == 1) {\n                    bucket[i] = index;\n                    index++;\n                }\n                else {\n                    int temp = bucket[i];\n                    bucket[i] = index;\n                    index += temp;\n                }\n            }\n        }\n        vector&lt;int&gt; ans(0, nums.size());\n        for(auto i : nums) {\n            ans.push_back(bucket[i]);\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; How Many Numbers Are Smaller Than the Current Number\n\nclass Solution {\npublic:\n    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) {\n        int bucket[101] = {0};\n        for(auto i : nums)\n            bucket[i]++;\n        int index = 0;\n        for(int i = 0; i != 101; i++) {\n            if(bucket[i] != 0) {\n                if(bucket[i] == 1) {\n                    bucket[i] = index;\n                    index++;\n                }\n                else {\n                    int temp = bucket[i];\n                    bucket[i] = index;\n                    index += temp;\n                }\n            }\n        }\n        vector&lt;int&gt; ans(0, nums.size());\n        for(auto i : nums) {\n            ans.push_back(bucket[i]);\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/02/10/How-Many-Numbers-Are-Smaller-Than-the-Current-Number/"
      },
    
      {
        "title": "Create Target Array in the Given Order",
        "excerpt": "&lt;-E&gt; Create Target Array in the Given Order\n\nclass Solution {\npublic:\n    vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != nums.size(); i++) \n            ans.insert(ans.begin() + index[i], nums[i]);\n        return ans;\n    }\n    \n};\n\n\n",
        "content": "&lt;-E&gt; Create Target Array in the Given Order\n\nclass Solution {\npublic:\n    vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != nums.size(); i++) \n            ans.insert(ans.begin() + index[i], nums[i]);\n        return ans;\n    }\n    \n};\n\n\n",
        "url": "/2020/02/11/Create-Target-Array-in-the-Given-Order/"
      },
    
      {
        "title": "To Lower Case",
        "excerpt": "&lt;-E&gt; To Lower Case\n\nclass Solution {\npublic:\n    string toLowerCase(string str) {\n        for(auto &amp;i: str) {\n            if(i &gt;= 'A' &amp;&amp; i &lt;= 'Z')\n                i = i + 32;\n        }\n        return str;\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; To Lower Case\n\nclass Solution {\npublic:\n    string toLowerCase(string str) {\n        for(auto &amp;i: str) {\n            if(i &gt;= 'A' &amp;&amp; i &lt;= 'Z')\n                i = i + 32;\n        }\n        return str;\n    }\n};\n\n\n",
        "url": "/2020/02/12/To-Lower-Case/"
      },
    
      {
        "title": "C++复习笔记",
        "excerpt": "2020年 02 月 26 日更新\n\n变量初始化\n\n函数体之外的变量都被初始化为 0\n函数体内部的变量都不会被初始化\n\n\n  直接初始化  没有等号\n  拷贝初始化 有等号\n\n\n引用\n\n引用一旦被初始化后, 就不能改为其他对象, (会进行赋值操作)\n\n传递引用\n\n可以阻止函数传递时, 对参数的拷贝\n\n类\n\n成员函数\n\nType A::f() const \n{}\n\n\n若将成员函数声明为const，则不允许通过其修改类的数据成员。 值得注意的是，如果类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象。\n\n设置友元类, 可以访问 私有变量\n\n构造函数初始值\n\n在构造函数中,无法忽略 初始化和赋值之间的差异\n\n\n  构造函数初始化存在顺序关系\n最好让保证于成名声明的顺序一致\n\n\nclass TestA {\npublic:\n    TestA(int ii);\nprivate:\n    int i;\n    const int ci;\n    int &amp;i;\n}\n//如使用赋值的话, 会出现错误\n/*\nTestA::TestA(int ii) {\n    i = ii;\n    ci = ii; // const 无法被赋值\n    ri = i; // ri 没有被初始化\n}\n*/\n\n// 正确的是 (构造方式)\n\nTestA::TestA(int ii):i(ii), ci(ii), ri(i) {}\n\n析构函数\n\n类中有且仅有一个析构函数\n\n类设计\n\nC++ 并不要求一定要自己定义析构函数, 拷贝构造函数, 拷贝赋值运算符, 但是这些操作应该被视为一个整体, 一般不会出现只定义某一个函数的情况\n\n错误示范\n\nclass A{\npublic:\n    A(const string &amp;s = string()):ps(new string(s)), i(0) { }\n    ~A() {delete ps;}\n    //\n};\n\nA f(A hp) {\n    A ret = hp; // 拷贝\n    return ret;  // ret 和 hp 都被销毁\n}\n\n// 如果有如下使用\nA p(\"hi\");\nf(p);         //p.ps指向的内容被释放\nA q(p);       // q, p 指向无效内存\n\n合成的xx函数\n\n\n  具有引用成员或无默认构造的const成员的类, 编译器不会为其合成默认构造函数.\n\n\n容器\n\nswap\n\n除了string外, 指向容器的迭代器,引用, 指针 不会 失效, 仍然指向之前的值.\n\n只有Array 真正交换了他们的元素.\n\nbind\n\nbind 函数拷贝其参数, 如果提供一个对象但不拷贝他, 需要使用标准库的ref函数\n\n函数\n\n尾置返回类型\n\nauto func(int i) -&gt; int(*)[10]\n\n用以简化函数的返回值\n\n迭代器\n\n普通迭代器\n\n*it;\n++it;\nit++\n\n\n不会对 迭代器 it 做任何事情, 每个操作都会返回it\n\niostream 迭代器\n\nistream_iterator\n\nistream_iterator&lt;int&gt; int_it(cin); // 从cin 读int\nistream_iterator&lt;int&gt; int_eof; // 尾后迭代器 (用来判断读取中止)\n\n\nostream_iterator\n\n    vector&lt;string&gt; test(10, \"test\");\n    // 将类型T写到cout 流中, 并且中间以---隔开\n    ostream_iterator&lt;string&gt; out_iter(cout, \"---\");\n    copy(test.begin(), test.end(), out_iter);\n    cout &lt;&lt; endl;\n\n算法中使用的迭代器错误, 可能不会被语法检查器检查出来.\n\n编程提示\n\n\n  如果两个对象共享底层的数据, 当某个对象被销毁的时候, 不能单方面的销毁底层数据\n\n\n指针\n\nstring *ps1 = new string;   // 默认初始化 空string\nstring *ps2 = new string(); // 值初始化   空string\nint *pi1 = new int;         // 默认初始化  未定义\nint *pi2 = new int();       // 值初始化  *pi2 为0\n\n\n空悬指针的问题\n\nint *p(new int(42));\nauto q = p;\ndelete p;     // p, q 均无效\np = nullptr; // q 仍然是空悬指针\n\n\n智能指针 + 动态指针\n\nshared_ptr&lt;int&gt; p1 = new int(1024); // 错误\nshared_ptr&lt;int&gt; p2(new int(1024)); // 正确\n\n\n智能指针 + 普通指针\n\nvoid process(shared_ptr&lt;int&gt; ptr) { }\nint *x(new int(1024));\nprocess(x); // 错误, 无法将int*类型转换到shared_ptr&lt;int&gt;\nprocess(shared_ptr&lt;int&gt;(x)); // 合法\nint j = *x // 未定义的, x成为空悬指针, 指向内容已经被智能指针释放\n\n\n智能指针 + 动态数组\n\nunique_ptr 管理动态数组\n\nunique_ptr&lt;int[]&gt; up(new int[10]);\nup.release(); // 自动调用delete[], 销毁其指针\n// 与普通的unique_ptr 不同\n\n\nshared_ptr 不能直接管理动态数组, 如果必须要用, 要提供自己写的删除器\n\nshared_prt&lt;int&gt; sp(new int[10], [](int *p) {delete[] p; });\nsp.reset(); // 调用lambda 释放数组\n\n\nshared_ptr 没有定义下标, 也不支持指针++\n\nnew\n\nchar arr[0]; // 非法\nchar *cp = new char[0]; // 合法但是不能被解引用\n\n\nallocator\n\n// 创建\nallocator&lt;string&gt; alloc;\nauto const p = alloc.allocate(n);  // 传递 n = 3  // string *const p\n// 赋值\nauto q = p;\nalloc.construct(q++);    //*q 为空字符串\nalloc.construct(q++, 2. 'c'); //*q 为cc\nalloc.construct(q++, \"hi\");   //*q 为hi\n// 销毁\nwhile(q != p) \n    alloc.destroy(--q);\n// 返回系统\nalloc.deallocate(p, n);\n\n\nexplicit\n\nexplicit关键字只能用于修饰 只有一个参数 的类构造函数, 它的作用是表明该构造函数是 显示 的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).\n\n",
        "content": "2020年 02 月 26 日更新\n\n变量初始化\n\n函数体之外的变量都被初始化为 0\n函数体内部的变量都不会被初始化\n\n\n  直接初始化  没有等号\n  拷贝初始化 有等号\n\n\n引用\n\n引用一旦被初始化后, 就不能改为其他对象, (会进行赋值操作)\n\n传递引用\n\n可以阻止函数传递时, 对参数的拷贝\n\n类\n\n成员函数\n\nType A::f() const \n{}\n\n\n若将成员函数声明为const，则不允许通过其修改类的数据成员。 值得注意的是，如果类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象。\n\n设置友元类, 可以访问 私有变量\n\n构造函数初始值\n\n在构造函数中,无法忽略 初始化和赋值之间的差异\n\n\n  构造函数初始化存在顺序关系\n最好让保证于成名声明的顺序一致\n\n\nclass TestA {\npublic:\n    TestA(int ii);\nprivate:\n    int i;\n    const int ci;\n    int &amp;i;\n}\n//如使用赋值的话, 会出现错误\n/*\nTestA::TestA(int ii) {\n    i = ii;\n    ci = ii; // const 无法被赋值\n    ri = i; // ri 没有被初始化\n}\n*/\n\n// 正确的是 (构造方式)\n\nTestA::TestA(int ii):i(ii), ci(ii), ri(i) {}\n\n析构函数\n\n类中有且仅有一个析构函数\n\n类设计\n\nC++ 并不要求一定要自己定义析构函数, 拷贝构造函数, 拷贝赋值运算符, 但是这些操作应该被视为一个整体, 一般不会出现只定义某一个函数的情况\n\n错误示范\n\nclass A{\npublic:\n    A(const string &amp;s = string()):ps(new string(s)), i(0) { }\n    ~A() {delete ps;}\n    //\n};\n\nA f(A hp) {\n    A ret = hp; // 拷贝\n    return ret;  // ret 和 hp 都被销毁\n}\n\n// 如果有如下使用\nA p(\"hi\");\nf(p);         //p.ps指向的内容被释放\nA q(p);       // q, p 指向无效内存\n\n合成的xx函数\n\n\n  具有引用成员或无默认构造的const成员的类, 编译器不会为其合成默认构造函数.\n\n\n容器\n\nswap\n\n除了string外, 指向容器的迭代器,引用, 指针 不会 失效, 仍然指向之前的值.\n\n只有Array 真正交换了他们的元素.\n\nbind\n\nbind 函数拷贝其参数, 如果提供一个对象但不拷贝他, 需要使用标准库的ref函数\n\n函数\n\n尾置返回类型\n\nauto func(int i) -&gt; int(*)[10]\n\n用以简化函数的返回值\n\n迭代器\n\n普通迭代器\n\n*it;\n++it;\nit++\n\n\n不会对 迭代器 it 做任何事情, 每个操作都会返回it\n\niostream 迭代器\n\nistream_iterator\n\nistream_iterator&lt;int&gt; int_it(cin); // 从cin 读int\nistream_iterator&lt;int&gt; int_eof; // 尾后迭代器 (用来判断读取中止)\n\n\nostream_iterator\n\n    vector&lt;string&gt; test(10, \"test\");\n    // 将类型T写到cout 流中, 并且中间以---隔开\n    ostream_iterator&lt;string&gt; out_iter(cout, \"---\");\n    copy(test.begin(), test.end(), out_iter);\n    cout &lt;&lt; endl;\n\n算法中使用的迭代器错误, 可能不会被语法检查器检查出来.\n\n编程提示\n\n\n  如果两个对象共享底层的数据, 当某个对象被销毁的时候, 不能单方面的销毁底层数据\n\n\n指针\n\nstring *ps1 = new string;   // 默认初始化 空string\nstring *ps2 = new string(); // 值初始化   空string\nint *pi1 = new int;         // 默认初始化  未定义\nint *pi2 = new int();       // 值初始化  *pi2 为0\n\n\n空悬指针的问题\n\nint *p(new int(42));\nauto q = p;\ndelete p;     // p, q 均无效\np = nullptr; // q 仍然是空悬指针\n\n\n智能指针 + 动态指针\n\nshared_ptr&lt;int&gt; p1 = new int(1024); // 错误\nshared_ptr&lt;int&gt; p2(new int(1024)); // 正确\n\n\n智能指针 + 普通指针\n\nvoid process(shared_ptr&lt;int&gt; ptr) { }\nint *x(new int(1024));\nprocess(x); // 错误, 无法将int*类型转换到shared_ptr&lt;int&gt;\nprocess(shared_ptr&lt;int&gt;(x)); // 合法\nint j = *x // 未定义的, x成为空悬指针, 指向内容已经被智能指针释放\n\n\n智能指针 + 动态数组\n\nunique_ptr 管理动态数组\n\nunique_ptr&lt;int[]&gt; up(new int[10]);\nup.release(); // 自动调用delete[], 销毁其指针\n// 与普通的unique_ptr 不同\n\n\nshared_ptr 不能直接管理动态数组, 如果必须要用, 要提供自己写的删除器\n\nshared_prt&lt;int&gt; sp(new int[10], [](int *p) {delete[] p; });\nsp.reset(); // 调用lambda 释放数组\n\n\nshared_ptr 没有定义下标, 也不支持指针++\n\nnew\n\nchar arr[0]; // 非法\nchar *cp = new char[0]; // 合法但是不能被解引用\n\n\nallocator\n\n// 创建\nallocator&lt;string&gt; alloc;\nauto const p = alloc.allocate(n);  // 传递 n = 3  // string *const p\n// 赋值\nauto q = p;\nalloc.construct(q++);    //*q 为空字符串\nalloc.construct(q++, 2. 'c'); //*q 为cc\nalloc.construct(q++, \"hi\");   //*q 为hi\n// 销毁\nwhile(q != p) \n    alloc.destroy(--q);\n// 返回系统\nalloc.deallocate(p, n);\n\n\nexplicit\n\nexplicit关键字只能用于修饰 只有一个参数 的类构造函数, 它的作用是表明该构造函数是 显示 的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).\n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2020/02/17/CPlus%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"
      },
    
      {
        "title": "设计模式学习笔记",
        "excerpt": "2020年03月05日更新\n\n模式分类\n\n\n  AbstractFactory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它\n们具体的类。\n  Adapter：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n  Bridge：将抽象部分与它的实现部分分离，使它们都可以独立地变化。\n  Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n  ChainofResponsibility：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。\n  Command：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。\n  Composite：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。\n  Decorator：动态地给一个对象添加一些额外的职责。就扩展功能而言,Decorator模式比生成子类方式更为灵活。\n  Facade：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n  FactoryMethod：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。FactoryMethod使一个类的实例化延迟到其子类。\n  Flyweight：运用共享技术有效地支持大量细粒度的对象。\n  Interpreter：给定一个语言,定义它的文法的一种表示，并定义一个解释器,该解释器使用该表示来解释语言中的句子。\n  Iterator：提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示。\n  Mediator：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n  Memento：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。\n  Observer：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。\n  Prototype：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。\n  Proxy：为其他对象提供一个代理以控制对这个对象的访问。\n  Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n  State：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。\n  Strategy：定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。\n  TemplateMethod：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n  Visitor：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n\n对接口编程,而不是对实现编程\n",
        "content": "2020年03月05日更新\n\n模式分类\n\n\n  AbstractFactory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它\n们具体的类。\n  Adapter：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n  Bridge：将抽象部分与它的实现部分分离，使它们都可以独立地变化。\n  Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n  ChainofResponsibility：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。\n  Command：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。\n  Composite：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。\n  Decorator：动态地给一个对象添加一些额外的职责。就扩展功能而言,Decorator模式比生成子类方式更为灵活。\n  Facade：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n  FactoryMethod：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。FactoryMethod使一个类的实例化延迟到其子类。\n  Flyweight：运用共享技术有效地支持大量细粒度的对象。\n  Interpreter：给定一个语言,定义它的文法的一种表示，并定义一个解释器,该解释器使用该表示来解释语言中的句子。\n  Iterator：提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示。\n  Mediator：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n  Memento：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。\n  Observer：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。\n  Prototype：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。\n  Proxy：为其他对象提供一个代理以控制对这个对象的访问。\n  Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n  State：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。\n  Strategy：定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。\n  TemplateMethod：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n  Visitor：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n\n对接口编程,而不是对实现编程\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2020/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
      },
    
      {
        "title": "编译原理学习笔记",
        "excerpt": "2020年03月08日更新\n\nSets\n\nG=(VT，VN，S，P)是上下文无关文法\n\nFirst sets\n\n\n  \n    若X∈VT，则FIRST(X)＝{X}。(简单讲，终结符的FIRST集就是它本身)\n  \n  \n    若X∈VN，且有产生式X→a…，a∈VT， 则 a∈FIRST(X)X→ε,则ε∈FIRST(X)。　（简单讲，若是非终结符X，能推导出以终结符a开头的串，那么这个终结符a属于FIRST（X），若X能够推导出空符号串ε，那么空符号串ε也属于X的FIRST集）\n  \n  \n    X→Y…是一个产生式且Y ∈VN  则把FIRST(Y)中的所有 非空符号串ε元素 都加入到FIRST(X)中。\n  \n  \n    若X∈VN；Y1，Y2，…，Yi∈VN，且有产生式X→Y1 Y2 … Yn；当Y1 Y2 … Yn-1都能推导出ε时，则FIRST(Y1)、FIRST(Y2)、…、FIRST(Yn-1)的所有非空元素和FIRST(Yn) 包含在FIRST(X)中。\n  \n\n\n即: FIRST(X)=(FIRST(Y1)－{ε} ）∪（FIRST(Y2)－{ε} ）∪…∪（FIRST(Yn-1)－{ε}）∪{FIRST(Yn)}\n⑤.当(4)中所有Yi 能够推导出ε,(i=1,2,…n)，则\nFIRST(X)=(FIRST(Y1)－{ε}）∪（FIRST(Y2)－ {ε}∪…∪（FIRST(Yn) －{ε}）∪{ε}\n\n\n  终结符的FIRST就是自己\n  对于产生式，如果最左边的能推导出ϵ\n  则再开始推第二个，并把最左边的FIRST并到自己的FIRST里。\n\n\nS→AB\nS→bC \nA→ε\nA→b\nB→ε　　\nB→aD\nC→AD\nC→b\nD→aS\nD→c\n\n\n\n  FIRST(A)={ε,b}\nFIRST(B)={a,ε}\nFIRST(S)={b,a,ε}\nFIRST(D)={a,c}\nFIRST(C)={b,a,c} #是因为A中有ε才去看D的\n\n\nFollow sets\n\nX→AB 则 first(B)∈follow(A) 并且 follow(X) ∈follow(B)\nB→*ϵ 则follow(X) ∈follow(A)\n\n\n  设S为文法中开始符号，把{#}加入FOLLOW(S)中(这里“$”  为开始符号)。\n  若A→αBβ是一个产生式，则把FIRST(β)的非空元素加入\nFOLLOW(B)中。如果β能够推导出ε 则把FOLLOW(A)也加入FOLLOW(B)中。\n  \n    反复使用(b)直到每个非终结符的FOLLOW集不再增大为止。\n  \n  产生式的右边如果存在，则把FIRST(右边)中除了ϵ 之外所有的符号加入FOLLOW(自己)\n  如果产生式的右边能推导出ϵ, 或者不存在，则产生式左边的FOLLOW也在自己的里面。 (左右是箭头的左右)\n\n\nE   →  TE'\nE'  →  +TE' | ε\nT   →  FT'\nT'  →  *FT' | ε\nF  →  (E) | i\n\n\n\n  FIRST(F)={ (,i }\nFIRST(T’)={ *,ε }\nFIRST(T) ={ (,i } #F中没有ε, 所以到F为止\nFIRST(E’)={ +,ε }\nFIRST(E)={ (,i }\n\n\n\n  FOLLOW(E)=｛ $,) };\nFOLLOW(E’)={ $,) }  \nFOLLOW(T)={+,),$}\nFOLLOW(T’)= FOLLOW(T)= {+,),$}    \nFOLLOW(F)={*,+,),$}\n\n\n",
        "content": "2020年03月08日更新\n\nSets\n\nG=(VT，VN，S，P)是上下文无关文法\n\nFirst sets\n\n\n  \n    若X∈VT，则FIRST(X)＝{X}。(简单讲，终结符的FIRST集就是它本身)\n  \n  \n    若X∈VN，且有产生式X→a…，a∈VT， 则 a∈FIRST(X)X→ε,则ε∈FIRST(X)。　（简单讲，若是非终结符X，能推导出以终结符a开头的串，那么这个终结符a属于FIRST（X），若X能够推导出空符号串ε，那么空符号串ε也属于X的FIRST集）\n  \n  \n    X→Y…是一个产生式且Y ∈VN  则把FIRST(Y)中的所有 非空符号串ε元素 都加入到FIRST(X)中。\n  \n  \n    若X∈VN；Y1，Y2，…，Yi∈VN，且有产生式X→Y1 Y2 … Yn；当Y1 Y2 … Yn-1都能推导出ε时，则FIRST(Y1)、FIRST(Y2)、…、FIRST(Yn-1)的所有非空元素和FIRST(Yn) 包含在FIRST(X)中。\n  \n\n\n即: FIRST(X)=(FIRST(Y1)－{ε} ）∪（FIRST(Y2)－{ε} ）∪…∪（FIRST(Yn-1)－{ε}）∪{FIRST(Yn)}\n⑤.当(4)中所有Yi 能够推导出ε,(i=1,2,…n)，则\nFIRST(X)=(FIRST(Y1)－{ε}）∪（FIRST(Y2)－ {ε}∪…∪（FIRST(Yn) －{ε}）∪{ε}\n\n\n  终结符的FIRST就是自己\n  对于产生式，如果最左边的能推导出ϵ\n  则再开始推第二个，并把最左边的FIRST并到自己的FIRST里。\n\n\nS→AB\nS→bC \nA→ε\nA→b\nB→ε　　\nB→aD\nC→AD\nC→b\nD→aS\nD→c\n\n\n\n  FIRST(A)={ε,b}\nFIRST(B)={a,ε}\nFIRST(S)={b,a,ε}\nFIRST(D)={a,c}\nFIRST(C)={b,a,c} #是因为A中有ε才去看D的\n\n\nFollow sets\n\nX→AB 则 first(B)∈follow(A) 并且 follow(X) ∈follow(B)\nB→*ϵ 则follow(X) ∈follow(A)\n\n\n  设S为文法中开始符号，把{#}加入FOLLOW(S)中(这里“$”  为开始符号)。\n  若A→αBβ是一个产生式，则把FIRST(β)的非空元素加入\nFOLLOW(B)中。如果β能够推导出ε 则把FOLLOW(A)也加入FOLLOW(B)中。\n  \n    反复使用(b)直到每个非终结符的FOLLOW集不再增大为止。\n  \n  产生式的右边如果存在，则把FIRST(右边)中除了ϵ 之外所有的符号加入FOLLOW(自己)\n  如果产生式的右边能推导出ϵ, 或者不存在，则产生式左边的FOLLOW也在自己的里面。 (左右是箭头的左右)\n\n\nE   →  TE'\nE'  →  +TE' | ε\nT   →  FT'\nT'  →  *FT' | ε\nF  →  (E) | i\n\n\n\n  FIRST(F)={ (,i }\nFIRST(T’)={ *,ε }\nFIRST(T) ={ (,i } #F中没有ε, 所以到F为止\nFIRST(E’)={ +,ε }\nFIRST(E)={ (,i }\n\n\n\n  FOLLOW(E)=｛ $,) };\nFOLLOW(E’)={ $,) }  \nFOLLOW(T)={+,),$}\nFOLLOW(T’)= FOLLOW(T)= {+,),$}    \nFOLLOW(F)={*,+,),$}\n\n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2020/03/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%A0%E7%AC%94%E8%AE%B0/"
      },
    
      {
        "title": "Fibonacci Number",
        "excerpt": "&lt;-E&gt; Fibonacci Number\n\nclass Solution {\npublic:\n    int fib(int N) {\n        if (N == 0)\n            return 0;\n        else if(N == 1)\n            return 1;\n        else\n            return fib(N - 1) + fib(N - 2);\n    }\n};\n\n\n",
        "content": "&lt;-E&gt; Fibonacci Number\n\nclass Solution {\npublic:\n    int fib(int N) {\n        if (N == 0)\n            return 0;\n        else if(N == 1)\n            return 1;\n        else\n            return fib(N - 1) + fib(N - 2);\n    }\n};\n\n\n",
        "url": "/2020/04/19/Fibonacci-Number/"
      },
    
      {
        "title": "Remove Palindromic Subsequences",
        "excerpt": "&lt;-E 1332&gt; Remove Palindromic Subsequences\n\nclass Solution {\npublic:\n    int removePalindromeSub(string s) {\n        if(s.empty()){\n            return 0;\n        }\n        if(isPalindrome(s)){\n            return 1;\n        }\n        return 2;\n    }\n    bool isPalindrome(string s){\n        for(int i=0; i != s.size(); i++){\n            if(s[i] != s[s.size() - 1 - i]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 1332&gt; Remove Palindromic Subsequences\n\nclass Solution {\npublic:\n    int removePalindromeSub(string s) {\n        if(s.empty()){\n            return 0;\n        }\n        if(isPalindrome(s)){\n            return 1;\n        }\n        return 2;\n    }\n    bool isPalindrome(string s){\n        for(int i=0; i != s.size(); i++){\n            if(s[i] != s[s.size() - 1 - i]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2020/07/21/1332-Remove-Palindromic-Subsequences/"
      },
    
      {
        "title": "The K Weakest Rows in a Matrix",
        "excerpt": "&lt;-E 1337&gt; The K Weakest Rows in a Matrix\n\nclass Solution {\npublic:\n    vector&lt;int&gt; kWeakestRows(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) {\n        multimap&lt;int,int&gt; temp;\n        for(int i = 0; i != mat.size(); i++) {\n            int account = 0;\n            for(int j = 0; j != mat[0].size(); j++) {\n                account += mat[i][j];\n            }\n            temp.insert(pair&lt;int,int&gt;(account,i));\n        }\n        vector&lt;int&gt; ans;\n        auto it = temp.begin();\n        for(int i=0;i&lt;k;i++)\n        {\n            ans.push_back(it-&gt;second);\n            it++;\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1337&gt; The K Weakest Rows in a Matrix\n\nclass Solution {\npublic:\n    vector&lt;int&gt; kWeakestRows(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) {\n        multimap&lt;int,int&gt; temp;\n        for(int i = 0; i != mat.size(); i++) {\n            int account = 0;\n            for(int j = 0; j != mat[0].size(); j++) {\n                account += mat[i][j];\n            }\n            temp.insert(pair&lt;int,int&gt;(account,i));\n        }\n        vector&lt;int&gt; ans;\n        auto it = temp.begin();\n        for(int i=0;i&lt;k;i++)\n        {\n            ans.push_back(it-&gt;second);\n            it++;\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/07/22/1337-The-K-Weakest-Rows-in-a-Matrix/"
      },
    
      {
        "title": "Check If N and Its Double Exist",
        "excerpt": "&lt;-E 1346&gt; Check If N and Its Double Exist\n\nclass Solution {\npublic:\n      bool checkIfExist(vector&lt;int&gt;&amp; arr) {\n        int positive[9999] = {0};\n        int negative[9999] = {0};\n        for(int i = 0; i != arr.size(); i++) {\n            if(arr[i] &gt; 0)\n                positive[arr[i]]++;\n            else\n                negative[-arr[i]]++;\n        }\n        \n        \n        for(int i = 1; i != 9999; i++) {\n            if(positive[i] != 0) {\n                if(positive[i * 2] != 0)\n                    return true;\n            }\n        }\n        for(int i = 1; i != 9999; i++) {\n            if(negative[i] != 0)\n                if(negative[i * 2] != 0)\n                    return true;\n        }\n        if(negative[0] == 2)\n            return true;\n        return false;\n    }\n};\n\n\nclass Solution {\npublic:\n      bool checkIfExist(vector&lt;int&gt;&amp; arr) {\n        unordered_multiset&lt;int&gt;st(arr.begin(),arr.end());\n        int n = arr.size();\n        for(int i = 0 ; i &lt; n ; i++)\n            if(st.find(arr[i]*2) != st.end())\n            {\n                if(arr[i] == 0)\n                    if(st.count(0) == 1)\n                        continue;\n                return true;\n            }\n        return false;\n    \n    }\n};\n\n\n",
        "content": "&lt;-E 1346&gt; Check If N and Its Double Exist\n\nclass Solution {\npublic:\n      bool checkIfExist(vector&lt;int&gt;&amp; arr) {\n        int positive[9999] = {0};\n        int negative[9999] = {0};\n        for(int i = 0; i != arr.size(); i++) {\n            if(arr[i] &gt; 0)\n                positive[arr[i]]++;\n            else\n                negative[-arr[i]]++;\n        }\n        \n        \n        for(int i = 1; i != 9999; i++) {\n            if(positive[i] != 0) {\n                if(positive[i * 2] != 0)\n                    return true;\n            }\n        }\n        for(int i = 1; i != 9999; i++) {\n            if(negative[i] != 0)\n                if(negative[i * 2] != 0)\n                    return true;\n        }\n        if(negative[0] == 2)\n            return true;\n        return false;\n    }\n};\n\n\nclass Solution {\npublic:\n      bool checkIfExist(vector&lt;int&gt;&amp; arr) {\n        unordered_multiset&lt;int&gt;st(arr.begin(),arr.end());\n        int n = arr.size();\n        for(int i = 0 ; i &lt; n ; i++)\n            if(st.find(arr[i]*2) != st.end())\n            {\n                if(arr[i] == 0)\n                    if(st.count(0) == 1)\n                        continue;\n                return true;\n            }\n        return false;\n    \n    }\n};\n\n\n",
        "url": "/2020/07/23/1346-Check-If-N-and-Its-Double-Exist/"
      },
    
      {
        "title": "Sort Integers by The Number of 1 Bits",
        "excerpt": "&lt;-E 1356&gt; Sort Integers by The Number of 1 Bits\n\nclass Solution {\npublic:\n  static bool cmp(int a,int b)\n    {\n        bitset&lt;32&gt; c1(a);\n        bitset&lt;32&gt; c2(b);\n        int p,q;\n        p=c1.count();\n        q=c2.count();\n        if(p==q)\n            return a&lt;b;\n        else return p&lt;q;\n    }\n    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; v) {\n        sort(v.begin(),v.end(),cmp);\n        return v;\n        \n    }\n};\n\n\n",
        "content": "&lt;-E 1356&gt; Sort Integers by The Number of 1 Bits\n\nclass Solution {\npublic:\n  static bool cmp(int a,int b)\n    {\n        bitset&lt;32&gt; c1(a);\n        bitset&lt;32&gt; c2(b);\n        int p,q;\n        p=c1.count();\n        q=c2.count();\n        if(p==q)\n            return a&lt;b;\n        else return p&lt;q;\n    }\n    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; v) {\n        sort(v.begin(),v.end(),cmp);\n        return v;\n        \n    }\n};\n\n\n",
        "url": "/2020/07/24/1356-Sort-Integers-by-The-Number-of-1-Bits/"
      },
    
      {
        "title": "Number of Days Between Two Dates",
        "excerpt": "&lt;-E 1360&gt; Number of Days Between Two Dates\n\nclass Solution {\npublic:\n    int daysBetweenDates(string date1, string date2) {\n        return abs(daysPassedSince1971(date1) - daysPassedSince1971(date2));\n    }\n    bool isLeapYear(int year){\n        return (year%400 == 0)||(year%100 != 0 &amp;&amp; year%4 == 0);\n    }\n    int daysPassedSince1971(string date){\n        int year = stoi(date.substr(0,4));\n        int month = stoi(date.substr(5,2));\n        int day = stoi(date.substr(8,2));\n        \n        vector&lt;int&gt; months ({0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31});\n        \n        for(int i=1971;i&lt;year;i++){\n            day += isLeapYear(i) ? 366 : 365;\n        }\n        \n        for(int i=1;i&lt;month;i++){\n            if(i==2 &amp;&amp; isLeapYear(year)){\n                day += 1;\n            }\n            day += months[i];\n        }\n        \n        return day;\n    }\n};\n\n\n",
        "content": "&lt;-E 1360&gt; Number of Days Between Two Dates\n\nclass Solution {\npublic:\n    int daysBetweenDates(string date1, string date2) {\n        return abs(daysPassedSince1971(date1) - daysPassedSince1971(date2));\n    }\n    bool isLeapYear(int year){\n        return (year%400 == 0)||(year%100 != 0 &amp;&amp; year%4 == 0);\n    }\n    int daysPassedSince1971(string date){\n        int year = stoi(date.substr(0,4));\n        int month = stoi(date.substr(5,2));\n        int day = stoi(date.substr(8,2));\n        \n        vector&lt;int&gt; months ({0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31});\n        \n        for(int i=1971;i&lt;year;i++){\n            day += isLeapYear(i) ? 366 : 365;\n        }\n        \n        for(int i=1;i&lt;month;i++){\n            if(i==2 &amp;&amp; isLeapYear(year)){\n                day += 1;\n            }\n            day += months[i];\n        }\n        \n        return day;\n    }\n};\n\n\n",
        "url": "/2020/07/25/1360-Number-of-Days-Between-Two-Dates/"
      },
    
      {
        "title": "Generate a String With Characters That Have Odd Counts",
        "excerpt": "&lt;-E 1374&gt; Generate a String With Characters That Have Odd Counts\n\nclass Solution {\npublic:\n    string generateTheString(int n) {\n        if(n % 2){\n            string a(n, 'a');\n            return a;\n        }\n        else{   \n            string a(n-1, 'a');\n            return \"b\"+a;\n        }\n            \n    }\n};\n\n\n",
        "content": "&lt;-E 1374&gt; Generate a String With Characters That Have Odd Counts\n\nclass Solution {\npublic:\n    string generateTheString(int n) {\n        if(n % 2){\n            string a(n, 'a');\n            return a;\n        }\n        else{   \n            string a(n-1, 'a');\n            return \"b\"+a;\n        }\n            \n    }\n};\n\n\n",
        "url": "/2020/07/26/1374-Generate-a-String-With-Characters-That-Have-Odd-Counts/"
      },
    
      {
        "title": "Find the Distance Value Between Two Arrays",
        "excerpt": "&lt;-E 1385&gt; Find the Distance Value Between Two Arrays\n\nclass Solution {\npublic:\n    int findTheDistanceValue(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2, int d) {\n        int len1 = arr1.size(), len2 = arr2.size();\n        int ans = 0;\n        bool chk;\n        \n        for(int i=0; i&lt;len1; i++){\n            chk = false;\n            for(int j=0; j&lt;len2; j++){\n                if(abs(arr1[i]-arr2[j]) &lt;= d)\n                {   \n                    chk = true;\n                    break;\n                }\n            }\n            if(!chk) ans++;\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1385&gt; Find the Distance Value Between Two Arrays\n\nclass Solution {\npublic:\n    int findTheDistanceValue(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2, int d) {\n        int len1 = arr1.size(), len2 = arr2.size();\n        int ans = 0;\n        bool chk;\n        \n        for(int i=0; i&lt;len1; i++){\n            chk = false;\n            for(int j=0; j&lt;len2; j++){\n                if(abs(arr1[i]-arr2[j]) &lt;= d)\n                {   \n                    chk = true;\n                    break;\n                }\n            }\n            if(!chk) ans++;\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/07/27/1385-Find-the-Distance-Value-Between-Two-Arrays/"
      },
    
      {
        "title": "Find Lucky Integer in an Array",
        "excerpt": "&lt;-E 1394&gt; Find Lucky Integer in an Array\n\nclass Solution {\npublic:\n    int findLucky(vector&lt;int&gt;&amp; arr) {\n        int temp[500] = {0};\n        for(int i = 0; i!= arr.size(); i++) {\n            temp[arr[i]]++;\n        }\n        for(int i = 499; i != 0; i--) {\n            if(temp[i] == i) \n                return i;\n        }\n       \n        return -1;\n    }   \n};\n\n\n",
        "content": "&lt;-E 1394&gt; Find Lucky Integer in an Array\n\nclass Solution {\npublic:\n    int findLucky(vector&lt;int&gt;&amp; arr) {\n        int temp[500] = {0};\n        for(int i = 0; i!= arr.size(); i++) {\n            temp[arr[i]]++;\n        }\n        for(int i = 499; i != 0; i--) {\n            if(temp[i] == i) \n                return i;\n        }\n       \n        return -1;\n    }   \n};\n\n\n",
        "url": "/2020/07/28/1394-Find-Lucky-Integer-in-an-Array/"
      },
    
      {
        "title": "Merge Two Sorted Lists",
        "excerpt": "&lt;-E 21&gt; Merge Two Sorted Lists\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(l1==NULL || l2==NULL)\n            return l1&gt;l2 ? l1 : l2;\n        \n        ListNode* head=(l1-&gt;val&lt;l2-&gt;val) ? l1 : l2;\n        head-&gt;next=mergeTwoLists(head==l1 ? l1-&gt;next : l1, head==l2 ? l2-&gt;next :l2);\n        return head;\n    }\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(l1 == NULL)\n            return l2;\n        else if(l2 == NULL)\n            return l1;\n        \n        ListNode* h = NULL;\n        \n        if(l1-&gt;val &lt;= l2-&gt;val) {\n            h = l1;\n            h-&gt;next = mergeTwoLists(l1-&gt;next,l2);\n        }\n        else {\n            h = l2;\n            h-&gt;next = mergeTwoLists(l1,l2-&gt;next);\n        }\n        return h; \n    }\n};\n\n\n",
        "content": "&lt;-E 21&gt; Merge Two Sorted Lists\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(l1==NULL || l2==NULL)\n            return l1&gt;l2 ? l1 : l2;\n        \n        ListNode* head=(l1-&gt;val&lt;l2-&gt;val) ? l1 : l2;\n        head-&gt;next=mergeTwoLists(head==l1 ? l1-&gt;next : l1, head==l2 ? l2-&gt;next :l2);\n        return head;\n    }\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(l1 == NULL)\n            return l2;\n        else if(l2 == NULL)\n            return l1;\n        \n        ListNode* h = NULL;\n        \n        if(l1-&gt;val &lt;= l2-&gt;val) {\n            h = l1;\n            h-&gt;next = mergeTwoLists(l1-&gt;next,l2);\n        }\n        else {\n            h = l2;\n            h-&gt;next = mergeTwoLists(l1,l2-&gt;next);\n        }\n        return h; \n    }\n};\n\n\n",
        "url": "/2020/07/29/121-Merge-Two-Sorted-Lists/"
      },
    
      {
        "title": "Implement strStr()",
        "excerpt": "&lt;-E 28&gt; Implement strStr()\n\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0)\n            return 0;\n        else if(needle.size() &gt; haystack.size())\n            return -1;\n        else {\n            for(int i = 0, j = 0; i!= haystack.size(); ) {\n                if(haystack[i] != needle[j]) {\n                    i = i - j + 1;\n                    j = 0;\n                }\n                else {\n                    i++;\n                    j++;\n                    if(j == needle.size())\n                        return i - needle.size();\n                }\n        }\n        return -1;   \n        }\n    }\n};\n\n\n",
        "content": "&lt;-E 28&gt; Implement strStr()\n\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0)\n            return 0;\n        else if(needle.size() &gt; haystack.size())\n            return -1;\n        else {\n            for(int i = 0, j = 0; i!= haystack.size(); ) {\n                if(haystack[i] != needle[j]) {\n                    i = i - j + 1;\n                    j = 0;\n                }\n                else {\n                    i++;\n                    j++;\n                    if(j == needle.size())\n                        return i - needle.size();\n                }\n        }\n        return -1;   \n        }\n    }\n};\n\n\n",
        "url": "/2020/07/30/28-Implement-strStr/"
      },
    
      {
        "title": "Count and Say",
        "excerpt": "&lt;-E 38&gt; Count and Say\n\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 0)\n            return \"\";\n        else if(n == 1)\n            return \"1\";\n        else if (n == 2)\n            return \"11\";\n        string ans = \"11\";\n        int counter = 0;\n        \n        while(n &gt;= 3) {\n            string temp;\n            \n            for(int i = 0; i != ans.size();) {\n                char curr = ans[i];\n\t\t\t\twhile (i &lt; ans.size() &amp;&amp; ans[i] == curr)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\ttemp.append(to_string(counter) + curr);\n\t\t\t\tcounter = 0;\n\t\t\t}\n\t\t\tans = temp;\n            \n            n--;    \n        }  \n        return ans;   \n    }\n};\n\n\n",
        "content": "&lt;-E 38&gt; Count and Say\n\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 0)\n            return \"\";\n        else if(n == 1)\n            return \"1\";\n        else if (n == 2)\n            return \"11\";\n        string ans = \"11\";\n        int counter = 0;\n        \n        while(n &gt;= 3) {\n            string temp;\n            \n            for(int i = 0; i != ans.size();) {\n                char curr = ans[i];\n\t\t\t\twhile (i &lt; ans.size() &amp;&amp; ans[i] == curr)\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\ttemp.append(to_string(counter) + curr);\n\t\t\t\tcounter = 0;\n\t\t\t}\n\t\t\tans = temp;\n            \n            n--;    \n        }  \n        return ans;   \n    }\n};\n\n\n",
        "url": "/2020/07/31/38-Count-and-Say/"
      },
    
      {
        "title": "Length of Last Word",
        "excerpt": "&lt;-E 58&gt; Length of Last Word\n\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int ans = 0;\n        for(int i = s.size() - 1; i &gt;= 0; i--) {\n            if(s[i] != ' ')\n                ans++;\n            if(s[i] == ' ' &amp;&amp; ans != 0)\n                return ans;\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 58&gt; Length of Last Word\n\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int ans = 0;\n        for(int i = s.size() - 1; i &gt;= 0; i--) {\n            if(s[i] != ' ')\n                ans++;\n            if(s[i] == ' ' &amp;&amp; ans != 0)\n                return ans;\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/08/01/58-Length-of-Last-Word/"
      },
    
      {
        "title": "Add Binary",
        "excerpt": "&lt;-E 67&gt; Add Binary\n\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        \n        const int aLength = a.length();\n        const int bLength = b.length();\n        const int resultLength = max(aLength, bLength) + 1;\n\n        char temp[resultLength + 1];\n        temp[resultLength] = '\\0';\n\n        int resultIndex = resultLength - 1;\n        int carry = 0;\n\n        for(int i = aLength-1, j = bLength-1; i&gt;=0 || j &gt;=0; i--, j--, resultIndex--) {\n            const int aVal = (i &gt;= 0 ? a[i] : '0') - '0';\n            const int bVal = (j &gt;= 0 ? b[j] : '0') - '0';\n            const int sum = aVal + bVal + carry;\n            temp[resultIndex] = (sum % 2) + '0';\n            carry = sum / 2;\n        }\n\n        char* result = &amp;temp[resultIndex];\n        \n        if (carry &gt; 0)\n            result[resultIndex] = carry + '0';\n        else\n            result++;\n\n        return result;\n    }\n};\n\n\n\nclass Solution {\npublic:\n    string addBinary(string&amp; a, string&amp; b) {\n        int n = max(a.size(), b.size());\n        string s;\n        s.reserve(n + 1);\n        \n        int carry = 0;\n        int i = a.size();\n        int j = b.size();\n        while (i || j || carry) {\n            int current_pos_sum = carry;\n            if (i) current_pos_sum += (a[--i] == '1' ? 1 : 0);\n            if (j) current_pos_sum += (b[--j] == '1' ? 1 : 0);\n            \n            s.push_back((current_pos_sum % 2 == 1) ? '1' : '0');\n            carry = current_pos_sum / 2;\n        }\n        reverse(s.begin(), s.end());\n        return s;\n    }\n};\n\n\n",
        "content": "&lt;-E 67&gt; Add Binary\n\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        \n        const int aLength = a.length();\n        const int bLength = b.length();\n        const int resultLength = max(aLength, bLength) + 1;\n\n        char temp[resultLength + 1];\n        temp[resultLength] = '\\0';\n\n        int resultIndex = resultLength - 1;\n        int carry = 0;\n\n        for(int i = aLength-1, j = bLength-1; i&gt;=0 || j &gt;=0; i--, j--, resultIndex--) {\n            const int aVal = (i &gt;= 0 ? a[i] : '0') - '0';\n            const int bVal = (j &gt;= 0 ? b[j] : '0') - '0';\n            const int sum = aVal + bVal + carry;\n            temp[resultIndex] = (sum % 2) + '0';\n            carry = sum / 2;\n        }\n\n        char* result = &amp;temp[resultIndex];\n        \n        if (carry &gt; 0)\n            result[resultIndex] = carry + '0';\n        else\n            result++;\n\n        return result;\n    }\n};\n\n\n\nclass Solution {\npublic:\n    string addBinary(string&amp; a, string&amp; b) {\n        int n = max(a.size(), b.size());\n        string s;\n        s.reserve(n + 1);\n        \n        int carry = 0;\n        int i = a.size();\n        int j = b.size();\n        while (i || j || carry) {\n            int current_pos_sum = carry;\n            if (i) current_pos_sum += (a[--i] == '1' ? 1 : 0);\n            if (j) current_pos_sum += (b[--j] == '1' ? 1 : 0);\n            \n            s.push_back((current_pos_sum % 2 == 1) ? '1' : '0');\n            carry = current_pos_sum / 2;\n        }\n        reverse(s.begin(), s.end());\n        return s;\n    }\n};\n\n\n",
        "url": "/2020/08/02/67.-Add-Binary/"
      },
    
      {
        "title": "Remove Duplicates from Sorted List",
        "excerpt": "&lt;-E 83&gt; Remove Duplicates from Sorted List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n       if(head==NULL)\n            return NULL;\n        ListNode *first=head,*last=head-&gt;next;\n        while(last!=NULL)\n        {\n            if(first-&gt;val==last-&gt;val)\n            {\n                ListNode *temp=last;\n                last=last-&gt;next;\n                first-&gt;next=last;\n            }\n            else\n            {\n                first=first-&gt;next;\n                last=last-&gt;next;\n            }\n        }\n        return head;\n    }\n};\n\n\n",
        "content": "&lt;-E 83&gt; Remove Duplicates from Sorted List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n       if(head==NULL)\n            return NULL;\n        ListNode *first=head,*last=head-&gt;next;\n        while(last!=NULL)\n        {\n            if(first-&gt;val==last-&gt;val)\n            {\n                ListNode *temp=last;\n                last=last-&gt;next;\n                first-&gt;next=last;\n            }\n            else\n            {\n                first=first-&gt;next;\n                last=last-&gt;next;\n            }\n        }\n        return head;\n    }\n};\n\n\n",
        "url": "/2020/08/03/83-Remove-Duplicates-from-Sorted-List/"
      },
    
      {
        "title": "Merge Sorted Array",
        "excerpt": "&lt;-E 88&gt; Merge Sorted Array\n\nclass Solution {\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n    for(int i = 0; i != n; i++) {\n        nums1[i + m] = nums2[i];\n    }\n    sort(nums1.begin(), nums1.end());\n    }\n};\n\n\n",
        "content": "&lt;-E 88&gt; Merge Sorted Array\n\nclass Solution {\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n    for(int i = 0; i != n; i++) {\n        nums1[i + m] = nums2[i];\n    }\n    sort(nums1.begin(), nums1.end());\n    }\n};\n\n\n",
        "url": "/2020/08/04/88-Merge-Sorted-Array/"
      },
    
      {
        "title": "Same Tree",
        "excerpt": "&lt;-E 100&gt; Same Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==NULL &amp;&amp; q==NULL)\n            return true;\n        if(p==NULL &amp;&amp; q!=NULL)\n            return false;\n        if(p!=NULL &amp;&amp; q==NULL)\n            return false;\n        if(p-&gt;val!=q-&gt;val)\n            return false;\n        return (isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right));\n    }\n};\n\n\n",
        "content": "&lt;-E 100&gt; Same Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==NULL &amp;&amp; q==NULL)\n            return true;\n        if(p==NULL &amp;&amp; q!=NULL)\n            return false;\n        if(p!=NULL &amp;&amp; q==NULL)\n            return false;\n        if(p-&gt;val!=q-&gt;val)\n            return false;\n        return (isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right));\n    }\n};\n\n\n",
        "url": "/2020/08/05/100-Same-Tree/"
      },
    
      {
        "title": "Reverse Linked List",
        "excerpt": "&lt;-E 206&gt; Reverse Linked List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *curr= head;\n        ListNode *next= NULL;\n        ListNode *prev= NULL;\n\n        while(curr !=NULL){\n            next=curr-&gt;next;\n            curr-&gt;next=prev;\n            prev=curr;\n            curr=next;\n        }\n        head=prev;\n        return head;\n    }\n};\n\n// method 2\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev{};\n            while(head)\n                head=exchange(head-&gt;next,exchange(prev,head));\n            return prev;\n        }\n};\n\n\n",
        "content": "&lt;-E 206&gt; Reverse Linked List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *curr= head;\n        ListNode *next= NULL;\n        ListNode *prev= NULL;\n\n        while(curr !=NULL){\n            next=curr-&gt;next;\n            curr-&gt;next=prev;\n            prev=curr;\n            curr=next;\n        }\n        head=prev;\n        return head;\n    }\n};\n\n// method 2\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev{};\n            while(head)\n                head=exchange(head-&gt;next,exchange(prev,head));\n            return prev;\n        }\n};\n\n\n",
        "url": "/2020/08/24/206-Reverse-Linked-List/"
      },
    
      {
        "title": "Monotonic Array",
        "excerpt": "&lt;-E 896&gt; Monotonic Array\n\nclass Solution {\npublic:\n    bool isMonotonic(vector&lt;int&gt;&amp; A) {\n        if(A.size() &lt; 2)\n            return true;\n        bool increasing =false;\n        bool decreasing =false;\n        for(int i = 1; i!= A.size(); i++) {\n            if(A[i] - A[i - 1] &gt; 0)\n                increasing = true;\n            else if (A[i] - A[i - 1] &lt; 0)\n                decreasing = true;\n            if(increasing &amp;&amp; decreasing)\n                return false;\n        }\n        \n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 896&gt; Monotonic Array\n\nclass Solution {\npublic:\n    bool isMonotonic(vector&lt;int&gt;&amp; A) {\n        if(A.size() &lt; 2)\n            return true;\n        bool increasing =false;\n        bool decreasing =false;\n        for(int i = 1; i!= A.size(); i++) {\n            if(A[i] - A[i - 1] &gt; 0)\n                increasing = true;\n            else if (A[i] - A[i - 1] &lt; 0)\n                decreasing = true;\n            if(increasing &amp;&amp; decreasing)\n                return false;\n        }\n        \n        return true;\n    }\n};\n\n\n",
        "url": "/2020/08/28/896-Monotonic-Arrayy/"
      },
    
      {
        "title": "Symmetric Tree",
        "excerpt": "&lt;-E 101&gt; Symmetric Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        return !root || rec(root-&gt;left, root-&gt;right);\n    }\n    bool rec(TreeNode* left, TreeNode *right) {\n        if(!right &amp;&amp; !left)\n            return true;\n        if(!right || !left || right-&gt;val != left-&gt;val)\n            return false;\n        return rec(left-&gt;left, right-&gt;right) &amp;&amp; rec(right-&gt;left, left-&gt;right);\n    }\n};\n\n\n\n",
        "content": "&lt;-E 101&gt; Symmetric Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        return !root || rec(root-&gt;left, root-&gt;right);\n    }\n    bool rec(TreeNode* left, TreeNode *right) {\n        if(!right &amp;&amp; !left)\n            return true;\n        if(!right || !left || right-&gt;val != left-&gt;val)\n            return false;\n        return rec(left-&gt;left, right-&gt;right) &amp;&amp; rec(right-&gt;left, left-&gt;right);\n    }\n};\n\n\n\n",
        "url": "/2020/08/29/101-Symmetric-Tree/"
      },
    
      {
        "title": "Distribute Candies to People",
        "excerpt": "&lt;-E 1103&gt; Distribute Candies to People\n\nclass Solution {\npublic:\n    vector&lt;int&gt; distributeCandies(int candies, int num_people) {\n        if (num_people == 1) return vector{candies};\n        vector&lt;int&gt; ans(num_people, 0);\n        int k = 0;\n        while (num_people * (k * num_people + num_people + 1) * (k + 1) / 2 &lt;= candies) k++;\n        k--;\n        candies -= (num_people * (k * num_people + num_people + 1) * (k + 1) / 2);\n        for (int i = 1; i &lt;= num_people; ++i) {\n            int p = i + (k + 1) * num_people;\n            if (candies &gt;= p) {\n                ans[i - 1] = p + (k + 1) * i + k * (k + 1) / 2 * num_people;\n                candies = candies - p;\n            } else {\n                ans[i - 1] = candies + (k + 1) * i + k * (k + 1) / 2 * num_people;\n                candies = 0;\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1103&gt; Distribute Candies to People\n\nclass Solution {\npublic:\n    vector&lt;int&gt; distributeCandies(int candies, int num_people) {\n        if (num_people == 1) return vector{candies};\n        vector&lt;int&gt; ans(num_people, 0);\n        int k = 0;\n        while (num_people * (k * num_people + num_people + 1) * (k + 1) / 2 &lt;= candies) k++;\n        k--;\n        candies -= (num_people * (k * num_people + num_people + 1) * (k + 1) / 2);\n        for (int i = 1; i &lt;= num_people; ++i) {\n            int p = i + (k + 1) * num_people;\n            if (candies &gt;= p) {\n                ans[i - 1] = p + (k + 1) * i + k * (k + 1) / 2 * num_people;\n                candies = candies - p;\n            } else {\n                ans[i - 1] = candies + (k + 1) * i + k * (k + 1) / 2 * num_people;\n                candies = 0;\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/08/30/1103-Distribute-Candies-to-People/"
      },
    
      {
        "title": "Asteroid Collision",
        "excerpt": "&lt;-E 735&gt; Asteroid Collision\n\n// method 1\nclass Solution {\npublic:\n        vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; asteroids) {\n                vector&lt;int&gt; ans;\n                for(int i=0; i!=asteroids.size();i++){\n                    if(ans.size() == 0)\n                        ans.push_back(asteroids[i]);\n                    else {\n                        while(ans.size() &gt; 0) {\n                            int temp = ans.back() + asteroids[i];\n                            if(temp == 0 &amp;&amp; ans.back() &gt; 0) {\n                                ans.pop_back();\n                                break;\n                            }\n                            else if(ans.back() &gt; 0) {\n                                if(temp &gt; ans.back()){\n                                    ans.push_back(asteroids[i]);\n                                    break;\n                                }\n                                else {\n                                    if(abs(asteroids[i]) &gt; abs(ans.back())) {\n                                        ans.pop_back();\n                                        if(ans.size() == 0){\n                                            ans.push_back(asteroids[i]);\n                                            break;\n                                        }\n                                            \n                                    }\n                                    else\n                                        break;\n                                }\n                            }\n                            else if (ans.back() &lt; 0) {\n                                ans.push_back(asteroids[i]);\n                                break;\n                        }\n                    }\n                    \n                }\n            }    \n            return ans;\n        }\n};\n\n// method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; asteroids) {\n        vector&lt;int&gt; leftpassed;\n        vector&lt;int&gt; ast;\n        for(auto&amp; a : asteroids){\n            if(a&gt;0)\n                ast.push_back(a);\n            else{\n                while(ast.size() &amp;&amp; ast.back()&lt;abs(a)){\n                    ast.pop_back();\n                }\n                if(ast.size() &amp;&amp; ast.back()==abs(a)){\n                    ast.pop_back();\n                }\n                else if(ast.size() &amp;&amp; ast.back()&gt;abs(a)){\n                    \n                }\n                else{\n                    leftpassed.push_back(a);\n                }\n            }\n        }\n        \n        for(auto&amp; x:ast)\n           leftpassed.push_back(x); \n        return leftpassed;\n    }\n};\n\n\n",
        "content": "&lt;-E 735&gt; Asteroid Collision\n\n// method 1\nclass Solution {\npublic:\n        vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; asteroids) {\n                vector&lt;int&gt; ans;\n                for(int i=0; i!=asteroids.size();i++){\n                    if(ans.size() == 0)\n                        ans.push_back(asteroids[i]);\n                    else {\n                        while(ans.size() &gt; 0) {\n                            int temp = ans.back() + asteroids[i];\n                            if(temp == 0 &amp;&amp; ans.back() &gt; 0) {\n                                ans.pop_back();\n                                break;\n                            }\n                            else if(ans.back() &gt; 0) {\n                                if(temp &gt; ans.back()){\n                                    ans.push_back(asteroids[i]);\n                                    break;\n                                }\n                                else {\n                                    if(abs(asteroids[i]) &gt; abs(ans.back())) {\n                                        ans.pop_back();\n                                        if(ans.size() == 0){\n                                            ans.push_back(asteroids[i]);\n                                            break;\n                                        }\n                                            \n                                    }\n                                    else\n                                        break;\n                                }\n                            }\n                            else if (ans.back() &lt; 0) {\n                                ans.push_back(asteroids[i]);\n                                break;\n                        }\n                    }\n                    \n                }\n            }    \n            return ans;\n        }\n};\n\n// method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; asteroids) {\n        vector&lt;int&gt; leftpassed;\n        vector&lt;int&gt; ast;\n        for(auto&amp; a : asteroids){\n            if(a&gt;0)\n                ast.push_back(a);\n            else{\n                while(ast.size() &amp;&amp; ast.back()&lt;abs(a)){\n                    ast.pop_back();\n                }\n                if(ast.size() &amp;&amp; ast.back()==abs(a)){\n                    ast.pop_back();\n                }\n                else if(ast.size() &amp;&amp; ast.back()&gt;abs(a)){\n                    \n                }\n                else{\n                    leftpassed.push_back(a);\n                }\n            }\n        }\n        \n        for(auto&amp; x:ast)\n           leftpassed.push_back(x); \n        return leftpassed;\n    }\n};\n\n\n",
        "url": "/2020/08/31/735-Asteroid-Collision/"
      },
    
      {
        "title": "Min Stack",
        "excerpt": "&lt;-E 155&gt; Min Stack\n\nclass MinStack {\nprivate:\n    stack&lt;int&gt; stk;\n    stack&lt;int&gt; min;\n    \npublic:\n    /** initialize your data structure here. */\n    MinStack() {\n        \n    }\n    \n    void push(int x) {\n        stk.push(x);\n        if (min.empty() || min.top() &gt;= x)\n            min.push(x);\n    }\n    \n    void pop() {\n        if (min.top() == stk.top())\n            min.pop();\n        stk.pop();\n    }\n    \n    int top() {\n        return stk.top();\n    }\n    \n    int getMin() {\n        return min.top();\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj-&gt;push(x);\n * obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * int param_4 = obj-&gt;getMin();\n */\n\n\n",
        "content": "&lt;-E 155&gt; Min Stack\n\nclass MinStack {\nprivate:\n    stack&lt;int&gt; stk;\n    stack&lt;int&gt; min;\n    \npublic:\n    /** initialize your data structure here. */\n    MinStack() {\n        \n    }\n    \n    void push(int x) {\n        stk.push(x);\n        if (min.empty() || min.top() &gt;= x)\n            min.push(x);\n    }\n    \n    void pop() {\n        if (min.top() == stk.top())\n            min.pop();\n        stk.pop();\n    }\n    \n    int top() {\n        return stk.top();\n    }\n    \n    int getMin() {\n        return min.top();\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj-&gt;push(x);\n * obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * int param_4 = obj-&gt;getMin();\n */\n\n\n",
        "url": "/2020/09/01/155-Min-Stack/"
      },
    
      {
        "title": "Rotate Array",
        "excerpt": "&lt;-E 189&gt; Rotate Array\n\n// Method 1\nclass Solution {\npublic:\n    \n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n       k%=nums.size();\n        reverse(nums.begin(),nums.end());\n        reverse(nums.begin(),nums.begin()+k);\n        reverse(nums.begin()+k,nums.end());\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    \n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n       k=k%nums.size();\n        int p=0;\n        for(int i=0;i&lt;k&amp;&amp;p&lt;nums.size();i++)\n        {\n            int f=0;\n            int j=i;\n            int temp=nums[i];\n            do{\n                j=(j+k)%nums.size();\n                int x=nums[j];\n                nums[j]=temp;\n                temp=x;\n                p++;\n                \n            }while(j!=i);\n           // p++;\n            \n        }\n    }\n};\n\n\n",
        "content": "&lt;-E 189&gt; Rotate Array\n\n// Method 1\nclass Solution {\npublic:\n    \n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n       k%=nums.size();\n        reverse(nums.begin(),nums.end());\n        reverse(nums.begin(),nums.begin()+k);\n        reverse(nums.begin()+k,nums.end());\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    \n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n       k=k%nums.size();\n        int p=0;\n        for(int i=0;i&lt;k&amp;&amp;p&lt;nums.size();i++)\n        {\n            int f=0;\n            int j=i;\n            int temp=nums[i];\n            do{\n                j=(j+k)%nums.size();\n                int x=nums[j];\n                nums[j]=temp;\n                temp=x;\n                p++;\n                \n            }while(j!=i);\n           // p++;\n            \n        }\n    }\n};\n\n\n",
        "url": "/2020/09/15/189-Rotate-Array/"
      },
    
      {
        "title": "Contains Duplicate II",
        "excerpt": "&lt;-E 219&gt; Contains Duplicate II\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {\n         \n        if (nums.size() == 0 || nums.size() == 1 || k == 35000)\n            return false;\n        for (int i = 0; i &lt; nums.size() - 1; i++)\n            for (int j = i + 1; j &lt; nums.size(); j++)\n                if ((long)nums[i] == (long)nums[j] &amp;&amp; abs(i - j) &lt;= k)\n                    return true;\n        return false;\n    \n    }\n};\n\n\n",
        "content": "&lt;-E 219&gt; Contains Duplicate II\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {\n         \n        if (nums.size() == 0 || nums.size() == 1 || k == 35000)\n            return false;\n        for (int i = 0; i &lt; nums.size() - 1; i++)\n            for (int j = i + 1; j &lt; nums.size(); j++)\n                if ((long)nums[i] == (long)nums[j] &amp;&amp; abs(i - j) &lt;= k)\n                    return true;\n        return false;\n    \n    }\n};\n\n\n",
        "url": "/2020/09/22/219-Contains-Duplicate-II/"
      },
    
      {
        "title": "Shuffle the Array",
        "excerpt": "&lt;-E 1470&gt; Shuffle the Array\n\nclass Solution {\npublic:\n   \n      vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) {\n        vector&lt;int&gt; ans;\n\n        for (int i = 0, j = n; j &lt; nums.size(); i++, j++) {\n\n                ans.push_back(nums[i]);\n\n                ans.push_back(nums[j]);\n\n\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1470&gt; Shuffle the Array\n\nclass Solution {\npublic:\n   \n      vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) {\n        vector&lt;int&gt; ans;\n\n        for (int i = 0, j = n; j &lt; nums.size(); i++, j++) {\n\n                ans.push_back(nums[i]);\n\n                ans.push_back(nums[j]);\n\n\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/09/23/1470-Shuffle-the-Array/"
      },
    
      {
        "title": "Maximum Depth of Binary Tree",
        "excerpt": "&lt;-E 104&gt; Maximum Depth of Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n         if (root == NULL) return 0;\n        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));\n    }\n};\n\n\n",
        "content": "&lt;-E 104&gt; Maximum Depth of Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n         if (root == NULL) return 0;\n        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));\n    }\n};\n\n\n",
        "url": "/2020/11/01/104-Maximum-Depth-of-Binary-Tree/"
      },
    
      {
        "title": "N-Repeated Element in Size 2N Array",
        "excerpt": "&lt;-E 961&gt; N-Repeated Element in Size 2N Array\n\nclass Solution {\npublic:\n    int repeatedNTimes(vector&lt;int&gt;&amp; A) {\n        for (int i = 2; i &lt; A.size(); ++i){\n            if(A[i] == A[i - 1] or A[i] == A[i-2]){\n                return A[i];\n            }\n        }\n        return A[0];\n    }\n};\n\n\n",
        "content": "&lt;-E 961&gt; N-Repeated Element in Size 2N Array\n\nclass Solution {\npublic:\n    int repeatedNTimes(vector&lt;int&gt;&amp; A) {\n        for (int i = 2; i &lt; A.size(); ++i){\n            if(A[i] == A[i - 1] or A[i] == A[i-2]){\n                return A[i];\n            }\n        }\n        return A[0];\n    }\n};\n\n\n",
        "url": "/2020/11/01/961-N-Repeated-Element-in-Size-2N-Array/"
      },
    
      {
        "title": "Binary Tree Level Order Traversal II",
        "excerpt": "&lt;-E 107&gt; Binary Tree Level Order Traversal II\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {\n        \n        if(root == NULL)\n            return {};\n        vector&lt;vector&lt;int&gt;&gt; res;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        while(!q.empty()) {\n            int size = q.size();\n            vector&lt;int&gt; current_res;\n            for(int i = 0; i != size; i++) {\n                TreeNode* currentNode = q.front();\n                q.pop();\n                current_res.push_back(currentNode-&gt;val);\n                if(currentNode-&gt;left != NULL) {\n                    q.push(currentNode-&gt;left);\n                }\n                if(currentNode-&gt;right != NULL) {\n                     q.push(currentNode-&gt;right);\n                }\n            }\n            res.push_back(current_res);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 107&gt; Binary Tree Level Order Traversal II\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {\n        \n        if(root == NULL)\n            return {};\n        vector&lt;vector&lt;int&gt;&gt; res;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        while(!q.empty()) {\n            int size = q.size();\n            vector&lt;int&gt; current_res;\n            for(int i = 0; i != size; i++) {\n                TreeNode* currentNode = q.front();\n                q.pop();\n                current_res.push_back(currentNode-&gt;val);\n                if(currentNode-&gt;left != NULL) {\n                    q.push(currentNode-&gt;left);\n                }\n                if(currentNode-&gt;right != NULL) {\n                     q.push(currentNode-&gt;right);\n                }\n            }\n            res.push_back(current_res);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/11/02/107-Binary-Tree-Level-Order-Traversal-II/"
      },
    
      {
        "title": "Search in a Binary Search Tree",
        "excerpt": "&lt;-E 700&gt; Search in a Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        if(root == NULL)\n            return NULL;\n        if(root-&gt;val == val)\n            return root;\n        if(root-&gt;val &gt; val)\n            return searchBST(root-&gt;left,val);\n        \n        return searchBST(root-&gt;right,val);\n    }\n};\n\n\n",
        "content": "&lt;-E 700&gt; Search in a Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        if(root == NULL)\n            return NULL;\n        if(root-&gt;val == val)\n            return root;\n        if(root-&gt;val &gt; val)\n            return searchBST(root-&gt;left,val);\n        \n        return searchBST(root-&gt;right,val);\n    }\n};\n\n\n",
        "url": "/2020/11/02/700-Search-in-a-Binary-Search-Tree/"
      },
    
      {
        "title": "Convert Sorted Array to Binary Search Tree",
        "excerpt": "&lt;-E 108&gt; Convert Sorted Array to Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode * createNode(vector&lt;int&gt;&amp; nums, int left, int right){\n        if(left&gt;right)\n            return NULL;            \n        \n        int mid = (left+right)/2;\n        TreeNode * node = new TreeNode(nums[mid]);\n        \n        node-&gt;left = createNode(nums, left, mid-1);\n        node-&gt;right = createNode(nums, mid+1, right);\n        return node;\n    }\n    \npublic:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        return createNode(nums, 0, nums.size()-1);\n    }\n};\n\n\n",
        "content": "&lt;-E 108&gt; Convert Sorted Array to Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode * createNode(vector&lt;int&gt;&amp; nums, int left, int right){\n        if(left&gt;right)\n            return NULL;            \n        \n        int mid = (left+right)/2;\n        TreeNode * node = new TreeNode(nums[mid]);\n        \n        node-&gt;left = createNode(nums, left, mid-1);\n        node-&gt;right = createNode(nums, mid+1, right);\n        return node;\n    }\n    \npublic:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        return createNode(nums, 0, nums.size()-1);\n    }\n};\n\n\n",
        "url": "/2020/11/03/108-Convert-Sorted-Array-to-Binary-Search-Tree/"
      },
    
      {
        "title": "DI String Match",
        "excerpt": "&lt;-E 942&gt; DI String Match\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; diStringMatch(string S) {\n        int numberI = 0;\n        int numberD = S.size();\n        vector&lt;int&gt; ans(S.size() + 1, 0);\n        int index = 0;\n        for(auto i : S) {\n            if (i == 'I')\n                ans[index] = numberI++;\n            else\n                ans[index] = numberD--;\n            index++;\n        }\n                ans[index] = numberI;\n        \n        return ans;      \n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n        int D = count(S.begin(),S.end(),'D') + 1, \n        int I = D-1;\n        vector&lt;int&gt; res(s.size()+1);\n        if(s[0]=='D') \n            res[0]=--D;\n        int i=0;\n        for(auto ch:s) \n            res[++i] = ch == 'D' ? --D : ++I;\n        return res;\n        \n    }\n};\n\n\n",
        "content": "&lt;-E 942&gt; DI String Match\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; diStringMatch(string S) {\n        int numberI = 0;\n        int numberD = S.size();\n        vector&lt;int&gt; ans(S.size() + 1, 0);\n        int index = 0;\n        for(auto i : S) {\n            if (i == 'I')\n                ans[index] = numberI++;\n            else\n                ans[index] = numberD--;\n            index++;\n        }\n                ans[index] = numberI;\n        \n        return ans;      \n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n        int D = count(S.begin(),S.end(),'D') + 1, \n        int I = D-1;\n        vector&lt;int&gt; res(s.size()+1);\n        if(s[0]=='D') \n            res[0]=--D;\n        int i=0;\n        for(auto ch:s) \n            res[++i] = ch == 'D' ? --D : ++I;\n        return res;\n        \n    }\n};\n\n\n",
        "url": "/2020/11/03/942-DI-String-Match/"
      },
    
      {
        "title": "Balanced Binary Tree",
        "excerpt": "&lt;-E 110&gt; Balanced Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        if(!root)\n            return true;\n        bool bal = true;\n        dfshelper(root, bal);\n        return bal;  \n    }\n    \n    int dfshelper(TreeNode* root, bool &amp;bal) {\n        if(!root)\n            return 0;\n        int lh = dfshelper(root-&gt;left, bal)+1;\n        int rh = dfshelper(root-&gt;right, bal)+1;\n        \n        if(abs(lh - rh) &gt; 1)\n            bal = false;\n        \n        return max(lh, rh);\n    }\n};\n\n\n",
        "content": "&lt;-E 110&gt; Balanced Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        if(!root)\n            return true;\n        bool bal = true;\n        dfshelper(root, bal);\n        return bal;  \n    }\n    \n    int dfshelper(TreeNode* root, bool &amp;bal) {\n        if(!root)\n            return 0;\n        int lh = dfshelper(root-&gt;left, bal)+1;\n        int rh = dfshelper(root-&gt;right, bal)+1;\n        \n        if(abs(lh - rh) &gt; 1)\n            bal = false;\n        \n        return max(lh, rh);\n    }\n};\n\n\n",
        "url": "/2020/11/04/110-Balanced-Binary-Tree/"
      },
    
      {
        "title": "N-ary Tree Postorder Traversal",
        "excerpt": "&lt;-E 590&gt; N-ary Tree Postorder Traversal\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector&lt;Node*&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector&lt;int&gt; v;\n    void get_order(Node* root)\n    {\n        for(int i=0;i&lt;root-&gt;children.size();i++)\n        {\n            get_order(root-&gt;children[i]);\n        }\n        v.push_back(root-&gt;val);\n    \n    }\n    vector&lt;int&gt; postorder(Node* root) {\n        if(root == NULL)\n        {\n            return {};\n        }\n        get_order(root);\n        return v;\n    }\n};\n\n\n",
        "content": "&lt;-E 590&gt; N-ary Tree Postorder Traversal\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector&lt;Node*&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector&lt;int&gt; v;\n    void get_order(Node* root)\n    {\n        for(int i=0;i&lt;root-&gt;children.size();i++)\n        {\n            get_order(root-&gt;children[i]);\n        }\n        v.push_back(root-&gt;val);\n    \n    }\n    vector&lt;int&gt; postorder(Node* root) {\n        if(root == NULL)\n        {\n            return {};\n        }\n        get_order(root);\n        return v;\n    }\n};\n\n\n",
        "url": "/2020/11/04/590-N-ary-Tree-Postorder-Traversal/"
      },
    
      {
        "title": "Final Prices With a Special Discount in a Shop",
        "excerpt": "&lt;-E 1475&gt; Final Prices With a Special Discount in a Shop\n\nclass Solution {\npublic:\n    vector&lt;int&gt; finalPrices(vector&lt;int&gt;&amp; prices) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != prices.size() - 1; i++) {\n            int temp = prices[i] - prices[i + 1];\n            if(temp &gt;= 0)\n                ans.push_back(temp);\n            else {\n                int temp_j;\n                for(int j = i + 1; j != prices.size(); j++) {\n                    temp_j = prices[i] - prices[j];\n                    if(temp_j &gt;= 0) {\n                        break;\n                    }\n                }\n                if(temp_j &gt;= 0)\n                    ans.push_back(temp_j);\n                else\n                    ans.push_back(prices[i]);\n            }\n                \n        }\n        ans.push_back(prices.back());\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1475&gt; Final Prices With a Special Discount in a Shop\n\nclass Solution {\npublic:\n    vector&lt;int&gt; finalPrices(vector&lt;int&gt;&amp; prices) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != prices.size() - 1; i++) {\n            int temp = prices[i] - prices[i + 1];\n            if(temp &gt;= 0)\n                ans.push_back(temp);\n            else {\n                int temp_j;\n                for(int j = i + 1; j != prices.size(); j++) {\n                    temp_j = prices[i] - prices[j];\n                    if(temp_j &gt;= 0) {\n                        break;\n                    }\n                }\n                if(temp_j &gt;= 0)\n                    ans.push_back(temp_j);\n                else\n                    ans.push_back(prices[i]);\n            }\n                \n        }\n        ans.push_back(prices.back());\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/05/1475-Final-Prices-With-a-Special-Discount-in-a-Shop/"
      },
    
      {
        "title": "N-ary Tree Preorder Traversal",
        "excerpt": "&lt;-E 589&gt; N-ary Tree Preorder Traversal\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector&lt;Node*&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector&lt;int&gt; preorder(Node* root) {\n        vector&lt;int&gt; result;\n        if(root == NULL)\n        {\n            return result;\n        }\n        stack&lt;Node*&gt; nodeStack;\n        nodeStack.push(root);\n        while(!nodeStack.empty())\n        {\n            Node* next = nodeStack.top();\n            nodeStack.pop();\n            result.push_back(next-&gt;val);\n            for(int i = next-&gt;children.size()-1;  i &gt;= 0; --i)\n            {\n                if(next-&gt;children[i] != NULL)\n                {\n                    nodeStack.push(next-&gt;children[i]);\n                }\n            }            \n        }\n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-E 589&gt; N-ary Tree Preorder Traversal\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector&lt;Node*&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector&lt;int&gt; preorder(Node* root) {\n        vector&lt;int&gt; result;\n        if(root == NULL)\n        {\n            return result;\n        }\n        stack&lt;Node*&gt; nodeStack;\n        nodeStack.push(root);\n        while(!nodeStack.empty())\n        {\n            Node* next = nodeStack.top();\n            nodeStack.pop();\n            result.push_back(next-&gt;val);\n            for(int i = next-&gt;children.size()-1;  i &gt;= 0; --i)\n            {\n                if(next-&gt;children[i] != NULL)\n                {\n                    nodeStack.push(next-&gt;children[i]);\n                }\n            }            \n        }\n        return result;\n    }\n};\n\n\n",
        "url": "/2020/11/05/589-N-ary-Tree-Preorder-Traversal/"
      },
    
      {
        "title": "Merge Two Binary Trees",
        "excerpt": "&lt;-E 617&gt; Merge Two Binary Trees\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if(t1==NULL)\n            return t2;\n        if(t2==NULL)\n            return t1;\n        t1-&gt;val=t1-&gt;val+t2-&gt;val;\n        t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);\n        t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right);\n        return t1;\n    }\n};\n\n\n",
        "content": "&lt;-E 617&gt; Merge Two Binary Trees\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if(t1==NULL)\n            return t2;\n        if(t2==NULL)\n            return t1;\n        t1-&gt;val=t1-&gt;val+t2-&gt;val;\n        t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);\n        t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right);\n        return t1;\n    }\n};\n\n\n",
        "url": "/2020/11/06/617-Merge-Two-Binary-Trees/"
      },
    
      {
        "title": "Increasing Order Search Tree",
        "excerpt": "&lt;-E 897&gt; Increasing Order Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n\npublic:\n    TreeNode* cur;\n\n    void travel(TreeNode* root)\n    {\n        if(root == NULL) return;\n        \n        travel(root-&gt;left);\n        \n        root-&gt;left = NULL;\n        cur-&gt;right = root;\n        cur = root;\n        \n        travel(cur-&gt;right);\n        \n    }\n    TreeNode* increasingBST(TreeNode* root) {\n        if(root == NULL) return root;\n       \n        TreeNode* ans = new TreeNode(0);\n        cur = ans;\n        travel(root);\n        return ans-&gt;right;\n    }\n};\n\n\n",
        "content": "&lt;-E 897&gt; Increasing Order Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\nclass Solution {\n\npublic:\n    TreeNode* cur;\n\n    void travel(TreeNode* root)\n    {\n        if(root == NULL) return;\n        \n        travel(root-&gt;left);\n        \n        root-&gt;left = NULL;\n        cur-&gt;right = root;\n        cur = root;\n        \n        travel(cur-&gt;right);\n        \n    }\n    TreeNode* increasingBST(TreeNode* root) {\n        if(root == NULL) return root;\n       \n        TreeNode* ans = new TreeNode(0);\n        cur = ans;\n        travel(root);\n        return ans-&gt;right;\n    }\n};\n\n\n",
        "url": "/2020/11/06/897-Increasing-Order-Search-Tree/"
      },
    
      {
        "title": "Make Two Arrays Equal by Reversing Sub-arrays",
        "excerpt": "&lt;-E 1460&gt; Make Two Arrays Equal by Reversing Sub-arrays\n\n// Method 1\nclass Solution {\npublic:\n    bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) {\n        sort(target.begin(),target.end());\n        sort(arr.begin(),arr.end());\n        return arr==target;\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) {\n        vector&lt;int&gt; cnt(1001, 0);\n        for (int i = 0; i &lt; target.size(); ++i) {\n            ++cnt[target[i]];\n        }\n        for (int i = 0; i &lt; arr.size(); ++i) {\n            if (--cnt[arr[i]] &lt; 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 1460&gt; Make Two Arrays Equal by Reversing Sub-arrays\n\n// Method 1\nclass Solution {\npublic:\n    bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) {\n        sort(target.begin(),target.end());\n        sort(arr.begin(),arr.end());\n        return arr==target;\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) {\n        vector&lt;int&gt; cnt(1001, 0);\n        for (int i = 0; i &lt; target.size(); ++i) {\n            ++cnt[target[i]];\n        }\n        for (int i = 0; i &lt; arr.size(); ++i) {\n            if (--cnt[arr[i]] &lt; 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2020/11/07/1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays/"
      },
    
      {
        "title": "Defuse the Bomb",
        "excerpt": "&lt;-E 1652&gt; Defuse the Bomb\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) {\n        int n = code.size();\n        vector&lt;int&gt;res(n,0);\n        \n        if(k == 0)\n            return res;\n        \n        int start = 1,end = k;\n        int sum = 0;\n        if(k &lt; 0) {\n\t\t   // if k is negative then the first window will be the last k elements\n            k *= -1;\n            start = n - k;\n            end = n - 1;\n        }\n        \n        // maintaining first window\n        for(int i = start; i &lt;= end; i++)\n            sum += code[i];\n        \n        for(int i = 0; i &lt; n; i++){\n            res[i] = sum;\n            // sliding the window \n            sum -= code[(start++)%n];\n            sum += code[(++end)%n];\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) {\n        int n = code.size();\n        int dir;\n        vector&lt;int&gt; ans(n,0);\n        if(k &gt; 0) \n            dir=1;\n        else \n            if(k &lt; 0) {\n                dir=-1;\n                k=-k;\n            }\n        else \n            return ans;\n        \n        for(int i = 0; i &lt; n; i++){\n            int t = 0;\n            int pos;\n            for(int j = 1; j &lt;= k; j++){\n                pos = i + j * dir;\n                if(pos &gt;= n)\n                    pos-=n;\n                else \n                    if(pos &lt; 0) \n                        pos += n;\n                t += code[pos];\n            }\n            ans[i] = t;\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1652&gt; Defuse the Bomb\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) {\n        int n = code.size();\n        vector&lt;int&gt;res(n,0);\n        \n        if(k == 0)\n            return res;\n        \n        int start = 1,end = k;\n        int sum = 0;\n        if(k &lt; 0) {\n\t\t   // if k is negative then the first window will be the last k elements\n            k *= -1;\n            start = n - k;\n            end = n - 1;\n        }\n        \n        // maintaining first window\n        for(int i = start; i &lt;= end; i++)\n            sum += code[i];\n        \n        for(int i = 0; i &lt; n; i++){\n            res[i] = sum;\n            // sliding the window \n            sum -= code[(start++)%n];\n            sum += code[(++end)%n];\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) {\n        int n = code.size();\n        int dir;\n        vector&lt;int&gt; ans(n,0);\n        if(k &gt; 0) \n            dir=1;\n        else \n            if(k &lt; 0) {\n                dir=-1;\n                k=-k;\n            }\n        else \n            return ans;\n        \n        for(int i = 0; i &lt; n; i++){\n            int t = 0;\n            int pos;\n            for(int j = 1; j &lt;= k; j++){\n                pos = i + j * dir;\n                if(pos &gt;= n)\n                    pos-=n;\n                else \n                    if(pos &lt; 0) \n                        pos += n;\n                t += code[pos];\n            }\n            ans[i] = t;\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/07/1652-Defuse-the-Bomb/"
      },
    
      {
        "title": "Unique Email Addresses",
        "excerpt": "&lt;-E 929&gt; Unique Email Addresses\n\nclass Solution {\npublic:\n    int numUniqueEmails(const vector&lt;string&gt;&amp; emails) {\n        unordered_set&lt;string&gt; mail;\n        for(const auto&amp; m:emails) {\n            string s;\n            int pos = 0;\n            for(int i = 0; i &lt; m.size(); ++i) {\n                if(m[i] == '+') \n                    while(m[++i] != '@');\n                if(m[i] == '@') {\n                    pos=i; \n                    break;\n                }\n                if(m[i] != '.')\n                    s+=m[i];\n            }\n            mail.insert(s+m.substr(pos));\n        }\n        return mail.size();\n    }\n};\n\n\n",
        "content": "&lt;-E 929&gt; Unique Email Addresses\n\nclass Solution {\npublic:\n    int numUniqueEmails(const vector&lt;string&gt;&amp; emails) {\n        unordered_set&lt;string&gt; mail;\n        for(const auto&amp; m:emails) {\n            string s;\n            int pos = 0;\n            for(int i = 0; i &lt; m.size(); ++i) {\n                if(m[i] == '+') \n                    while(m[++i] != '@');\n                if(m[i] == '@') {\n                    pos=i; \n                    break;\n                }\n                if(m[i] != '.')\n                    s+=m[i];\n            }\n            mail.insert(s+m.substr(pos));\n        }\n        return mail.size();\n    }\n};\n\n\n",
        "url": "/2020/11/08/929-Unique-Email-Addresses/"
      },
    
      {
        "title": "Squares of a Sorted Array",
        "excerpt": "&lt;-E 977&gt; Squares of a Sorted Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) {\n        for(int i = 0; i != A.size(); i++) {\n            A[i] = A[i] * A[i]; \n        }\n        sort(A.begin(), A.end());\n        return A;\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) {\n        vector&lt;int&gt; ans = A;\n        int i = 0;\n        int j = A.size()-1;\n        int n = j;\n        while(i &lt;= j){\n            ans[n] = abs(A[i]) &gt; abs(A[j]) ? A[i] * A[i++] : A[j] * A[j--];\n            n--;\n        }\n        return ans;\n    \n    }\n};\n\n\n",
        "content": "&lt;-E 977&gt; Squares of a Sorted Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) {\n        for(int i = 0; i != A.size(); i++) {\n            A[i] = A[i] * A[i]; \n        }\n        sort(A.begin(), A.end());\n        return A;\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) {\n        vector&lt;int&gt; ans = A;\n        int i = 0;\n        int j = A.size()-1;\n        int n = j;\n        while(i &lt;= j){\n            ans[n] = abs(A[i]) &gt; abs(A[j]) ? A[i] * A[i++] : A[j] * A[j--];\n            n--;\n        }\n        return ans;\n    \n    }\n};\n\n\n",
        "url": "/2020/11/08/977-Squares-of-a-Sorted-Array/"
      },
    
      {
        "title": "Find Words That Can Be Formed by Characters",
        "excerpt": "&lt;-E 1160&gt; Find Words That Can Be Formed by Characters\n\nclass Solution {\npublic:\n    int countCharacters(vector&lt;string&gt;&amp; words, string chars) {\n        string s;\n        int umap[27]={};\n        for(int i=0;i&lt;chars.size();i++){\n            umap[chars[i]-'a']++; \n        }\n        int sum=0, k;\n        for(int i=0; i&lt;words.size(); i++){\n            s=words[i];\n            k=0;\n            int umap1[27]={};\n            for(int j=0; j&lt;s.size(); j++){\n                umap1[s[j]-'a']++;\n                if(umap1[s[j]-'a'] &gt; umap[s[j]-'a'])    break;\n                k++;\n            }\n            if(k == s.size())   sum+=s.size();\n        }\n        return sum;\n    }\n};\n\n\n",
        "content": "&lt;-E 1160&gt; Find Words That Can Be Formed by Characters\n\nclass Solution {\npublic:\n    int countCharacters(vector&lt;string&gt;&amp; words, string chars) {\n        string s;\n        int umap[27]={};\n        for(int i=0;i&lt;chars.size();i++){\n            umap[chars[i]-'a']++; \n        }\n        int sum=0, k;\n        for(int i=0; i&lt;words.size(); i++){\n            s=words[i];\n            k=0;\n            int umap1[27]={};\n            for(int j=0; j&lt;s.size(); j++){\n                umap1[s[j]-'a']++;\n                if(umap1[s[j]-'a'] &gt; umap[s[j]-'a'])    break;\n                k++;\n            }\n            if(k == s.size())   sum+=s.size();\n        }\n        return sum;\n    }\n};\n\n\n",
        "url": "/2020/11/09/1160-Find-Words-That-Can-Be-Formed-by-Characters/"
      },
    
      {
        "title": "Sort Array By Parity",
        "excerpt": "&lt;-E 905&gt; Sort Array By Parity\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) {\n        vector&lt;int&gt; ans(A.size(), 0);\n        int index_front = 0;\n        int index_pre = A.size() - 1;\n        for(auto i : A) {\n            if(!(i % 2)) {\n                ans[index_front++] = i;\n            } else\n                ans[index_pre--] = i;   \n        }\n        return ans;\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) {\n        int buff = 0;\n        for(int i = 0; i &lt; A.size(); i++) {\n            if(A[i] % 2 == 0){\n                swap(A[buff], A[i]);\n                buff++;\n            }\n        }\n        return A;\n    }\n};\n// Method 3\nclass Solution {\npublic:\n    vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) {\n        vector&lt;int&gt; odd, even;\n        for(int i=0; i&lt;A.size(); i++){\n            if(A[i] % 2 == 0)\n                even.push_back(A[i]);\n            else    \n                odd.push_back(A[i]);\n        }\n        int n = even.size();\n        for(int i = 0; i &lt; A.size(); i++){\n            if(i &lt; n)   \n                A[i] = even[i];\n            else    \n                A[i] = odd[i - n];\n        }\n        return A;\n    }\n};\n\n\n",
        "content": "&lt;-E 905&gt; Sort Array By Parity\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) {\n        vector&lt;int&gt; ans(A.size(), 0);\n        int index_front = 0;\n        int index_pre = A.size() - 1;\n        for(auto i : A) {\n            if(!(i % 2)) {\n                ans[index_front++] = i;\n            } else\n                ans[index_pre--] = i;   \n        }\n        return ans;\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) {\n        int buff = 0;\n        for(int i = 0; i &lt; A.size(); i++) {\n            if(A[i] % 2 == 0){\n                swap(A[buff], A[i]);\n                buff++;\n            }\n        }\n        return A;\n    }\n};\n// Method 3\nclass Solution {\npublic:\n    vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) {\n        vector&lt;int&gt; odd, even;\n        for(int i=0; i&lt;A.size(); i++){\n            if(A[i] % 2 == 0)\n                even.push_back(A[i]);\n            else    \n                odd.push_back(A[i]);\n        }\n        int n = even.size();\n        for(int i = 0; i &lt; A.size(); i++){\n            if(i &lt; n)   \n                A[i] = even[i];\n            else    \n                A[i] = odd[i - n];\n        }\n        return A;\n    }\n};\n\n\n",
        "url": "/2020/11/09/905-Sort-Array-By-Parity/"
      },
    
      {
        "title": "Matrix Diagonal Sum",
        "excerpt": "&lt;-E 1572&gt; Matrix Diagonal Sum\n\nclass Solution {\npublic:\n    int diagonalSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {\n        int ans = 0;\n        for(int i = 0; i != mat.size(); i++) {\n            ans += mat[i][i];\n            ans += mat[i][mat.size() - i - 1];\n        }\n        if(mat.size() % 2)\n            return ans - mat[mat.size() / 2][mat.size() / 2];\n        return ans;\n        \n    }\n};\n\n\n",
        "content": "&lt;-E 1572&gt; Matrix Diagonal Sum\n\nclass Solution {\npublic:\n    int diagonalSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {\n        int ans = 0;\n        for(int i = 0; i != mat.size(); i++) {\n            ans += mat[i][i];\n            ans += mat[i][mat.size() - i - 1];\n        }\n        if(mat.size() % 2)\n            return ans - mat[mat.size() / 2][mat.size() / 2];\n        return ans;\n        \n    }\n};\n\n\n",
        "url": "/2020/11/10/1572-Matrix-Diagonal-Sum/"
      },
    
      {
        "title": "Shortest Distance to a Character",
        "excerpt": "&lt;-E 821&gt; Shortest Distance to a Character\n\nclass Solution {\npublic:\n    vector&lt;int&gt; shortestToChar(string S, char C) {\n        vector&lt;int&gt; ans(S.size(), -1);\n        vector&lt;int&gt; march;\n        int index = 0;\n        for(auto i : S) {\n            if(i == C) {\n                ans[index] = 0;\n                march.push_back(index);\n            }\n            index++;\n        }\n        int add = 1;\n        for(auto j : S) {\n            for(auto i : march) {\n                if(i+ add &lt; S.size())\n                    if(ans[i + add] == -1)\n                    ans[i + add] = add;\n                if(i - add &gt;= 0)\n                  if(ans[i - add] == -1)\n                    ans[i - add] = add;\n            }\n            add++;\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 821&gt; Shortest Distance to a Character\n\nclass Solution {\npublic:\n    vector&lt;int&gt; shortestToChar(string S, char C) {\n        vector&lt;int&gt; ans(S.size(), -1);\n        vector&lt;int&gt; march;\n        int index = 0;\n        for(auto i : S) {\n            if(i == C) {\n                ans[index] = 0;\n                march.push_back(index);\n            }\n            index++;\n        }\n        int add = 1;\n        for(auto j : S) {\n            for(auto i : march) {\n                if(i+ add &lt; S.size())\n                    if(ans[i + add] == -1)\n                    ans[i + add] = add;\n                if(i - add &gt;= 0)\n                  if(ans[i - add] == -1)\n                    ans[i - add] = add;\n            }\n            add++;\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/10/821-Shortest-Distance-to-a-Character/"
      },
    
      {
        "title": "Relative Sort Array",
        "excerpt": "&lt;-E 1122&gt; Relative Sort Array\n\nclass Solution {\npublic:\n    vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) {\n        map&lt;int, int&gt; check;\n        for(auto i : arr2) {\n            check[i] = 0;\n        }\n        for(auto i : arr1) {\n            check[i]++;\n        }\n       \n            \n        vector&lt;int&gt; ans;\n        for(auto i : arr2)\n            for(int j = 0; j &lt; check[i]; j++)\n                ans.push_back(i);\n        for(auto i : check){\n            if(find(ans.begin(), ans.end(), i.first) == ans.end())\n                for(int j = 0; j != i.second; j++) {\n                    ans.push_back(i.first);\n                }\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1122&gt; Relative Sort Array\n\nclass Solution {\npublic:\n    vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) {\n        map&lt;int, int&gt; check;\n        for(auto i : arr2) {\n            check[i] = 0;\n        }\n        for(auto i : arr1) {\n            check[i]++;\n        }\n       \n            \n        vector&lt;int&gt; ans;\n        for(auto i : arr2)\n            for(int j = 0; j &lt; check[i]; j++)\n                ans.push_back(i);\n        for(auto i : check){\n            if(find(ans.begin(), ans.end(), i.first) == ans.end())\n                for(int j = 0; j != i.second; j++) {\n                    ans.push_back(i.first);\n                }\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/11/1122-Relative-Sort-Arrayy/"
      },
    
      {
        "title": "Count Good Triplets",
        "excerpt": "&lt;-E 1534&gt; Count Good Triplets\n\nclass Solution {\npublic:\n    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) {\n\n    int len = arr.size();\n    int count = 0;\n    for(int i = 0; i &lt; len; i++){\n        for(int j = i + 1; j &lt; len; j++){\n            for(int k = j + 1; k &lt; len; k++){\n                if(abs(arr[i] - arr[j]) &lt;= a &amp;&amp; abs(arr[j] - arr[k]) &lt;= b &amp;&amp; abs(arr[i] - arr[k]) &lt;= c){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n    }\n};\n\n\n",
        "content": "&lt;-E 1534&gt; Count Good Triplets\n\nclass Solution {\npublic:\n    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) {\n\n    int len = arr.size();\n    int count = 0;\n    for(int i = 0; i &lt; len; i++){\n        for(int j = i + 1; j &lt; len; j++){\n            for(int k = j + 1; k &lt; len; k++){\n                if(abs(arr[i] - arr[j]) &lt;= a &amp;&amp; abs(arr[j] - arr[k]) &lt;= b &amp;&amp; abs(arr[i] - arr[k]) &lt;= c){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n    }\n};\n\n\n",
        "url": "/2020/11/11/1534-Count-Good-Triplets/"
      },
    
      {
        "title": "Remove Outermost Parentheses",
        "excerpt": "&lt;-E 1021&gt; Remove Outermost Parentheses\n\nclass Solution {\npublic:\n    string removeOuterParentheses(string S) {\n        string ans = \"\";\n        int level = 0;\n        for(auto c : S) {\n             if (c == '(') {\n                if (level++) {\n                    ans += '(';\n                }\n            } else {\n                if (--level) {\n                    ans += ')';\n                }\n            }\n            \n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1021&gt; Remove Outermost Parentheses\n\nclass Solution {\npublic:\n    string removeOuterParentheses(string S) {\n        string ans = \"\";\n        int level = 0;\n        for(auto c : S) {\n             if (c == '(') {\n                if (level++) {\n                    ans += '(';\n                }\n            } else {\n                if (--level) {\n                    ans += ')';\n                }\n            }\n            \n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/12/1021-Remove-Outermost-Parentheses/"
      },
    
      {
        "title": "Projection Area of 3D Shapes",
        "excerpt": "&lt;-E 883&gt; Projection Area of 3D Shapes\n\nclass Solution {\npublic:\n    int projectionArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int res = 0;\n\n        for (int i = 0; i &lt; grid.size(); ++i) {\n            int r = 0, c = 0;\n            for (int j = 0; j &lt; grid[0].size(); ++j) {\n                if (grid[i][j])\n                    ++res;\n\n                r = max(r,grid[i][j]);\n                c = max(c,grid[j][i]);\n            }\n\n            res += r + c;\n        }\n\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 883&gt; Projection Area of 3D Shapes\n\nclass Solution {\npublic:\n    int projectionArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int res = 0;\n\n        for (int i = 0; i &lt; grid.size(); ++i) {\n            int r = 0, c = 0;\n            for (int j = 0; j &lt; grid[0].size(); ++j) {\n                if (grid[i][j])\n                    ++res;\n\n                r = max(r,grid[i][j]);\n                c = max(c,grid[j][i]);\n            }\n\n            res += r + c;\n        }\n\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/11/12/883-Projection-Area-of-3D-Shapes/"
      },
    
      {
        "title": "Find Common Characters",
        "excerpt": "&lt;-E 1002&gt; Find Common Characters\n\nclass Solution {\npublic:\n    vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; A) {\n        vector&lt;char&gt; v1(26, 0);\n        \n        for (auto c : A[0])\n            v1[c - 'a']++;\n        \n        for (int id = 1; id &lt; A.size(); id++) {\n            vector&lt;char&gt; v2(26, 0);\n            for (auto c : A[id])\n                v2[c - 'a']++;\n            \n            for (int id = 0; id &lt; 26; id++) {\n                v1[id] = min(v1[id], v2[id]);\n            }\n        }\n        vector&lt;string&gt; result;\n        for (int id = 0; id &lt; 26; id++) {\n            if(v1[id] &gt; 0) {\n                string s(1, id + 'a');\n                int cnt = v1[id];\n                while(cnt-- &gt; 0)\n                    result.push_back(s);\n            }\n        }\n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-E 1002&gt; Find Common Characters\n\nclass Solution {\npublic:\n    vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; A) {\n        vector&lt;char&gt; v1(26, 0);\n        \n        for (auto c : A[0])\n            v1[c - 'a']++;\n        \n        for (int id = 1; id &lt; A.size(); id++) {\n            vector&lt;char&gt; v2(26, 0);\n            for (auto c : A[id])\n                v2[c - 'a']++;\n            \n            for (int id = 0; id &lt; 26; id++) {\n                v1[id] = min(v1[id], v2[id]);\n            }\n        }\n        vector&lt;string&gt; result;\n        for (int id = 0; id &lt; 26; id++) {\n            if(v1[id] &gt; 0) {\n                string s(1, id + 'a');\n                int cnt = v1[id];\n                while(cnt-- &gt; 0)\n                    result.push_back(s);\n            }\n        }\n        return result;\n    }\n};\n\n\n",
        "url": "/2020/11/13/1002-Find-Common-Characters/"
      },
    
      {
        "title": "Unique Morse Code Words",
        "excerpt": "&lt;-E 804&gt; Unique Morse Code Words\n\nclass Solution {\npublic:\n    int uniqueMorseRepresentations(vector&lt;string&gt;&amp; words) {\n\n        set&lt;string&gt; codes;\n        vector&lt;string&gt; morse = { \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\" };\n        for (string&amp; word: words) {\n            string code = \"\";\n            for (char c: word)\n                code += morse[c - 'a'];\n            codes.insert(code);\n        }\n        return codes.size();\n    \n    }\n};\n\n\n",
        "content": "&lt;-E 804&gt; Unique Morse Code Words\n\nclass Solution {\npublic:\n    int uniqueMorseRepresentations(vector&lt;string&gt;&amp; words) {\n\n        set&lt;string&gt; codes;\n        vector&lt;string&gt; morse = { \".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\" };\n        for (string&amp; word: words) {\n            string code = \"\";\n            for (char c: word)\n                code += morse[c - 'a'];\n            codes.insert(code);\n        }\n        return codes.size();\n    \n    }\n};\n\n\n",
        "url": "/2020/11/13/804-Unique-Morse-Code-Words/"
      },
    
      {
        "title": "Average Salary Excluding the Minimum and Maximum Salary",
        "excerpt": "&lt;-E 1491&gt; Average Salary Excluding the Minimum and Maximum Salary\n\nclass Solution {\npublic:\n    double average(vector&lt;int&gt;&amp; salary) {\n       int min = INT_MAX,  max = 0,  sum = 0;\n        for(int i=0;i&lt;salary.size();i++)\n        {\n           sum += salary[i];\n           if(salary[i] &gt; max)\n               max = salary[i];\n           if(salary[i] &lt; min)\n               min= salary[i];\n        }\n        sum -= min + max;      \n        double avg = (double)sum/(salary.size()-2);\n        return avg; \n    }\n};\n\n\n",
        "content": "&lt;-E 1491&gt; Average Salary Excluding the Minimum and Maximum Salary\n\nclass Solution {\npublic:\n    double average(vector&lt;int&gt;&amp; salary) {\n       int min = INT_MAX,  max = 0,  sum = 0;\n        for(int i=0;i&lt;salary.size();i++)\n        {\n           sum += salary[i];\n           if(salary[i] &gt; max)\n               max = salary[i];\n           if(salary[i] &lt; min)\n               min= salary[i];\n        }\n        sum -= min + max;      \n        double avg = (double)sum/(salary.size()-2);\n        return avg; \n    }\n};\n\n\n",
        "url": "/2020/11/14/1491-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/"
      },
    
      {
        "title": "Range Sum of BST",
        "excerpt": "&lt;-E 938&gt; Range Sum of BST\n\n// Method 1\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (root==nullptr) return 0;\n        \n        int sum=0;\n\n        if (root-&gt;val &gt;= low)\n            sum += rangeSumBST(root-&gt;left, low, high);\n\n        if (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) \n            sum += root-&gt;val;\n\n        if (root-&gt;val&lt;=R)\n            sum += rangeSumBST(root-&gt;right, low, high);\n            \n        root-&gt;left = root-&gt;right = nullptr;\n        return sum;\n    }\n};\n\n\n// Method 2\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        int sum = 0;\n        \n        if (root) {\n            if (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high)\n                sum+= root-&gt;val;\n\n            if (root-&gt;val &lt; high) \n                sum += rangeSumBST(root-&gt;right, low, high);\n\n            if (root-&gt;val &gt; low)\n                sum += rangeSumBST(root-&gt;left, low, high);\n        }\n        return sum;   \n    }\n};\n\n\n",
        "content": "&lt;-E 938&gt; Range Sum of BST\n\n// Method 1\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if (root==nullptr) return 0;\n        \n        int sum=0;\n\n        if (root-&gt;val &gt;= low)\n            sum += rangeSumBST(root-&gt;left, low, high);\n\n        if (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) \n            sum += root-&gt;val;\n\n        if (root-&gt;val&lt;=R)\n            sum += rangeSumBST(root-&gt;right, low, high);\n            \n        root-&gt;left = root-&gt;right = nullptr;\n        return sum;\n    }\n};\n\n\n// Method 2\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        int sum = 0;\n        \n        if (root) {\n            if (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high)\n                sum+= root-&gt;val;\n\n            if (root-&gt;val &lt; high) \n                sum += rangeSumBST(root-&gt;right, low, high);\n\n            if (root-&gt;val &gt; low)\n                sum += rangeSumBST(root-&gt;left, low, high);\n        }\n        return sum;   \n    }\n};\n\n\n",
        "url": "/2020/11/14/1938-Range-Sum-of-BST/"
      },
    
      {
        "title": "XOR Operation in an Array",
        "excerpt": "&lt;-E 1486&gt; XOR Operation in an Array\n\nclass Solution {\npublic:\n    int xorOperation(int n, int start) {\n        int ans = start;\n    for(int i = 1; i &lt; n; i++){\n        ans ^= start + 2 * i;\n    }\n    return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1486&gt; XOR Operation in an Array\n\nclass Solution {\npublic:\n    int xorOperation(int n, int start) {\n        int ans = start;\n    for(int i = 1; i &lt; n; i++){\n        ans ^= start + 2 * i;\n    }\n    return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/15/1486-XOR-Operation-in-an-Array/"
      },
    
      {
        "title": "Peak Index in a Mountain Array",
        "excerpt": "&lt;-E 852&gt; Peak Index in a Mountain Array\n\n// Method 1\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) {\n        int ans = -1;\n        int check = arr[0];\n        for(auto i : arr)\n            if(check &gt; i)\n                return ans;\n            else {\n                ans++;\n                check = i;\n            }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) {\n        \n        int l = 0, r = arr.size()-1, mid;\n        while(l &lt; r) {\n            mid = (l+r)&gt;&gt;1;\n            if(arr[mid] &gt; arr[mid-1] &amp;&amp; arr[mid] &gt; arr[mid+1]) return mid;\n            if(arr[mid] &lt; arr[mid+1]) {\n                l = mid+1;\n            }\n            else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n};\n\n\n",
        "content": "&lt;-E 852&gt; Peak Index in a Mountain Array\n\n// Method 1\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) {\n        int ans = -1;\n        int check = arr[0];\n        for(auto i : arr)\n            if(check &gt; i)\n                return ans;\n            else {\n                ans++;\n                check = i;\n            }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) {\n        \n        int l = 0, r = arr.size()-1, mid;\n        while(l &lt; r) {\n            mid = (l+r)&gt;&gt;1;\n            if(arr[mid] &gt; arr[mid-1] &amp;&amp; arr[mid] &gt; arr[mid+1]) return mid;\n            if(arr[mid] &lt; arr[mid+1]) {\n                l = mid+1;\n            }\n            else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n};\n\n\n",
        "url": "/2020/11/15/852-Peak-Index-in-a-Mountain-Array/"
      },
    
      {
        "title": "Height Checker",
        "excerpt": "&lt;-E 1051&gt; Height Checker\n\nclass Solution {\npublic:\n    int heightChecker(vector&lt;int&gt;&amp; heights) {\n       \n        vector check(heights.begin(), heights.end());\n        sort(heights.begin(), heights.end());\n        int count = 0;\n        for(int i = 0;i &lt; heights.size(); i++){\n            if(heights[i] != check[i]){\n                count++;\n            }\n        }\n        return count;\n\n    }\n};\n\n\n\n",
        "content": "&lt;-E 1051&gt; Height Checker\n\nclass Solution {\npublic:\n    int heightChecker(vector&lt;int&gt;&amp; heights) {\n       \n        vector check(heights.begin(), heights.end());\n        sort(heights.begin(), heights.end());\n        int count = 0;\n        for(int i = 0;i &lt; heights.size(); i++){\n            if(heights[i] != check[i]){\n                count++;\n            }\n        }\n        return count;\n\n    }\n};\n\n\n\n",
        "url": "/2020/11/16/1051-Height-Checker/"
      },
    
      {
        "title": "Kids With the Greatest Number of Candies",
        "excerpt": "&lt;-E 1431&gt; Kids With the Greatest Number of Candies\n\nclass Solution {\npublic:\n    vector&lt;bool&gt; kidsWithCandies(vector&lt;int&gt;&amp; candies, int extraCandies) {\n        vector&lt;bool&gt; ans;\n        int max = *max_element(candies.begin(), candies.end());\n        for(int i = 0; i != candies.size(); i++){\n            if(candies[i] + extraCandies &gt;= max){\n                ans.push_back(true);\n            }\n            else{\n                ans.push_back(false);\n            }\n        }\n        return ans; \n    }\n};\n\n\n",
        "content": "&lt;-E 1431&gt; Kids With the Greatest Number of Candies\n\nclass Solution {\npublic:\n    vector&lt;bool&gt; kidsWithCandies(vector&lt;int&gt;&amp; candies, int extraCandies) {\n        vector&lt;bool&gt; ans;\n        int max = *max_element(candies.begin(), candies.end());\n        for(int i = 0; i != candies.size(); i++){\n            if(candies[i] + extraCandies &gt;= max){\n                ans.push_back(true);\n            }\n            else{\n                ans.push_back(false);\n            }\n        }\n        return ans; \n    }\n};\n\n\n",
        "url": "/2020/11/16/11431-Kids-With-the-Greatest-Number-of-Candies/"
      },
    
      {
        "title": "Build an Array With Stack Operations",
        "excerpt": "&lt;-E 1441&gt; Build an Array With Stack Operations\n\n//method1\nclass Solution {\npublic:\n    vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) {\n        vector&lt;string&gt; ans;\n        int begin = 1;\n        for(auto i : target) {\n            if(i == begin) {\n                ans.push_back(\"Push\");\n                begin++;\n            }\n            else {\n                while(++begin &lt;= i) {\n                    ans.push_back(\"Push\");\n                    ans.push_back(\"Pop\");\n                }\n                ans.push_back(\"Push\");\n            }\n            \n        }\n        return ans;\n    }\n};\n\n// Method 2\n\nclass Solution {\npublic:\n    vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) {\n        vector&lt;string&gt; ans;\n        \n        int i = 0;\n        \n        for(int j = 0;j &lt; target[target.size()-1]; j++){\n            ans.push_back(\"Push\");\n            if(j + 1 == target[i]){\n                i++;\n            } else {\n                ans.push_back(\"Pop\");\n            }\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1441&gt; Build an Array With Stack Operations\n\n//method1\nclass Solution {\npublic:\n    vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) {\n        vector&lt;string&gt; ans;\n        int begin = 1;\n        for(auto i : target) {\n            if(i == begin) {\n                ans.push_back(\"Push\");\n                begin++;\n            }\n            else {\n                while(++begin &lt;= i) {\n                    ans.push_back(\"Push\");\n                    ans.push_back(\"Pop\");\n                }\n                ans.push_back(\"Push\");\n            }\n            \n        }\n        return ans;\n    }\n};\n\n// Method 2\n\nclass Solution {\npublic:\n    vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) {\n        vector&lt;string&gt; ans;\n        \n        int i = 0;\n        \n        for(int j = 0;j &lt; target[target.size()-1]; j++){\n            ans.push_back(\"Push\");\n            if(j + 1 == target[i]){\n                i++;\n            } else {\n                ans.push_back(\"Pop\");\n            }\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/17/1441-Build-an-Array-With-Stack-Operations/"
      },
    
      {
        "title": "Shuffle String",
        "excerpt": "&lt;-E 1528&gt; Shuffle String\n\n//method1\nclass Solution {\nclass Solution {\npublic:\n    string restoreString(string s, vector&lt;int&gt;&amp; indices) {\n        char chrArray[101] = {};\n        \n        for(int i = 0; i != s.size(); i++) {\n            chrArray[indices[i]] = s[i];\n        }\n        string ans = \"\";\n        for(int i = 0; i != s.size(); i++){    \n            ans += chrArray[i];\n        }\n        \n        return ans;\n    }\n};\n\n//method2\nclass Solution {\npublic:\n    string restoreString(string s, vector&lt;int&gt;&amp; indices) {\n        string S(s.length(), ' ');\n        for(int i = 0; i &lt; s.length() ; i++) \n            S[indices[i]] = s[i];\n        return S;\n    }\n};\n\n\n",
        "content": "&lt;-E 1528&gt; Shuffle String\n\n//method1\nclass Solution {\nclass Solution {\npublic:\n    string restoreString(string s, vector&lt;int&gt;&amp; indices) {\n        char chrArray[101] = {};\n        \n        for(int i = 0; i != s.size(); i++) {\n            chrArray[indices[i]] = s[i];\n        }\n        string ans = \"\";\n        for(int i = 0; i != s.size(); i++){    \n            ans += chrArray[i];\n        }\n        \n        return ans;\n    }\n};\n\n//method2\nclass Solution {\npublic:\n    string restoreString(string s, vector&lt;int&gt;&amp; indices) {\n        string S(s.length(), ' ');\n        for(int i = 0; i &lt; s.length() ; i++) \n            S[indices[i]] = s[i];\n        return S;\n    }\n};\n\n\n",
        "url": "/2020/11/17/1528-Shuffle-String/"
      },
    
      {
        "title": "Design Parking System",
        "excerpt": "&lt;-E 1603&gt; Design Parking System\n\nclass ParkingSystem {\n    int b,m,s;\npublic:\n    ParkingSystem(int big, int medium, int small) {\n        b=big; m=medium; s=small;\n    }\n    \n    bool addCar(int carType) {\n        bool result = true;\n        switch(carType) {\n            case 1:\n                (b &lt;= 0)? result=false:  --b;\n                break;\n            case 2: \n                (m &lt;= 0)? result=false:  --m;\n                break;\n            case 3: \n                (s &lt;= 0)? result=false:  --s;\n                break;\n            default:\n                result=false;\n        }\n        return result;\n    }\n};\n\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem* obj = new ParkingSystem(big, medium, small);\n * bool param_1 = obj-&gt;addCar(carType);\n */\n\n\n",
        "content": "&lt;-E 1603&gt; Design Parking System\n\nclass ParkingSystem {\n    int b,m,s;\npublic:\n    ParkingSystem(int big, int medium, int small) {\n        b=big; m=medium; s=small;\n    }\n    \n    bool addCar(int carType) {\n        bool result = true;\n        switch(carType) {\n            case 1:\n                (b &lt;= 0)? result=false:  --b;\n                break;\n            case 2: \n                (m &lt;= 0)? result=false:  --m;\n                break;\n            case 3: \n                (s &lt;= 0)? result=false:  --s;\n                break;\n            default:\n                result=false;\n        }\n        return result;\n    }\n};\n\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem* obj = new ParkingSystem(big, medium, small);\n * bool param_1 = obj-&gt;addCar(carType);\n */\n\n\n",
        "url": "/2020/11/18/1603-Design-Parking-System/"
      },
    
      {
        "title": "Number of Recent Calls",
        "excerpt": "&lt;-E 933&gt; Number of Recent Calls\n\nclass RecentCounter {\npublic:\n    queue&lt;int&gt; q;\n    RecentCounter() {\n        while(!q.empty())\n            q.pop();\n    }\n    \n    int ping(int t) {\n        while(!q.empty() &amp;&amp; (t - q.front()) &gt; 3000)\n            q.pop();\n        q.push(t);  \n        return q.size();\n    }\n    \n};\n\n/**\n * Your RecentCounter object will be instantiated and called as such:\n * RecentCounter* obj = new RecentCounter();\n * int param_1 = obj-&gt;ping(t);\n */\n\n\n",
        "content": "&lt;-E 933&gt; Number of Recent Calls\n\nclass RecentCounter {\npublic:\n    queue&lt;int&gt; q;\n    RecentCounter() {\n        while(!q.empty())\n            q.pop();\n    }\n    \n    int ping(int t) {\n        while(!q.empty() &amp;&amp; (t - q.front()) &gt; 3000)\n            q.pop();\n        q.push(t);  \n        return q.size();\n    }\n    \n};\n\n/**\n * Your RecentCounter object will be instantiated and called as such:\n * RecentCounter* obj = new RecentCounter();\n * int param_1 = obj-&gt;ping(t);\n */\n\n\n",
        "url": "/2020/11/18/933-Number-of-Recent-Calls/"
      },
    
      {
        "title": "Minimum Subsequence in Non-Increasing Order",
        "excerpt": "&lt;-E 1403&gt; Minimum Subsequence in Non-Increasing Order\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        sort(nums.rbegin(), nums.rend());\n        vector&lt;int&gt; res;\n        int sum_res = 0;\n        int i = 0;\n        while (sum_res &lt;= sum - sum_res &amp;&amp; i &lt; nums.size()) {\n            res.push_back(nums[i]);\n            sum_res += nums[i];\n            i ++;\n        }\n        return res;\n    }\n    \n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) {\n        int buckets[101] = {};\n        int sum = 0;\n        vector&lt;int&gt; result;\n        \n        for(int num : nums) {\n            buckets[num]++;\n            sum += num;\n        }\n        \n        int seq_sum = 0;\n        for(int i = 100; i &gt; 0; i--) {\n            while(buckets[i] &gt; 0) {\n                result.push_back(i);\n                seq_sum += i;\n                buckets[i]--;\n                if(seq_sum &gt; sum - seq_sum) {\n                    i = -1;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-E 1403&gt; Minimum Subsequence in Non-Increasing Order\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        sort(nums.rbegin(), nums.rend());\n        vector&lt;int&gt; res;\n        int sum_res = 0;\n        int i = 0;\n        while (sum_res &lt;= sum - sum_res &amp;&amp; i &lt; nums.size()) {\n            res.push_back(nums[i]);\n            sum_res += nums[i];\n            i ++;\n        }\n        return res;\n    }\n    \n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) {\n        int buckets[101] = {};\n        int sum = 0;\n        vector&lt;int&gt; result;\n        \n        for(int num : nums) {\n            buckets[num]++;\n            sum += num;\n        }\n        \n        int seq_sum = 0;\n        for(int i = 100; i &gt; 0; i--) {\n            while(buckets[i] &gt; 0) {\n                result.push_back(i);\n                seq_sum += i;\n                buckets[i]--;\n                if(seq_sum &gt; sum - seq_sum) {\n                    i = -1;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n};\n\n\n",
        "url": "/2020/11/19/1403-Minimum-Subsequence-in-Non-Increasing-Order/"
      },
    
      {
        "title": "Number of Good Pairs",
        "excerpt": "&lt;-E 1512&gt; Number of Good Pairs\n\nclass Solution {\npublic:\n    int numIdenticalPairs(vector&lt;int&gt;&amp; nums) {\n        int temp[101] = {0};\n        for(auto i : nums) {\n            temp[i]++;\n        }\n        \n        int ans = 0;\n        for(int i = 0; i != 101; i++) {\n            int times = 1;\n            if(temp[i] &gt; 1) {\n                times =  temp[i] * (temp[i] - 1) / 2;\n            ans += times;\n            }\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1512&gt; Number of Good Pairs\n\nclass Solution {\npublic:\n    int numIdenticalPairs(vector&lt;int&gt;&amp; nums) {\n        int temp[101] = {0};\n        for(auto i : nums) {\n            temp[i]++;\n        }\n        \n        int ans = 0;\n        for(int i = 0; i != 101; i++) {\n            int times = 1;\n            if(temp[i] &gt; 1) {\n                times =  temp[i] * (temp[i] - 1) / 2;\n            ans += times;\n            }\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/19/1512-Number-of-Good-Pairs/"
      },
    
      {
        "title": "Running Sum of 1d Array",
        "excerpt": "&lt;-E 1480&gt; Running Sum of 1d Array\n\nclass Solution {\npublic:\n    vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) {\n       \n        for(int i=1;i&lt;nums.size();i++)\n            nums[i]+=nums[i-1];\n        return nums;\n    }\n};\n\n\n",
        "content": "&lt;-E 1480&gt; Running Sum of 1d Array\n\nclass Solution {\npublic:\n    vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) {\n       \n        for(int i=1;i&lt;nums.size();i++)\n            nums[i]+=nums[i-1];\n        return nums;\n    }\n};\n\n\n",
        "url": "/2020/11/20/1480-Running-Sum-of-1d-Array/"
      },
    
      {
        "title": "Can Make Arithmetic Progression From Sequence",
        "excerpt": "&lt;-E 1502&gt; Can Make Arithmetic Progression From Sequence\n\nclass Solution {\npublic:\n    bool canMakeArithmeticProgression(vector&lt;int&gt;&amp; arr) {\n        sort(arr.begin(), arr.end());\n        int differ = arr[1] - arr[0];\n        for(int i = 2; i &lt; arr.size(); i++) {\n            if((arr[i] - arr[i - 1]) != differ)\n                return false;\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 1502&gt; Can Make Arithmetic Progression From Sequence\n\nclass Solution {\npublic:\n    bool canMakeArithmeticProgression(vector&lt;int&gt;&amp; arr) {\n        sort(arr.begin(), arr.end());\n        int differ = arr[1] - arr[0];\n        for(int i = 2; i &lt; arr.size(); i++) {\n            if((arr[i] - arr[i - 1]) != differ)\n                return false;\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2020/11/20/1502-Can-Make-Arithmetic-Progression-From-Sequence/"
      },
    
      {
        "title": "Check If Two String Arrays are Equivalent",
        "excerpt": "&lt;-E 1662&gt; Check If Two String Arrays are Equivalent\n\nclass Solution {\npublic:\n    bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) {\n        string a = \"\",b = \"\";\n        for(auto x : word1)\n            a += x;\n        for(auto x : word2)\n            b += x;\n        return a == b;\n        \n    }\n};\n\n\n\n",
        "content": "&lt;-E 1662&gt; Check If Two String Arrays are Equivalent\n\nclass Solution {\npublic:\n    bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) {\n        string a = \"\",b = \"\";\n        for(auto x : word1)\n            a += x;\n        for(auto x : word2)\n            b += x;\n        return a == b;\n        \n    }\n};\n\n\n\n",
        "url": "/2020/11/21/1662-Check-If-Two-String-Arrays-are-Equivalent/"
      },
    
      {
        "title": "Sort Array By Parity II",
        "excerpt": "&lt;-E 922&gt; Sort Array By Parity II\n\nclass Solution {\npublic:\n    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) {\n        \n        vector&lt;int&gt; result(A.size(), 0);\n        int even = 0;\n        int odd = 1;\n        \n        for(auto c : A) {\n            if(c % 2 == 0) {\n                result[even] = c;\n                even += 2;\n            }\n            else{\n                result[odd] = c;\n                odd += 2;\n            }\n        }      \n        \n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-E 922&gt; Sort Array By Parity II\n\nclass Solution {\npublic:\n    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) {\n        \n        vector&lt;int&gt; result(A.size(), 0);\n        int even = 0;\n        int odd = 1;\n        \n        for(auto c : A) {\n            if(c % 2 == 0) {\n                result[even] = c;\n                even += 2;\n            }\n            else{\n                result[odd] = c;\n                odd += 2;\n            }\n        }      \n        \n        return result;\n    }\n};\n\n\n",
        "url": "/2020/11/21/922-Sort-Array-By-Parity-II/"
      },
    
      {
        "title": "Remove All Adjacent Duplicates In String",
        "excerpt": "&lt;-E 1047&gt; Remove All Adjacent Duplicates In String\n\n// Method 1\nclass Solution {\npublic:\n    string removeDuplicates(string S) {\n        int n = S.size();\n        for(int i = 0;i &lt; n; i++){\n            if(S[i] == S[i+1]) {\n                S = S.erase(i,2);\n                n = S.size();\n                i = -1;\n            }\n        }\n        return S;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string removeDuplicates(string S) {\n        int end = 0;\n        for(int i= 0, n = S.size(); i &lt; n; i++, end++) {\n            S[end] = S[i];\n            if( end &gt; 0 &amp;&amp; S[end] == S[end-1])\n                end -= 2;\n        }\n        \n        return S.substr(0, end);        \n    }\n};\n\n\n",
        "content": "&lt;-E 1047&gt; Remove All Adjacent Duplicates In String\n\n// Method 1\nclass Solution {\npublic:\n    string removeDuplicates(string S) {\n        int n = S.size();\n        for(int i = 0;i &lt; n; i++){\n            if(S[i] == S[i+1]) {\n                S = S.erase(i,2);\n                n = S.size();\n                i = -1;\n            }\n        }\n        return S;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string removeDuplicates(string S) {\n        int end = 0;\n        for(int i= 0, n = S.size(); i &lt; n; i++, end++) {\n            S[end] = S[i];\n            if( end &gt; 0 &amp;&amp; S[end] == S[end-1])\n                end -= 2;\n        }\n        \n        return S.substr(0, end);        \n    }\n};\n\n\n",
        "url": "/2020/11/22/11047-Remove-All-Adjacent-Duplicates-In-String/"
      },
    
      {
        "title": "Maximum Nesting Depth of the Parentheses",
        "excerpt": "&lt;-E 1614&gt; Maximum Nesting Depth of the Parentheses\n\nclass Solution {\npublic:\n    int maxDepth(string s) {\n        int ans = 0;\n        int check = 0;\n        for(auto i : s) {\n            if(i == '(') {\n                check++;\n            }\n                \n            if(i == ')') {\n                check--;\n            }\n            if(check &gt; ans) {\n                ans = check;\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1614&gt; Maximum Nesting Depth of the Parentheses\n\nclass Solution {\npublic:\n    int maxDepth(string s) {\n        int ans = 0;\n        int check = 0;\n        for(auto i : s) {\n            if(i == '(') {\n                check++;\n            }\n                \n            if(i == ')') {\n                check--;\n            }\n            if(check &gt; ans) {\n                ans = check;\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/22/1614-Maximum-Nesting-Depth-of-the-Parentheses/"
      },
    
      {
        "title": "Sum of All Odd Length Subarrays",
        "excerpt": "&lt;-E 1588&gt; Sum of All Odd Length Subarrays\n\n// Method 1\nclass Solution {\npublic:\n    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) {\n\n        int n = arr.size();\n        int result = 0;\n\n        for(int i = 0; i &lt; n; i++){\n            result += arr[i] * (((i + 1)*(n - i) + 1) / 2);\n        }\n        \n        return result;  \n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) {\n        int ans = 0;\n      \n        for(int i = 1; i &lt;= arr.size(); i += 2){\n            \n            int begin = 0;\n            while((begin + i) &lt;= arr.size()) {\n                \n                for(int times = 0; times &lt; i; times++) {\n                    ans += arr[begin + times];\n                }\n                begin += 1;\n            }\n            \n        }\n        return ans;\n    }\n};\n\n// Method 3\nclass Solution {\npublic:\n    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) {\n        int n = arr.size();\n        int sum = 0;\n        for(int i=1;i&lt;=n;i+=2){\n            int windowSize=i;\n            int tmpSum=0;\n            for(int j=0;j&lt;windowSize;j++){\n                tmpSum+=arr[j];\n            }\n            sum+=tmpSum;\n            int start = 0;\n            for(int j=windowSize;j&lt;n;j++){\n                tmpSum = tmpSum - arr[start];\n                tmpSum = tmpSum + arr[j];\n                start++;\n                sum+=tmpSum;\n            }\n        }\n        return sum;\n        \n    }\n};\n\n\n",
        "content": "&lt;-E 1588&gt; Sum of All Odd Length Subarrays\n\n// Method 1\nclass Solution {\npublic:\n    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) {\n\n        int n = arr.size();\n        int result = 0;\n\n        for(int i = 0; i &lt; n; i++){\n            result += arr[i] * (((i + 1)*(n - i) + 1) / 2);\n        }\n        \n        return result;  \n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) {\n        int ans = 0;\n      \n        for(int i = 1; i &lt;= arr.size(); i += 2){\n            \n            int begin = 0;\n            while((begin + i) &lt;= arr.size()) {\n                \n                for(int times = 0; times &lt; i; times++) {\n                    ans += arr[begin + times];\n                }\n                begin += 1;\n            }\n            \n        }\n        return ans;\n    }\n};\n\n// Method 3\nclass Solution {\npublic:\n    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) {\n        int n = arr.size();\n        int sum = 0;\n        for(int i=1;i&lt;=n;i+=2){\n            int windowSize=i;\n            int tmpSum=0;\n            for(int j=0;j&lt;windowSize;j++){\n                tmpSum+=arr[j];\n            }\n            sum+=tmpSum;\n            int start = 0;\n            for(int j=windowSize;j&lt;n;j++){\n                tmpSum = tmpSum - arr[start];\n                tmpSum = tmpSum + arr[j];\n                start++;\n                sum+=tmpSum;\n            }\n        }\n        return sum;\n        \n    }\n};\n\n\n",
        "url": "/2020/11/23/1588-Sum-of-All-Odd-Length-Subarrays/"
      },
    
      {
        "title": "Maximum Depth of N-ary Tree",
        "excerpt": "&lt;-E 559&gt; Maximum Depth of N-ary Tree\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector&lt;Node*&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int maxDepth(Node* root) {\n        \n        if(root==NULL) return 0;\n        int ans=1;\n        for(int i=0;i&lt;root-&gt;children.size();i++) \n            ans= max(ans,1+maxDepth(root-&gt;children[i]));\n        \n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 559&gt; Maximum Depth of N-ary Tree\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector&lt;Node*&gt; children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector&lt;Node*&gt; _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int maxDepth(Node* root) {\n        \n        if(root==NULL) return 0;\n        int ans=1;\n        for(int i=0;i&lt;root-&gt;children.size();i++) \n            ans= max(ans,1+maxDepth(root-&gt;children[i]));\n        \n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/23/559-Maximum-Depth-of-N-ary-Tree/"
      },
    
      {
        "title": "Design an Ordered Stream",
        "excerpt": "&lt;-E 1656&gt; Design an Ordered Stream\n\n// Method 1\nclass OrderedStream {\npublic:\n    vector&lt;string&gt; pos;\n    int ptr;\n    \n    OrderedStream(int n) {\n        pos.resize(n + 1, \"\");\n        ptr = 1;\n    }\n    \n    vector&lt;string&gt; insert(int id, string value) {\n        //ptr+=1;\n        pos[id] = value;\n        vector&lt;string&gt; ans;\n        int flag = 0;\n        if(pos[ptr] != \"\") \n            flag = 1;\n        if(flag == 1) {\n            for(int i = ptr;i &lt; pos.size();i++) {\n                if(pos[i] != \"\") \n                    ans.push_back(pos[i]);\n                else{\n                    ptr = i;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * OrderedStream* obj = new OrderedStream(n);\n * vector&lt;string&gt; param_1 = obj-&gt;insert(id,value);\n */\n\n // Method 2\nclass OrderedStream {\npublic:\n    vector&lt;string&gt; stream ; \n    int i = 0;\n    OrderedStream(int n) {\n        stream.resize(n); \n    }\n    \n    vector&lt;string&gt; insert(int id, string value) {\n        vector&lt;string&gt; result;\n        stream[id-1] = value; \n        while(i&lt;stream.size() &amp;&amp; stream[i]!=\"\") \n        {\n            result.push_back(stream[i]);\n            i++;\n        }\n        return result;\n    }\n};\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * OrderedStream* obj = new OrderedStream(n);\n * vector&lt;string&gt; param_1 = obj-&gt;insert(id,value);\n */\n\n\n",
        "content": "&lt;-E 1656&gt; Design an Ordered Stream\n\n// Method 1\nclass OrderedStream {\npublic:\n    vector&lt;string&gt; pos;\n    int ptr;\n    \n    OrderedStream(int n) {\n        pos.resize(n + 1, \"\");\n        ptr = 1;\n    }\n    \n    vector&lt;string&gt; insert(int id, string value) {\n        //ptr+=1;\n        pos[id] = value;\n        vector&lt;string&gt; ans;\n        int flag = 0;\n        if(pos[ptr] != \"\") \n            flag = 1;\n        if(flag == 1) {\n            for(int i = ptr;i &lt; pos.size();i++) {\n                if(pos[i] != \"\") \n                    ans.push_back(pos[i]);\n                else{\n                    ptr = i;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * OrderedStream* obj = new OrderedStream(n);\n * vector&lt;string&gt; param_1 = obj-&gt;insert(id,value);\n */\n\n // Method 2\nclass OrderedStream {\npublic:\n    vector&lt;string&gt; stream ; \n    int i = 0;\n    OrderedStream(int n) {\n        stream.resize(n); \n    }\n    \n    vector&lt;string&gt; insert(int id, string value) {\n        vector&lt;string&gt; result;\n        stream[id-1] = value; \n        while(i&lt;stream.size() &amp;&amp; stream[i]!=\"\") \n        {\n            result.push_back(stream[i]);\n            i++;\n        }\n        return result;\n    }\n};\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * OrderedStream* obj = new OrderedStream(n);\n * vector&lt;string&gt; param_1 = obj-&gt;insert(id,value);\n */\n\n\n",
        "url": "/2020/11/24/1656-Design-an-Ordered-Stream/"
      },
    
      {
        "title": "Subdomain Visit Count",
        "excerpt": "&lt;-E 811&gt; Subdomain Visit Count\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) {\n        std::map&lt;std::string, int&gt; fmap;\n        std::vector&lt;std::string&gt; fvec;\n        for(std::string s : cpdomains)\n        {\n            int len = s.length();\n            int pos1 = s.find_first_of(' ');\n            int visit = std::stoi(s.substr(0, pos1));\n            int pos2 = pos1;\n            while(pos2 != std::string::npos)\n            {\n                std::string in = s.substr(pos1+1, len-pos1);\n                fmap[in] += visit;\n                pos2 = s.find_first_of('.', pos1+1);\n                pos1 = pos2;\n            }\n        }\n        \n        for(auto&amp; x : fmap)\n            fvec.push_back((std::to_string(x.second) + ' ' + x.first));\n        \n        return fvec; \n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) {\n        \n        unordered_map&lt;string, int&gt; cache;\n        for (int i = 0; i&lt; cpdomains.size(); i++) {\n            int count = 0;\n            int j = 0;\n            while (j &lt; cpdomains[i].size() &amp;&amp; cpdomains[i][j]!=' '){\n                count  = count*10 + (cpdomains[i][j]-'0'); \n                j++;\n            }\n            j++;\n            cache[cpdomains[i].substr(j, cpdomains[i].size()-j)] += count;\n            while (j &lt; cpdomains[i].size()) {\n                if (cpdomains[i][j] == '.')\n                    cache[cpdomains[i].substr(j+1, cpdomains[i].size()-j-1)] += count;\n                j++;\n            }\n        }\n        \n        vector&lt;string&gt; res;\n        for (auto it : cache)\n            res.push_back(to_string(it.second) + ' ' + it.first);\n        \n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 811&gt; Subdomain Visit Count\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) {\n        std::map&lt;std::string, int&gt; fmap;\n        std::vector&lt;std::string&gt; fvec;\n        for(std::string s : cpdomains)\n        {\n            int len = s.length();\n            int pos1 = s.find_first_of(' ');\n            int visit = std::stoi(s.substr(0, pos1));\n            int pos2 = pos1;\n            while(pos2 != std::string::npos)\n            {\n                std::string in = s.substr(pos1+1, len-pos1);\n                fmap[in] += visit;\n                pos2 = s.find_first_of('.', pos1+1);\n                pos1 = pos2;\n            }\n        }\n        \n        for(auto&amp; x : fmap)\n            fvec.push_back((std::to_string(x.second) + ' ' + x.first));\n        \n        return fvec; \n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) {\n        \n        unordered_map&lt;string, int&gt; cache;\n        for (int i = 0; i&lt; cpdomains.size(); i++) {\n            int count = 0;\n            int j = 0;\n            while (j &lt; cpdomains[i].size() &amp;&amp; cpdomains[i][j]!=' '){\n                count  = count*10 + (cpdomains[i][j]-'0'); \n                j++;\n            }\n            j++;\n            cache[cpdomains[i].substr(j, cpdomains[i].size()-j)] += count;\n            while (j &lt; cpdomains[i].size()) {\n                if (cpdomains[i][j] == '.')\n                    cache[cpdomains[i].substr(j+1, cpdomains[i].size()-j-1)] += count;\n                j++;\n            }\n        }\n        \n        vector&lt;string&gt; res;\n        for (auto it : cache)\n            res.push_back(to_string(it.second) + ' ' + it.first);\n        \n        return res;\n    }\n};\n\n\n",
        "url": "/2020/11/24/811-Subdomain-Visit-Count/"
      },
    
      {
        "title": "Flipping an Image",
        "excerpt": "&lt;-E 832&gt; Flipping an Image\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) {\n        if(A.empty()){\n            return A;\n        }\n        for (auto&amp; row : A) \n            reverse(row.begin(), row.end());\n        for (auto&amp; row : A) \n            for (int&amp; i: row) i ^= 1;\n        return A;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) {\n        if(A.empty()){\n            return A;\n        }\n        for(auto&amp; row : A){\n            reverse(begin(row), end(row));\n        for_each(row.begin(), row.end(), [](int&amp; item){ item ^= 1; });\n        }\n        return A;\n    }\n};\n\n\n",
        "content": "&lt;-E 832&gt; Flipping an Image\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) {\n        if(A.empty()){\n            return A;\n        }\n        for (auto&amp; row : A) \n            reverse(row.begin(), row.end());\n        for (auto&amp; row : A) \n            for (int&amp; i: row) i ^= 1;\n        return A;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) {\n        if(A.empty()){\n            return A;\n        }\n        for(auto&amp; row : A){\n            reverse(begin(row), end(row));\n        for_each(row.begin(), row.end(), [](int&amp; item){ item ^= 1; });\n        }\n        return A;\n    }\n};\n\n\n",
        "url": "/2020/11/25/832-Flipping-an-Image/"
      },
    
      {
        "title": "Delete Columns to Make Sorted",
        "excerpt": "&lt;-E 944&gt; Delete Columns to Make Sorted\n\nclass Solution {\npublic:\n    int minDeletionSize(vector&lt;string&gt;&amp; A) {\n        int n = A.size(), len = A[0].size(), res = 0;\n        for (int j = 0; j &lt; len; ++j) {\n            for (int i = 0; i &lt; n - 1; ++i) {\n                if (A[i][j] &lt;= A[i + 1][j]) continue;\n                ++res;\n                break;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 944&gt; Delete Columns to Make Sorted\n\nclass Solution {\npublic:\n    int minDeletionSize(vector&lt;string&gt;&amp; A) {\n        int n = A.size(), len = A[0].size(), res = 0;\n        for (int j = 0; j &lt; len; ++j) {\n            for (int i = 0; i &lt; n - 1; ++i) {\n                if (A[i][j] &lt;= A[i + 1][j]) continue;\n                ++res;\n                break;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/11/25/944-Delete-Columns-to-Make-Sorted/"
      },
    
      {
        "title": "Sum of Root To Leaf Binary Numbers",
        "excerpt": "&lt;-E 1022&gt; Sum of Root To Leaf Binary Numbers\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int ans;\n    void sumRootToLeafUtils(TreeNode* root, int path) {\n        if(root == NULL)\n            return;\n        \n        path = path &lt;&lt; 1 | root-&gt;val;\n        \n        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {\n            ans += path;\n            return;\n        }\n        sumRootToLeafUtils(root-&gt;left,path);\n        sumRootToLeafUtils(root-&gt;right, path);\n        \n    }\n    int sumRootToLeaf(TreeNode* root) {\n        ans = 0;\n        sumRootToLeafUtils(root, 0);\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1022&gt; Sum of Root To Leaf Binary Numbers\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int ans;\n    void sumRootToLeafUtils(TreeNode* root, int path) {\n        if(root == NULL)\n            return;\n        \n        path = path &lt;&lt; 1 | root-&gt;val;\n        \n        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {\n            ans += path;\n            return;\n        }\n        sumRootToLeafUtils(root-&gt;left,path);\n        sumRootToLeafUtils(root-&gt;right, path);\n        \n    }\n    int sumRootToLeaf(TreeNode* root) {\n        ans = 0;\n        sumRootToLeafUtils(root, 0);\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/26/1022-Sum-of-Root-To-Leaf-Binary-Numbers/"
      },
    
      {
        "title": "Destination City",
        "excerpt": "&lt;-E 1436&gt; Destination City\n\nclass Solution {\npublic:\n    string destCity(vector&lt;vector&lt;string&gt;&gt;&amp; paths) {\n        unordered_map&lt;string, int&gt; map;\n        for(int i = 0; i &lt; paths.size(); i++){\n            map[paths[i][0]]++;\n        }\n        \n        for(int i = 0; i &lt; paths.size(); i++){\n            if(map[paths[i][1]] == 0) \n                return paths[i][1];\n        }  \n        \n        return NULL;\n    }\n};\n\n\n",
        "content": "&lt;-E 1436&gt; Destination City\n\nclass Solution {\npublic:\n    string destCity(vector&lt;vector&lt;string&gt;&gt;&amp; paths) {\n        unordered_map&lt;string, int&gt; map;\n        for(int i = 0; i &lt; paths.size(); i++){\n            map[paths[i][0]]++;\n        }\n        \n        for(int i = 0; i &lt; paths.size(); i++){\n            if(map[paths[i][1]] == 0) \n                return paths[i][1];\n        }  \n        \n        return NULL;\n    }\n};\n\n\n",
        "url": "/2020/11/26/1436-Destination-City/"
      },
    
      {
        "title": "Number of Students Doing Homework at a Given Time",
        "excerpt": "&lt;-E 1450&gt; Number of Students Doing Homework at a Given Time\n\nclass Solution {\npublic:\n    int busyStudent(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, int queryTime) {\n        int ans = 0;\n        for(int i = 0; i != startTime.size(); i++) {\n            if(startTime[i] &lt;= queryTime)\n                if(endTime[i] &gt;= queryTime)\n                    ans++;\n                    \n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1450&gt; Number of Students Doing Homework at a Given Time\n\nclass Solution {\npublic:\n    int busyStudent(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, int queryTime) {\n        int ans = 0;\n        for(int i = 0; i != startTime.size(); i++) {\n            if(startTime[i] &lt;= queryTime)\n                if(endTime[i] &gt;= queryTime)\n                    ans++;\n                    \n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/27/1450-Number-of-Students-Doing-Homework-at-a-Given-Time/"
      },
    
      {
        "title": "Special Array With X Elements Greater Than or Equal X",
        "excerpt": "&lt;-E 1608&gt; Special Array With X Elements Greater Than or Equal X\n\nclass Solution {\npublic:\n    int specialArray(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        int size = nums.size();\n        if (1 &lt;= size &amp;&amp; size &lt;= nums[0]) \n            return size;\n        for (int i = 1; i &lt; size; i++) {\n            int left = size - i;\n            if (nums[i - 1] &lt; left &amp;&amp; left &lt;= nums[i]) \n                return left;\n        }\n        return -1;\n    }\n};\n\n\n",
        "content": "&lt;-E 1608&gt; Special Array With X Elements Greater Than or Equal X\n\nclass Solution {\npublic:\n    int specialArray(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        int size = nums.size();\n        if (1 &lt;= size &amp;&amp; size &lt;= nums[0]) \n            return size;\n        for (int i = 1; i &lt; size; i++) {\n            int left = size - i;\n            if (nums[i - 1] &lt; left &amp;&amp; left &lt;= nums[i]) \n                return left;\n        }\n        return -1;\n    }\n};\n\n\n",
        "url": "/2020/11/27/1608-Special-Array-With-X-Elements-Greater-Than-or-Equal-X/"
      },
    
      {
        "title": "Maximum Product of Two Elements in an Array",
        "excerpt": "&lt;-E 1464&gt; Maximum Product of Two Elements in an Array\n\n// Method 1\nclass Solution {\npublic:\n    int maxProduct(vector&lt;int&gt;&amp; nums) {\n         if(nums.size() ==2){\n            return (nums[0] - 1) * (nums[1] - 1);\n        }\n        int firstMax ;\n        int secondMax ;\n        if( nums[0] &gt; nums[1]){\n            secondMax = nums[0];\n            firstMax = nums[1];\n        }else{\n            secondMax = nums[1];\n            firstMax = nums[0];\n        }\n        \n        int j =2;\n        for( j; j&lt; nums.size(); j++){\n            if( nums[j] &gt;= secondMax){\n                firstMax = secondMax;\n                secondMax = nums[j];\n            }else if( nums[j] &gt; firstMax){\n                firstMax = nums[j];\n            }\n        }\n        \n        return (firstMax-1) * (secondMax-1);\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    int maxProduct(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        return (nums[nums.size()-1]-1)*(nums[nums.size()-2]-1);\n    }\n};\n\n\n",
        "content": "&lt;-E 1464&gt; Maximum Product of Two Elements in an Array\n\n// Method 1\nclass Solution {\npublic:\n    int maxProduct(vector&lt;int&gt;&amp; nums) {\n         if(nums.size() ==2){\n            return (nums[0] - 1) * (nums[1] - 1);\n        }\n        int firstMax ;\n        int secondMax ;\n        if( nums[0] &gt; nums[1]){\n            secondMax = nums[0];\n            firstMax = nums[1];\n        }else{\n            secondMax = nums[1];\n            firstMax = nums[0];\n        }\n        \n        int j =2;\n        for( j; j&lt; nums.size(); j++){\n            if( nums[j] &gt;= secondMax){\n                firstMax = secondMax;\n                secondMax = nums[j];\n            }else if( nums[j] &gt; firstMax){\n                firstMax = nums[j];\n            }\n        }\n        \n        return (firstMax-1) * (secondMax-1);\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    int maxProduct(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        return (nums[nums.size()-1]-1)*(nums[nums.size()-2]-1);\n    }\n};\n\n\n",
        "url": "/2020/11/28/1464-Maximum-Product-of-Two-Elements-in-an-Array/"
      },
    
      {
        "title": "Transpose Matrix",
        "excerpt": "&lt;-E 867&gt; Transpose Matrix\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) {\n        vector&lt;vector&lt;int&gt;&gt; res(A[0].size(), vector&lt;int&gt;(A.size()));\n        for(int i = 0; i &lt; A.size(); i++){\n            for(int j = 0; j &lt; A[i].size(); j++){\n                res[j][i] = A[i][j];\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 867&gt; Transpose Matrix\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) {\n        vector&lt;vector&lt;int&gt;&gt; res(A[0].size(), vector&lt;int&gt;(A.size()));\n        for(int i = 0; i &lt; A.size(); i++){\n            for(int j = 0; j &lt; A[i].size(); j++){\n                res[j][i] = A[i][j];\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/11/28/867-Transpose-Matrix/"
      },
    
      {
        "title": "Day of the Week",
        "excerpt": "&lt;-E 1185&gt; Day of the Week\n\nclass Solution {\npublic:\n    string dayOfTheWeek(int day, int month, int year) {\n        vector&lt;int&gt; mon{0,31,28,31,30,31,30,31,31,30,31,30,31};\n        vector&lt;string&gt; dayofweek{\"Sunday\", \"Monday\", \"Tuesday\", \n                           \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n        int sum=4;\n        \n        for(int i=1971;i&lt;year;i++){\n          if((((i % 4 == 0) &amp;&amp; (i % 100 != 0)) ||\n             (i % 400 == 0)))\n                sum+=366;\n            else\n                sum+=365;\n        }\n        \n        for(int i=1;i&lt;month;i++){\n            if(i==2 &amp;&amp; (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) ||\n             (year % 400 == 0)))\n                sum++;\n            sum+=mon[i];\n        }\n        \n        sum+=day;\n        return dayofweek[sum%7];\n    }\n};\n\n\n",
        "content": "&lt;-E 1185&gt; Day of the Week\n\nclass Solution {\npublic:\n    string dayOfTheWeek(int day, int month, int year) {\n        vector&lt;int&gt; mon{0,31,28,31,30,31,30,31,31,30,31,30,31};\n        vector&lt;string&gt; dayofweek{\"Sunday\", \"Monday\", \"Tuesday\", \n                           \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n        int sum=4;\n        \n        for(int i=1971;i&lt;year;i++){\n          if((((i % 4 == 0) &amp;&amp; (i % 100 != 0)) ||\n             (i % 400 == 0)))\n                sum+=366;\n            else\n                sum+=365;\n        }\n        \n        for(int i=1;i&lt;month;i++){\n            if(i==2 &amp;&amp; (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) ||\n             (year % 400 == 0)))\n                sum++;\n            sum+=mon[i];\n        }\n        \n        sum+=day;\n        return dayofweek[sum%7];\n    }\n};\n\n\n",
        "url": "/2020/11/29/1185-Day-of-the-Week/"
      },
    
      {
        "title": "Check Array Formation Through Concatenation",
        "excerpt": "&lt;-E 1640&gt; Check Array Formation Through Concatenation\n\nclass Solution {\npublic:\n    bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) {\n        for(auto i:pieces){\n            auto it=find(arr.begin(),arr.end(),i[0]);\n            if(it != arr.end()){\n                for(auto j: i){\n                    if(*it != j)\n                        return false;\n                    it++;\n                }\n            }\n            else\n                return false;\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 1640&gt; Check Array Formation Through Concatenation\n\nclass Solution {\npublic:\n    bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) {\n        for(auto i:pieces){\n            auto it=find(arr.begin(),arr.end(),i[0]);\n            if(it != arr.end()){\n                for(auto j: i){\n                    if(*it != j)\n                        return false;\n                    it++;\n                }\n            }\n            else\n                return false;\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2020/11/29/1640-Check-Array-Formation-Through-Concatenation/"
      },
    
      {
        "title": "Last Stone Weight",
        "excerpt": "&lt;-E 1046&gt; Last Stone Weight\n\nclass Solution {\npublic:\n    int lastStoneWeight(vector&lt;int&gt;&amp; stones) {\n       priority_queue&lt;int&gt; pq(stones.begin(),stones.end());\n        while(pq.size() &gt;= 2){\n            int x = pq.top();\n            pq.pop();\n            int y = pq.top();\n            pq.pop();\n            if(x&gt;y)\n                pq.push(x - y);\n        }\n        return pq.empty() ? 0 : pq.top();\n    }\n};\n\n\n",
        "content": "&lt;-E 1046&gt; Last Stone Weight\n\nclass Solution {\npublic:\n    int lastStoneWeight(vector&lt;int&gt;&amp; stones) {\n       priority_queue&lt;int&gt; pq(stones.begin(),stones.end());\n        while(pq.size() &gt;= 2){\n            int x = pq.top();\n            pq.pop();\n            int y = pq.top();\n            pq.pop();\n            if(x&gt;y)\n                pq.push(x - y);\n        }\n        return pq.empty() ? 0 : pq.top();\n    }\n};\n\n\n",
        "url": "/2020/11/30/1046-Last-Stone-Weight/"
      },
    
      {
        "title": "Sort Array by Increasing Frequency",
        "excerpt": "&lt;-E 1636&gt; Sort Array by Increasing Frequency\n\nclass Solution {\npublic:\n    vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) {\n        unordered_map &lt;int, int&gt; ma;\n        for (int i = 0 ; i &lt; nums.size(); i++) {\n            ma[nums[i]]++;\n        }\n        vector &lt;pair &lt;int, int&gt; &gt; pa;\n        for (auto it : ma) { \n            pa.push_back({it.second, it.first});\n        }\n        sort(pa.begin(), pa.end(), [](auto a, auto b) {\n            if (a.first == b.first) {\n                return a.second &gt; b.second;\n            }\n            return a.first &lt; b.first;\n        });\n        vector &lt;int&gt; ans;\n        for (int i = 0; i &lt; pa.size(); i++) {\n            for (int j = 0; j &lt; pa[i].first; j++)\n                ans.push_back(pa[i].second);\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1636&gt; Sort Array by Increasing Frequency\n\nclass Solution {\npublic:\n    vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) {\n        unordered_map &lt;int, int&gt; ma;\n        for (int i = 0 ; i &lt; nums.size(); i++) {\n            ma[nums[i]]++;\n        }\n        vector &lt;pair &lt;int, int&gt; &gt; pa;\n        for (auto it : ma) { \n            pa.push_back({it.second, it.first});\n        }\n        sort(pa.begin(), pa.end(), [](auto a, auto b) {\n            if (a.first == b.first) {\n                return a.second &gt; b.second;\n            }\n            return a.first &lt; b.first;\n        });\n        vector &lt;int&gt; ans;\n        for (int i = 0; i &lt; pa.size(); i++) {\n            for (int j = 0; j &lt; pa[i].first; j++)\n                ans.push_back(pa[i].second);\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/11/30/1636-Sort-Array-by-Increasing-Frequency/"
      },
    
      {
        "title": "Print in Order",
        "excerpt": "&lt;-E 1114&gt; Print in Order\n\nclass Foo {\npublic:\n    Foo() {\n        pthread_mutex_lock(&amp;m_second);\n        pthread_mutex_lock(&amp;m_third);\n    }\n    \n    ~Foo() {\n        pthread_mutex_destroy(&amp;m_second);\n        pthread_mutex_destroy(&amp;m_third);\n    }\n\n    void first(function&lt;void()&gt; printFirst) {\n        \n        // printFirst() outputs \"first\". Do not change or remove this line.\n        printFirst();\n        pthread_mutex_unlock(&amp;m_second);\n    }\n\n    void second(function&lt;void()&gt; printSecond) {\n        \n        // printSecond() outputs \"second\". Do not change or remove this line.\n        pthread_mutex_lock(&amp;m_second);\n        printSecond();\n        pthread_mutex_unlock(&amp;m_third);\n    }\n\n    void third(function&lt;void()&gt; printThird) {\n        \n        // printThird() outputs \"third\". Do not change or remove this line.\n        pthread_mutex_lock(&amp;m_third);\n        printThird();\n    }\nprivate:\n    pthread_mutex_t m_second = PTHREAD_MUTEX_INITIALIZER;\n    pthread_mutex_t m_third = PTHREAD_MUTEX_INITIALIZER;\n};\n\n\n",
        "content": "&lt;-E 1114&gt; Print in Order\n\nclass Foo {\npublic:\n    Foo() {\n        pthread_mutex_lock(&amp;m_second);\n        pthread_mutex_lock(&amp;m_third);\n    }\n    \n    ~Foo() {\n        pthread_mutex_destroy(&amp;m_second);\n        pthread_mutex_destroy(&amp;m_third);\n    }\n\n    void first(function&lt;void()&gt; printFirst) {\n        \n        // printFirst() outputs \"first\". Do not change or remove this line.\n        printFirst();\n        pthread_mutex_unlock(&amp;m_second);\n    }\n\n    void second(function&lt;void()&gt; printSecond) {\n        \n        // printSecond() outputs \"second\". Do not change or remove this line.\n        pthread_mutex_lock(&amp;m_second);\n        printSecond();\n        pthread_mutex_unlock(&amp;m_third);\n    }\n\n    void third(function&lt;void()&gt; printThird) {\n        \n        // printThird() outputs \"third\". Do not change or remove this line.\n        pthread_mutex_lock(&amp;m_third);\n        printThird();\n    }\nprivate:\n    pthread_mutex_t m_second = PTHREAD_MUTEX_INITIALIZER;\n    pthread_mutex_t m_third = PTHREAD_MUTEX_INITIALIZER;\n};\n\n\n",
        "url": "/2020/12/01/1114-Print-in-Order/"
      },
    
      {
        "title": "String Matching in an Array",
        "excerpt": "&lt;-E 1408&gt; String Matching in an Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {\n        vector&lt;string&gt; s;\n        \n        for(int i = 0;i &lt; words.size(); i++) {\n            for(int j = 0;j &lt; words.size(); j++) {\n                if(j == i || words[i].size() &gt; words[j].size())\n                    continue;\n                if(words[j].find(words[i]) !=-1){ \n                    s.push_back(words[i]); \n                    break;\n                }\n            }\n        }\n            return s;\n    }\n};\n\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {\n        vector&lt;string&gt; myVector;\n        for(int i=0; i&lt;words.size(); i++){\n            for(int j=0; j&lt;words.size(); j++){\n                if(i != j &amp;&amp; words[j].find(words[i])!=string::npos){\n                    if(find(myVector.begin(), myVector.end(), words[i]) == myVector.end()){\n                        myVector.push_back(words[i]);\n                    }\n                }\n            }\n        }\n        return myVector;\n    }\n};\n\n\n",
        "content": "&lt;-E 1408&gt; String Matching in an Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {\n        vector&lt;string&gt; s;\n        \n        for(int i = 0;i &lt; words.size(); i++) {\n            for(int j = 0;j &lt; words.size(); j++) {\n                if(j == i || words[i].size() &gt; words[j].size())\n                    continue;\n                if(words[j].find(words[i]) !=-1){ \n                    s.push_back(words[i]); \n                    break;\n                }\n            }\n        }\n            return s;\n    }\n};\n\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) {\n        vector&lt;string&gt; myVector;\n        for(int i=0; i&lt;words.size(); i++){\n            for(int j=0; j&lt;words.size(); j++){\n                if(i != j &amp;&amp; words[j].find(words[i])!=string::npos){\n                    if(find(myVector.begin(), myVector.end(), words[i]) == myVector.end()){\n                        myVector.push_back(words[i]);\n                    }\n                }\n            }\n        }\n        return myVector;\n    }\n};\n\n\n",
        "url": "/2020/12/01/1408-String-Matching-in-an-Array/"
      },
    
      {
        "title": "Trim a Binary Search Tree",
        "excerpt": "&lt;-E 669&gt; Trim a Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if(root==nullptr) return root;\n        root-&gt;left = trimBST(root-&gt;left,low,high);\n        root-&gt;right = trimBST(root-&gt;right,low,high);\n        \n        if(root-&gt;val &lt; low){\n            return root-&gt;right;\n        }else if(root-&gt;val &gt; high){\n            return root-&gt;left;\n        }\n        \n        return root;\n    }\n};\n\n\n",
        "content": "&lt;-E 669&gt; Trim a Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if(root==nullptr) return root;\n        root-&gt;left = trimBST(root-&gt;left,low,high);\n        root-&gt;right = trimBST(root-&gt;right,low,high);\n        \n        if(root-&gt;val &lt; low){\n            return root-&gt;right;\n        }else if(root-&gt;val &gt; high){\n            return root-&gt;left;\n        }\n        \n        return root;\n    }\n};\n\n\n",
        "url": "/2020/12/02/669-Trim-a-Binary-Search-Tree/"
      },
    
      {
        "title": "Available Captures for Rook",
        "excerpt": "&lt;-E 999&gt; Available Captures for Rook\n\nclass Solution {\npublic:\n    int numRookCaptures(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        int row = 0;\n        int col = 0;\n        for(auto i : board) {\n            auto it = find(i.begin(), i.end(), 'R');\n            if(it != i.end()) {\n                col = it - i.begin();\n                break;\n            }\n            row++;\n        }\n        int add = 1;\n        bool n = false;\n        bool e = false;\n        bool w = false;\n        bool s = false;\n        int ans = 0;\n        while(true) {\n            if(e != true) {\n                if(col + add &gt;= 8) {\n                    e = true;\n                } else {\n                    if(e == false &amp;&amp; board[row][col + add] == 'B')\n                        e = true;\n                    if(e == false &amp;&amp; board[row][col + add] == 'p') {\n                        e = true;\n                        ans++;\n                    }\n                }\n            }\n            if(n != true) {\n                if(row + add &gt;= 8) {\n                    n = true;\n                } else {\n                    if(n == false &amp;&amp; board[row + add][col] == 'B')\n                        n = true;\n                    if(n == false &amp;&amp; board[row + add][col] == 'p') {\n                        ans++;\n                        n = true;\n                    }\n                }\n            }\n            \n            if(w != true) {\n                if(col - add &lt; 0) {\n                    w = true;\n                } else {\n                    if(board[row][col - add] == 'B')\n                        w = true;\n                    if(w == false &amp;&amp; board[row][col - add] == 'p') {\n                        ans++;\n                        w = true;\n                    }\n                }\n            }\n            if(s != true) {\n                if(row - add &lt; 0) {\n                    s = true;\n                } else {\n                    if(board[row - add][col] == 'B')\n                        s = true;\n                    if(s == false &amp;&amp; board[row - add][col] == 'p') {\n                        ans++;\n                        s = true;\n                    }\n                }\n            }\n            if(n &amp;&amp; e &amp;&amp; w &amp;&amp; s)\n                break;\n            add++;\n            //cout &lt;&lt; n &lt;&lt; e &lt;&lt; w &lt;&lt; s &lt;&lt; endl;\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 999&gt; Available Captures for Rook\n\nclass Solution {\npublic:\n    int numRookCaptures(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        int row = 0;\n        int col = 0;\n        for(auto i : board) {\n            auto it = find(i.begin(), i.end(), 'R');\n            if(it != i.end()) {\n                col = it - i.begin();\n                break;\n            }\n            row++;\n        }\n        int add = 1;\n        bool n = false;\n        bool e = false;\n        bool w = false;\n        bool s = false;\n        int ans = 0;\n        while(true) {\n            if(e != true) {\n                if(col + add &gt;= 8) {\n                    e = true;\n                } else {\n                    if(e == false &amp;&amp; board[row][col + add] == 'B')\n                        e = true;\n                    if(e == false &amp;&amp; board[row][col + add] == 'p') {\n                        e = true;\n                        ans++;\n                    }\n                }\n            }\n            if(n != true) {\n                if(row + add &gt;= 8) {\n                    n = true;\n                } else {\n                    if(n == false &amp;&amp; board[row + add][col] == 'B')\n                        n = true;\n                    if(n == false &amp;&amp; board[row + add][col] == 'p') {\n                        ans++;\n                        n = true;\n                    }\n                }\n            }\n            \n            if(w != true) {\n                if(col - add &lt; 0) {\n                    w = true;\n                } else {\n                    if(board[row][col - add] == 'B')\n                        w = true;\n                    if(w == false &amp;&amp; board[row][col - add] == 'p') {\n                        ans++;\n                        w = true;\n                    }\n                }\n            }\n            if(s != true) {\n                if(row - add &lt; 0) {\n                    s = true;\n                } else {\n                    if(board[row - add][col] == 'B')\n                        s = true;\n                    if(s == false &amp;&amp; board[row - add][col] == 'p') {\n                        ans++;\n                        s = true;\n                    }\n                }\n            }\n            if(n &amp;&amp; e &amp;&amp; w &amp;&amp; s)\n                break;\n            add++;\n            //cout &lt;&lt; n &lt;&lt; e &lt;&lt; w &lt;&lt; s &lt;&lt; endl;\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/12/02/999-Available-Captures-for-Rook/"
      },
    
      {
        "title": "Matrix Cells in Distance Order",
        "excerpt": "&lt;-E 1030&gt; Matrix Cells in Distance Order\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; vec(201);\n        for (int i = 0; i &lt; R; ++i) {\n            for (int j = 0; j &lt; C; ++j) {\n                int dist = dis(i, j, r0, c0);\n                vec[dist].push_back(make_pair(i, j));\n            }\n        }\n        for (int i = 0; i &lt; vec.size(); ++i) {\n            for (int j = 0; j &lt; vec[i].size(); ++j) {\n                res.push_back({vec[i][j].first, vec[i][j].second});\n            }\n        }\n        return res;\n    }\n    \n    int dis(int r1, int c1, int r2, int c2) {\n        return abs(r1 - r2) + abs(c1 - c2);\n    }\n};\n\n\n",
        "content": "&lt;-E 1030&gt; Matrix Cells in Distance Order\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; vec(201);\n        for (int i = 0; i &lt; R; ++i) {\n            for (int j = 0; j &lt; C; ++j) {\n                int dist = dis(i, j, r0, c0);\n                vec[dist].push_back(make_pair(i, j));\n            }\n        }\n        for (int i = 0; i &lt; vec.size(); ++i) {\n            for (int j = 0; j &lt; vec[i].size(); ++j) {\n                res.push_back({vec[i][j].first, vec[i][j].second});\n            }\n        }\n        return res;\n    }\n    \n    int dis(int r1, int c1, int r2, int c2) {\n        return abs(r1 - r2) + abs(c1 - c2);\n    }\n};\n\n\n",
        "url": "/2020/12/03/1030-Matrix-Cells-in-Distance-Order/"
      },
    
      {
        "title": "Uncommon Words from Two Sentences",
        "excerpt": "&lt;-E 884&gt; Uncommon Words from Two Sentences\n\nclass Solution {\npublic:\n    void addWords(unordered_map&lt;string,int&gt;&amp; m, const string&amp; s) {\n        string t;\n        for(auto i:s) {\n            if(i==' ') {\n                if(!t.empty()) {\n                    ++m[t];\n                    t.clear();\n                }\n            }\n            else t+=i;\n        }\n        if(!t.empty()) ++m[t];\n    }\n    \n    vector&lt;string&gt; uncommonFromSentences(const string&amp; A, const string&amp; B) {\n        unordered_map&lt;string,int&gt; m;\n        addWords(m,A);\n        addWords(m,B);\n        vector&lt;string&gt; v;\n        for(const auto&amp; i:m)\n            if(i.second==1) v.push_back(i.first);\n        return v;\n    }\n};\n\n\n\n",
        "content": "&lt;-E 884&gt; Uncommon Words from Two Sentences\n\nclass Solution {\npublic:\n    void addWords(unordered_map&lt;string,int&gt;&amp; m, const string&amp; s) {\n        string t;\n        for(auto i:s) {\n            if(i==' ') {\n                if(!t.empty()) {\n                    ++m[t];\n                    t.clear();\n                }\n            }\n            else t+=i;\n        }\n        if(!t.empty()) ++m[t];\n    }\n    \n    vector&lt;string&gt; uncommonFromSentences(const string&amp; A, const string&amp; B) {\n        unordered_map&lt;string,int&gt; m;\n        addWords(m,A);\n        addWords(m,B);\n        vector&lt;string&gt; v;\n        for(const auto&amp; i:m)\n            if(i.second==1) v.push_back(i.first);\n        return v;\n    }\n};\n\n\n\n",
        "url": "/2020/12/03/884-Uncommon-Words-from-Two-Sentences/"
      },
    
      {
        "title": "Special Positions in a Binary Matrix",
        "excerpt": "&lt;-E 1582&gt; Special Positions in a Binary Matrix\n\nclass Solution {\npublic:\n    bool isSingle(const vector&lt;vector&lt;int&gt;&gt;&amp; mat,int row,int col) {\n        int count=0;\n        for(auto i:mat[row])\n            if(i and ++count&gt;1) return false;\n            \n        count=0;\n        for(const auto&amp; i:mat)\n            if(i[col] and ++count&gt;1) return false;\n        \n        return true;\n    }\n    \n    int numSpecial(const vector&lt;vector&lt;int&gt;&gt;&amp; mat) {\n        int count=0;\n        for(int i=0; i&lt;mat.size(); ++i)\n            for(int j=0; j&lt;mat[0].size(); ++j)\n                if(mat[i][j] and isSingle(mat,i,j)) ++count;\n        return count;\n    }\n};\n\n\n",
        "content": "&lt;-E 1582&gt; Special Positions in a Binary Matrix\n\nclass Solution {\npublic:\n    bool isSingle(const vector&lt;vector&lt;int&gt;&gt;&amp; mat,int row,int col) {\n        int count=0;\n        for(auto i:mat[row])\n            if(i and ++count&gt;1) return false;\n            \n        count=0;\n        for(const auto&amp; i:mat)\n            if(i[col] and ++count&gt;1) return false;\n        \n        return true;\n    }\n    \n    int numSpecial(const vector&lt;vector&lt;int&gt;&gt;&amp; mat) {\n        int count=0;\n        for(int i=0; i&lt;mat.size(); ++i)\n            for(int j=0; j&lt;mat[0].size(); ++j)\n                if(mat[i][j] and isSingle(mat,i,j)) ++count;\n        return count;\n    }\n};\n\n\n",
        "url": "/2020/12/04/1582-Special-Positions-in-a-Binary-Matrix/"
      },
    
      {
        "title": "Univalued Binary Tree",
        "excerpt": "&lt;-E 965&gt; Univalued Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\n    \npublic:\n    bool isUnivalTree(TreeNode* root) {\n        queue &lt;TreeNode *&gt; q ;\n        q.push(root) ;\n        \n        while(!q.empty())\n        {\n            TreeNode *x = q.front() ;\n            q.pop() ;\n            \n            if(x-&gt;left)\n            {\n                q.push(x-&gt;left) ;\n                if(x-&gt;val != x-&gt;left-&gt;val)\n                    return false ;\n            }\n            if(x-&gt;right)\n            {\n                q.push(x-&gt;right) ;\n                if(x-&gt;val != x-&gt;right-&gt;val)\n                    return false ;\n            }\n        }\n        return true ;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isUnivalTree(TreeNode* root) {\n        if(!root) return true;\n        int val = root-&gt;val;\n        return dfs(root, val);\n    }\nprivate:\n    bool dfs(TreeNode* root, int&amp; val){\n        if(!root) return true;\n        if(root-&gt;val != val) return false;\n        return dfs(root-&gt;left, val) &amp;&amp; dfs(root-&gt;right, val);\n    }\n};\n\n\n",
        "content": "&lt;-E 965&gt; Univalued Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\n    \npublic:\n    bool isUnivalTree(TreeNode* root) {\n        queue &lt;TreeNode *&gt; q ;\n        q.push(root) ;\n        \n        while(!q.empty())\n        {\n            TreeNode *x = q.front() ;\n            q.pop() ;\n            \n            if(x-&gt;left)\n            {\n                q.push(x-&gt;left) ;\n                if(x-&gt;val != x-&gt;left-&gt;val)\n                    return false ;\n            }\n            if(x-&gt;right)\n            {\n                q.push(x-&gt;right) ;\n                if(x-&gt;val != x-&gt;right-&gt;val)\n                    return false ;\n            }\n        }\n        return true ;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isUnivalTree(TreeNode* root) {\n        if(!root) return true;\n        int val = root-&gt;val;\n        return dfs(root, val);\n    }\nprivate:\n    bool dfs(TreeNode* root, int&amp; val){\n        if(!root) return true;\n        if(root-&gt;val != val) return false;\n        return dfs(root-&gt;left, val) &amp;&amp; dfs(root-&gt;right, val);\n    }\n};\n\n\n",
        "url": "/2020/12/04/965-Univalued-Binary-Tree/"
      },
    
      {
        "title": "Prime Number of Set Bits in Binary Representation",
        "excerpt": "&lt;-E 762&gt; Prime Number of Set Bits in Binary Representation\n\nclass Solution {\npublic:\n    int countPrimeSetBits(int L, int R) {\n        int res = 0;\n        for (int num = L; num &lt;= R; num++) {\n            int cnt = __builtin_popcount(num);\n            res += cnt &lt; 4 ? cnt &gt; 1 : (cnt % 2 &amp;&amp; cnt % 3);\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 762&gt; Prime Number of Set Bits in Binary Representation\n\nclass Solution {\npublic:\n    int countPrimeSetBits(int L, int R) {\n        int res = 0;\n        for (int num = L; num &lt;= R; num++) {\n            int cnt = __builtin_popcount(num);\n            res += cnt &lt; 4 ? cnt &gt; 1 : (cnt % 2 &amp;&amp; cnt % 3);\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/05/762-Prime-Number-of-Set-Bits-in-Binary-Representation/"
      },
    
      {
        "title": "Middle of the Linked List",
        "excerpt": "&lt;-E 876&gt; Middle of the Linked List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *slow=head;\n        ListNode *fast=head;\n        while(fast&amp;&amp;fast-&gt;next)\n        {\n            slow=slow-&gt;next;\n            fast=fast-&gt;next-&gt;next;\n        }\n        return slow;\n    }\n};\n\n\n",
        "content": "&lt;-E 876&gt; Middle of the Linked List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *slow=head;\n        ListNode *fast=head;\n        while(fast&amp;&amp;fast-&gt;next)\n        {\n            slow=slow-&gt;next;\n            fast=fast-&gt;next-&gt;next;\n        }\n        return slow;\n    }\n};\n\n\n",
        "url": "/2020/12/05/876-Middle-of-the-Linked-List/"
      },
    
      {
        "title": "Crawler Log Folder",
        "excerpt": "&lt;-E 1598&gt; Crawler Log Folder\n\nclass Solution {\npublic:\n    int minOperations(vector&lt;string&gt;&amp; logs) {\n       stack&lt;int&gt; s;\n        for(int i = 0; i &lt; logs.size(); i++){\n            if(logs[i] == \"./\") continue;\n            else if(logs[i] == \"../\"){\n                if(!s.empty()) \n                    s.pop();\n            }\n            else \n                s.push(1);\n        }\n        return s.size();\n    }\n};\n\nclass Solution {\npublic:\n    int minOperations(vector&lt;string&gt;&amp; logs) {\n        \n        int n = logs.size();\n        \n        if(n == 0) \n            return n;\n        int count = 0；\n        int ans = 0;\n                \n        for(int i = n - 1; i &gt;= 0; i--){\n            if(logs[i] == \"../\") \n                count++;\n            if(logs[i] != \"./\" &amp;&amp; logs[i] != \"../\"){\n                if(count&gt;0) \n                    count--;\n                else \n                    ans++;\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1598&gt; Crawler Log Folder\n\nclass Solution {\npublic:\n    int minOperations(vector&lt;string&gt;&amp; logs) {\n       stack&lt;int&gt; s;\n        for(int i = 0; i &lt; logs.size(); i++){\n            if(logs[i] == \"./\") continue;\n            else if(logs[i] == \"../\"){\n                if(!s.empty()) \n                    s.pop();\n            }\n            else \n                s.push(1);\n        }\n        return s.size();\n    }\n};\n\nclass Solution {\npublic:\n    int minOperations(vector&lt;string&gt;&amp; logs) {\n        \n        int n = logs.size();\n        \n        if(n == 0) \n            return n;\n        int count = 0；\n        int ans = 0;\n                \n        for(int i = n - 1; i &gt;= 0; i--){\n            if(logs[i] == \"../\") \n                count++;\n            if(logs[i] != \"./\" &amp;&amp; logs[i] != \"../\"){\n                if(count&gt;0) \n                    count--;\n                else \n                    ans++;\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/12/06/1598-Crawler-Log-Foldery/"
      },
    
      {
        "title": "Groups of Special-Equivalent Strings",
        "excerpt": "&lt;-E 893&gt; Groups of Special-Equivalent Strings\n\nclass Solution {\npublic:\n    int numSpecialEquivGroups(vector&lt;string&gt;&amp; A) {\n        unordered_set&lt;string&gt; us;\n        for(auto i : A) {\n            string check(52,0);\n            for(int j = 0; j != i.size(); j++) \n                check[i[j] - 'a' + 26 * (j%2)]++;           \n            us.insert(check);\n        }\n        return us.size();\n    }\n};\n\n\n",
        "content": "&lt;-E 893&gt; Groups of Special-Equivalent Strings\n\nclass Solution {\npublic:\n    int numSpecialEquivGroups(vector&lt;string&gt;&amp; A) {\n        unordered_set&lt;string&gt; us;\n        for(auto i : A) {\n            string check(52,0);\n            for(int j = 0; j != i.size(); j++) \n                check[i[j] - 'a' + 26 * (j%2)]++;           \n            us.insert(check);\n        }\n        return us.size();\n    }\n};\n\n\n",
        "url": "/2020/12/06/893-Groups-of-Special-Equivalent-Strings/"
      },
    
      {
        "title": "Design HashSet",
        "excerpt": "&lt;-E 705&gt; Design HashSet\n\nclass MyHashSet {\npublic:\n    vector&lt;bool&gt; set;\n    /** Initialize your data structure here. */\n    MyHashSet() {\n        set = vector&lt;bool&gt;(1000000,false);\n    }\n    \n    void add(int key) {\n        set[key] = true;\n    }\n    \n    void remove(int key) {\n        set[key] = false;\n    }\n    \n    /** Returns true if this set contains the specified element */\n    bool contains(int key) {\n        return set[key] == true;\n    }\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj = new MyHashSet();\n * obj-&gt;add(key);\n * obj-&gt;remove(key);\n * bool param_3 = obj-&gt;contains(key);\n */\n\n\n",
        "content": "&lt;-E 705&gt; Design HashSet\n\nclass MyHashSet {\npublic:\n    vector&lt;bool&gt; set;\n    /** Initialize your data structure here. */\n    MyHashSet() {\n        set = vector&lt;bool&gt;(1000000,false);\n    }\n    \n    void add(int key) {\n        set[key] = true;\n    }\n    \n    void remove(int key) {\n        set[key] = false;\n    }\n    \n    /** Returns true if this set contains the specified element */\n    bool contains(int key) {\n        return set[key] == true;\n    }\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj = new MyHashSet();\n * obj-&gt;add(key);\n * obj-&gt;remove(key);\n * bool param_3 = obj-&gt;contains(key);\n */\n\n\n",
        "url": "/2020/12/07/705-Design-HashSet/"
      },
    
      {
        "title": "Design HashMap",
        "excerpt": "&lt;-E 706&gt; Design HashMap\n\nclass MyHashMap {\npublic:\n    /** Initialize your data structure here. */\n    \n    int hash(int key){\n        \n        return (key%10000);\n    }\n    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;map;\n    MyHashMap() {\n        \n        map.resize(10000,{});\n        \n    }\n    \n    /** value will always be non-negative. */\n    void put(int key, int value) {\n        \n        int hash_val = hash(key);\n        for(int i = 0 ; i &lt; map[hash_val].size() ; i++){\n            if(map[hash_val][i].first == key){\n                 map[hash_val][i].second = value;\n                //cout&lt;&lt;\"here\";\n                return;\n            }\n        }\n        map[hash_val].push_back({key,value});\n        \n        return;\n        \n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    int get(int key) {\n       int hash_val = hash(key);\n        for(auto a : map[hash_val]){\n            if(a.first == key){\n                return a.second;\n            }\n        }\n        \n        return -1;\n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    void remove(int key) {\n        \n        int hash_val = hash(key);\n        for(int i = 0 ; i &lt; map[hash_val].size() ; i++){\n            \n            if(map[hash_val][i].first == key){\n                map[hash_val].erase(map[hash_val].begin()+i);\n                return;\n            }\n            \n        }\n        \n        return;\n        \n    }\n};\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj-&gt;put(key,value);\n * int param_2 = obj-&gt;get(key);\n * obj-&gt;remove(key);\n */\n\n\n",
        "content": "&lt;-E 706&gt; Design HashMap\n\nclass MyHashMap {\npublic:\n    /** Initialize your data structure here. */\n    \n    int hash(int key){\n        \n        return (key%10000);\n    }\n    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt;map;\n    MyHashMap() {\n        \n        map.resize(10000,{});\n        \n    }\n    \n    /** value will always be non-negative. */\n    void put(int key, int value) {\n        \n        int hash_val = hash(key);\n        for(int i = 0 ; i &lt; map[hash_val].size() ; i++){\n            if(map[hash_val][i].first == key){\n                 map[hash_val][i].second = value;\n                //cout&lt;&lt;\"here\";\n                return;\n            }\n        }\n        map[hash_val].push_back({key,value});\n        \n        return;\n        \n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    int get(int key) {\n       int hash_val = hash(key);\n        for(auto a : map[hash_val]){\n            if(a.first == key){\n                return a.second;\n            }\n        }\n        \n        return -1;\n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    void remove(int key) {\n        \n        int hash_val = hash(key);\n        for(int i = 0 ; i &lt; map[hash_val].size() ; i++){\n            \n            if(map[hash_val][i].first == key){\n                map[hash_val].erase(map[hash_val].begin()+i);\n                return;\n            }\n            \n        }\n        \n        return;\n        \n    }\n};\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj-&gt;put(key,value);\n * int param_2 = obj-&gt;get(key);\n * obj-&gt;remove(key);\n */\n\n\n",
        "url": "/2020/12/07/706-Design-HashMap/"
      },
    
      {
        "title": "Divisor Game",
        "excerpt": "&lt;-E 1025&gt; Divisor Game\n\n// Method 1\nclass Solution {\npublic:\n    bool divisorGame(int N) {\n        if(N % 2 == 0)\n            return true;\n        else\n            return false;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int dp[1001] ;\n    int help(int N) {\n        if(N == 1)\n            return 0;\n        if(dp[N] != -1)\n            return dp[N];\n        else {\n            for(int i = 1; i * i &lt;= N; i++) {\n                if(N % i == 0) {\n                    if(help(N - i) == 0)\n                        return dp[N] = 1;\n                    if((i != 1) &amp;&amp; help(N - (N /i)) == 0)\n                        return dp[N] = 1;\n                }\n            }\n        }\n        return dp[N] = 0;\n    }\n    bool divisorGame(int N) {\n        memset(dp, -1, sizeof(dp));\n        return help(N);\n    }\n};\n\n\n\n",
        "content": "&lt;-E 1025&gt; Divisor Game\n\n// Method 1\nclass Solution {\npublic:\n    bool divisorGame(int N) {\n        if(N % 2 == 0)\n            return true;\n        else\n            return false;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int dp[1001] ;\n    int help(int N) {\n        if(N == 1)\n            return 0;\n        if(dp[N] != -1)\n            return dp[N];\n        else {\n            for(int i = 1; i * i &lt;= N; i++) {\n                if(N % i == 0) {\n                    if(help(N - i) == 0)\n                        return dp[N] = 1;\n                    if((i != 1) &amp;&amp; help(N - (N /i)) == 0)\n                        return dp[N] = 1;\n                }\n            }\n        }\n        return dp[N] = 0;\n    }\n    bool divisorGame(int N) {\n        memset(dp, -1, sizeof(dp));\n        return help(N);\n    }\n};\n\n\n\n",
        "url": "/2020/12/08/1025-Divisor-Game/"
      },
    
      {
        "title": "Occurrences After Bigram",
        "excerpt": "&lt;-E 1078&gt; Occurrences After Bigram\n\nclass Solution {\npublic:\n    vector&lt;string&gt; findOcurrences(string text, string first, string second) {\n        vector&lt;string&gt; result;\n        stringstream ss(text);\n        string token1, token2, token3;\n        \n        while(!ss.eof()) {\n            ss &gt;&gt; token3;\n            if (token1 == first &amp;&amp; token2 == second)\n                result.push_back(token3);\n            \n            token1 = std::move(token2), token2 = std::move(token3);\n        }\n        \n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-E 1078&gt; Occurrences After Bigram\n\nclass Solution {\npublic:\n    vector&lt;string&gt; findOcurrences(string text, string first, string second) {\n        vector&lt;string&gt; result;\n        stringstream ss(text);\n        string token1, token2, token3;\n        \n        while(!ss.eof()) {\n            ss &gt;&gt; token3;\n            if (token1 == first &amp;&amp; token2 == second)\n                result.push_back(token3);\n            \n            token1 = std::move(token2), token2 = std::move(token3);\n        }\n        \n        return result;\n    }\n};\n\n\n",
        "url": "/2020/12/08/1078-Occurrences-After-Bigram/"
      },
    
      {
        "title": "Count Largest Group",
        "excerpt": "&lt;-E 1399&gt; Count Largest Group\n\n// Method 1\nclass Solution {\npublic:\n    int findDigitsSum(int x){\n        int sum = 0;\n        while(x != 0){\n            sum += (x % 10);\n            x /= 10;\n        }\n        return sum;\n    }\n    int countLargestGroup(int n) {\n        unordered_map&lt;int, int&gt; umap;\n        int maxi = 0;\n        for(int i = 1; i &lt;= n; i++){\n            int sum = findDigitsSum(i);\n            umap[sum]++;\n            if(umap[sum] &gt;= maxi)\n             maxi = umap[sum];\n        }\n        int rep = 0;\n        for (auto x : umap) \n            if(x.second==maxi)\n                rep++;\n        return rep;\n    }\n};\n\n\nclass Solution {\npublic:\n    int countLargestGroup(int n) {\n        vector&lt;int&gt; c(100);\n        vector&lt;int&gt; dp(10000,0);\n        int m = 0;\n        for(int i = 1; i &lt;= n; i++){\n            dp[i] = i % 10 + dp[i/10];\n            m = max(m, ++c[dp[i]]);\n        }\n        int ret = 0;\n        for(int i = 1; i &lt; c.size(); i++){\n            if(c[i] == m){\n                ret++;\n            }\n        }\n        return ret;\n    }\n};\n\n\n",
        "content": "&lt;-E 1399&gt; Count Largest Group\n\n// Method 1\nclass Solution {\npublic:\n    int findDigitsSum(int x){\n        int sum = 0;\n        while(x != 0){\n            sum += (x % 10);\n            x /= 10;\n        }\n        return sum;\n    }\n    int countLargestGroup(int n) {\n        unordered_map&lt;int, int&gt; umap;\n        int maxi = 0;\n        for(int i = 1; i &lt;= n; i++){\n            int sum = findDigitsSum(i);\n            umap[sum]++;\n            if(umap[sum] &gt;= maxi)\n             maxi = umap[sum];\n        }\n        int rep = 0;\n        for (auto x : umap) \n            if(x.second==maxi)\n                rep++;\n        return rep;\n    }\n};\n\n\nclass Solution {\npublic:\n    int countLargestGroup(int n) {\n        vector&lt;int&gt; c(100);\n        vector&lt;int&gt; dp(10000,0);\n        int m = 0;\n        for(int i = 1; i &lt;= n; i++){\n            dp[i] = i % 10 + dp[i/10];\n            m = max(m, ++c[dp[i]]);\n        }\n        int ret = 0;\n        for(int i = 1; i &lt; c.size(); i++){\n            if(c[i] == m){\n                ret++;\n            }\n        }\n        return ret;\n    }\n};\n\n\n",
        "url": "/2020/12/08/1399-Count-Largest-Group/"
      },
    
      {
        "title": "Minimum Value to Get Positive Step by Step Sum",
        "excerpt": "&lt;-E 1413&gt; Minimum Value to Get Positive Step by Step Sum\n\n\n// Method 1\nclass Solution {\npublic:\n    int minStartValue(vector&lt;int&gt;&amp; nums) {\n        int s = 0;\n        int minSum = 0;\n        for (int num : nums) {\n            s += num;\n            if (s &lt; minSum) {\n                minSum = s;\n            }\n        }\n        return 1 - minSum;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int minStartValue(vector&lt;int&gt;&amp; nums) {\n        int ret = 1;\n        int tmp = ret;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            tmp = tmp + nums[i];\n            if(tmp &lt; 1) {\n                ret += (1-tmp);\n                tmp = 1;\n            }\n        }\n        \n        return ret;\n    }\n};\n\n\n",
        "content": "&lt;-E 1413&gt; Minimum Value to Get Positive Step by Step Sum\n\n\n// Method 1\nclass Solution {\npublic:\n    int minStartValue(vector&lt;int&gt;&amp; nums) {\n        int s = 0;\n        int minSum = 0;\n        for (int num : nums) {\n            s += num;\n            if (s &lt; minSum) {\n                minSum = s;\n            }\n        }\n        return 1 - minSum;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int minStartValue(vector&lt;int&gt;&amp; nums) {\n        int ret = 1;\n        int tmp = ret;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            tmp = tmp + nums[i];\n            if(tmp &lt; 1) {\n                ret += (1-tmp);\n                tmp = 1;\n            }\n        }\n        \n        return ret;\n    }\n};\n\n\n",
        "url": "/2020/12/08/1413-Minimum-Value-to-Get-Positive-Step-by-Step-Sum/"
      },
    
      {
        "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "excerpt": "&lt;-E 1455&gt; Check If a Word Occurs As a Prefix of Any Word in a Sentence\n\nclass Solution {\npublic:\n    int isPrefixOfWord(string sentence, string searchWord) {\n        stringstream s(sentence);\n        string word;\n        int count = 1;\n        while(s &gt;&gt; word){\n            if (word.substr(0,searchWord.size()) == searchWord){\n                return count;\n            }\n            count+= 1;\n        }\n        return -1;\n    }\n};\n\n\n",
        "content": "&lt;-E 1455&gt; Check If a Word Occurs As a Prefix of Any Word in a Sentence\n\nclass Solution {\npublic:\n    int isPrefixOfWord(string sentence, string searchWord) {\n        stringstream s(sentence);\n        string word;\n        int count = 1;\n        while(s &gt;&gt; word){\n            if (word.substr(0,searchWord.size()) == searchWord){\n                return count;\n            }\n            count+= 1;\n        }\n        return -1;\n    }\n};\n\n\n",
        "url": "/2020/12/08/1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/"
      },
    
      {
        "title": "Three Consecutive Odds",
        "excerpt": "&lt;-E 1550&gt; Three Consecutive Odds\n\nclass Solution {\npublic:\n    bool threeConsecutiveOdds(vector&lt;int&gt;&amp; arr) {\n        \n        if(arr.size()&lt;2)\n            return false;\n\t\tfor(int i = 0; i &lt; arr.size() - 2;i++){\n\t\t\tif(arr[i] % 2 != 0 &amp;&amp; arr[i + 1] % 2 != 0 &amp;&amp; arr[i + 2] % 2 !=0) \n                return true;\n\t\t}\n\t\treturn false;\n    }\n};\n\n\n",
        "content": "&lt;-E 1550&gt; Three Consecutive Odds\n\nclass Solution {\npublic:\n    bool threeConsecutiveOdds(vector&lt;int&gt;&amp; arr) {\n        \n        if(arr.size()&lt;2)\n            return false;\n\t\tfor(int i = 0; i &lt; arr.size() - 2;i++){\n\t\t\tif(arr[i] % 2 != 0 &amp;&amp; arr[i + 1] % 2 != 0 &amp;&amp; arr[i + 2] % 2 !=0) \n                return true;\n\t\t}\n\t\treturn false;\n    }\n};\n\n\n",
        "url": "/2020/12/08/1550-Three-Consecutive-Odds-copy/"
      },
    
      {
        "title": "Mean of Array After Removing Some Elements",
        "excerpt": "&lt;-E 1619&gt; Mean of Array After Removing Some Elements\n\nclass Solution {\npublic:\n    double trimMean(vector&lt;int&gt;&amp; arr) {\n        sort(arr.begin(), arr.end());\n        \n        int num = arr.size() *.05;\n        double sum = 0;\n        double count = 0;\n        for(int i = num; i &lt; arr.size() - num; i++){\n            sum += arr[i];\n            count++;\n        }\n\n        return sum / count;\n    }\n};\n\n\n",
        "content": "&lt;-E 1619&gt; Mean of Array After Removing Some Elements\n\nclass Solution {\npublic:\n    double trimMean(vector&lt;int&gt;&amp; arr) {\n        sort(arr.begin(), arr.end());\n        \n        int num = arr.size() *.05;\n        double sum = 0;\n        double count = 0;\n        for(int i = num; i &lt; arr.size() - num; i++){\n            sum += arr[i];\n            count++;\n        }\n\n        return sum / count;\n    }\n};\n\n\n",
        "url": "/2020/12/08/1619-Mean-of-Array-After-Removing-Some-Elements/"
      },
    
      {
        "title": "Invert Binary Tree",
        "excerpt": "&lt;-E 226&gt; Invert Binary Tree\n\n// Method 1\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root==NULL)\n            return NULL;\n\t\t\t\n        TreeNode* l=invertTree(root-&gt;left);\n        TreeNode* r=invertTree(root-&gt;right);\n\t\t\n        root-&gt;left=r;\n        root-&gt;right=l;\n\t\t\n        return root;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        \n        if(root==NULL) return NULL;\n        TreeNode* temp = root-&gt;left;\n        root-&gt;left = root-&gt;right;\n        root-&gt;right = temp;\n        \n        invertTree(root-&gt;left);\n        invertTree(root-&gt;right);\n        \n        return root;\n        \n        \n    }\n};\n\n\n",
        "content": "&lt;-E 226&gt; Invert Binary Tree\n\n// Method 1\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root==NULL)\n            return NULL;\n\t\t\t\n        TreeNode* l=invertTree(root-&gt;left);\n        TreeNode* r=invertTree(root-&gt;right);\n\t\t\n        root-&gt;left=r;\n        root-&gt;right=l;\n\t\t\n        return root;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        \n        if(root==NULL) return NULL;\n        TreeNode* temp = root-&gt;left;\n        root-&gt;left = root-&gt;right;\n        root-&gt;right = temp;\n        \n        invertTree(root-&gt;left);\n        invertTree(root-&gt;right);\n        \n        return root;\n        \n        \n    }\n};\n\n\n",
        "url": "/2020/12/08/226-Invert-Binary-Tree/"
      },
    
      {
        "title": "Delete Node in a Linked List",
        "excerpt": "&lt;-E 237&gt; Delete Node in a Linked List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        auto nxt=node-&gt;next;\n        *node=*nxt;\n        delete nxt;\n    }\n};\n\n\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node-&gt;val=node-&gt;next-&gt;val;\n        auto del=node-&gt;next;\n        node-&gt;next=del-&gt;next;\n        delete del;\n    }\n};\n\n\n",
        "content": "&lt;-E 237&gt; Delete Node in a Linked List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        auto nxt=node-&gt;next;\n        *node=*nxt;\n        delete nxt;\n    }\n};\n\n\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node-&gt;val=node-&gt;next-&gt;val;\n        auto del=node-&gt;next;\n        node-&gt;next=del-&gt;next;\n        delete del;\n    }\n};\n\n\n",
        "url": "/2020/12/08/237-Delete-Node-in-a-Linked-List/"
      },
    
      {
        "title": "Intersection of Two Arrays",
        "excerpt": "&lt;-E 349&gt; Intersection of Two Arrays\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        map&lt;int, int&gt; check;\n        for(auto i : nums1) {\n            check[i]++;\n        }\n        set&lt;int&gt; output;\n        for(auto i : nums2) {\n           if(check.find(i) != check.end())\n              output.insert(i);\n        }\n        vector&lt;int&gt; ans(output.begin(),output.end());\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        unordered_set&lt;int&gt; first(nums1.begin(), nums1.end());\n        unordered_set&lt;int&gt; res;\n        \n        \n        for (int num : nums2) {\n            if (first.find(num) != first.end()) {\n                res.insert(num);\n            }\n        }\n        \n        vector&lt;int&gt; sol(res.begin(), res.end());\n        \n        return sol;\n    }\n};\n\n\n",
        "content": "&lt;-E 349&gt; Intersection of Two Arrays\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        map&lt;int, int&gt; check;\n        for(auto i : nums1) {\n            check[i]++;\n        }\n        set&lt;int&gt; output;\n        for(auto i : nums2) {\n           if(check.find(i) != check.end())\n              output.insert(i);\n        }\n        vector&lt;int&gt; ans(output.begin(),output.end());\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        unordered_set&lt;int&gt; first(nums1.begin(), nums1.end());\n        unordered_set&lt;int&gt; res;\n        \n        \n        for (int num : nums2) {\n            if (first.find(num) != first.end()) {\n                res.insert(num);\n            }\n        }\n        \n        vector&lt;int&gt; sol(res.begin(), res.end());\n        \n        return sol;\n    }\n};\n\n\n",
        "url": "/2020/12/08/349-Intersection-of-Two-Arrays/"
      },
    
      {
        "title": "Average of Levels in Binary Tree",
        "excerpt": "&lt;-E 637&gt; Average of Levels in Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;double&gt; averageOfLevels(TreeNode* root) {\n        \n        vector&lt;double&gt; avg;\n        \n        queue&lt;TreeNode*&gt; q;\n        \n        long long sum(0);\n        int n(1), n_bup(1);\n        \n        if(root != nullptr)\n            q.push(root);\n        while(!q.empty()) {\n            while(n--) {\n                sum += q.front()-&gt;val;\n                \n                if(q.front()-&gt;left != nullptr)\n                    q.push(q.front()-&gt;left);\n                \n                if(q.front()-&gt;right != nullptr)\n                    q.push(q.front()-&gt;right);\n                \n                q.pop();\n            }\n            avg.push_back((double)sum/n_bup);\n            sum = 0;\n            n = n_bup = q.size();\n        }\n        \n        return avg;\n        \n    }\n};\n\n\n",
        "content": "&lt;-E 637&gt; Average of Levels in Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;double&gt; averageOfLevels(TreeNode* root) {\n        \n        vector&lt;double&gt; avg;\n        \n        queue&lt;TreeNode*&gt; q;\n        \n        long long sum(0);\n        int n(1), n_bup(1);\n        \n        if(root != nullptr)\n            q.push(root);\n        while(!q.empty()) {\n            while(n--) {\n                sum += q.front()-&gt;val;\n                \n                if(q.front()-&gt;left != nullptr)\n                    q.push(q.front()-&gt;left);\n                \n                if(q.front()-&gt;right != nullptr)\n                    q.push(q.front()-&gt;right);\n                \n                q.pop();\n            }\n            avg.push_back((double)sum/n_bup);\n            sum = 0;\n            n = n_bup = q.size();\n        }\n        \n        return avg;\n        \n    }\n};\n\n\n",
        "url": "/2020/12/08/637-Average-of-Levels-in-Binary-Tree/"
      },
    
      {
        "title": "Baseball Game",
        "excerpt": "&lt;-E 682&gt; Baseball Game\n\nclass Solution {\npublic:\n    int calPoints(vector&lt;string&gt;&amp; ops) {\n       vector&lt;int&gt; s;\n        for(auto i : ops){\n            if(i == \"+\")\n                s.push_back(s[s.size()-1]+s[s.size()-2]);\n            else if(i == \"D\")\n                s.push_back(s[s.size()-1]*2);\n            else if(i == \"C\")\n                s.pop_back();\n            else s.push_back(stoi(i));\n        }\n        return accumulate(s.begin(),s.end(),0);\n    }\n};\n\n\n",
        "content": "&lt;-E 682&gt; Baseball Game\n\nclass Solution {\npublic:\n    int calPoints(vector&lt;string&gt;&amp; ops) {\n       vector&lt;int&gt; s;\n        for(auto i : ops){\n            if(i == \"+\")\n                s.push_back(s[s.size()-1]+s[s.size()-2]);\n            else if(i == \"D\")\n                s.push_back(s[s.size()-1]*2);\n            else if(i == \"C\")\n                s.pop_back();\n            else s.push_back(stoi(i));\n        }\n        return accumulate(s.begin(),s.end(),0);\n    }\n};\n\n\n",
        "url": "/2020/12/08/682-Baseball-Game/"
      },
    
      {
        "title": "Toeplitz Matrix",
        "excerpt": "&lt;-E 766&gt; Toeplitz Matrix\n\nclass Solution {\npublic:\n    bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        for(int i = 1; i &lt; matrix.size(); i++)\n            for(int j = 1; j &lt; matrix[1].size(); j++)\n                if(matrix[i][j] != matrix[i-1][j-1])\n                    return false;\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 766&gt; Toeplitz Matrix\n\nclass Solution {\npublic:\n    bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        for(int i = 1; i &lt; matrix.size(); i++)\n            for(int j = 1; j &lt; matrix[1].size(); j++)\n                if(matrix[i][j] != matrix[i-1][j-1])\n                    return false;\n        return true;\n    }\n};\n\n\n",
        "url": "/2020/12/08/766-Toeplitz-Matrix/"
      },
    
      {
        "title": "Number of Lines To Write String",
        "excerpt": "&lt;-E 806&gt; Number of Lines To Write String\n\nclass Solution {\npublic:\n    vector&lt;int&gt; numberOfLines(vector&lt;int&gt;&amp; widths, string S) {\n         int W = 0, L = 1;\n        for(auto i:S) {\n            W += widths[i - 'a'];\n            if(100 &lt; W) { \n                W = widths[i - 'a']; \n                L++; \n            }\n        }\n        return {L, W};\n    }\n};\n\n\n",
        "content": "&lt;-E 806&gt; Number of Lines To Write String\n\nclass Solution {\npublic:\n    vector&lt;int&gt; numberOfLines(vector&lt;int&gt;&amp; widths, string S) {\n         int W = 0, L = 1;\n        for(auto i:S) {\n            W += widths[i - 'a'];\n            if(100 &lt; W) { \n                W = widths[i - 'a']; \n                L++; \n            }\n        }\n        return {L, W};\n    }\n};\n\n\n",
        "url": "/2020/12/08/806-Number-of-Lines-To-Write-String/"
      },
    
      {
        "title": "Leaf-Similar Trees",
        "excerpt": "&lt;-E 872&gt; Leaf-Similar Trees\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void traverseTree(TreeNode* &amp;root, vector&lt;int&gt; &amp;vals){\n        \n        if (!root-&gt;left &amp;&amp; !root-&gt;right){\n            vals.push_back(root-&gt;val);\n        }\n        if (root-&gt;left) {traverseTree(root-&gt;left,vals);}\n        if (root-&gt;right) {traverseTree(root-&gt;right,vals);}\n    }\n    \n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector&lt;int&gt; val1;\n        vector&lt;int&gt; val2;\n        traverseTree(root1,val1);\n        traverseTree(root2,val2);\n        if (val1.size() != val2.size()){\n            return false;\n        }\n        for(int i = 0;i &lt; val1.size(); ++i){\n            if (val1[i] != val2[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 872&gt; Leaf-Similar Trees\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void traverseTree(TreeNode* &amp;root, vector&lt;int&gt; &amp;vals){\n        \n        if (!root-&gt;left &amp;&amp; !root-&gt;right){\n            vals.push_back(root-&gt;val);\n        }\n        if (root-&gt;left) {traverseTree(root-&gt;left,vals);}\n        if (root-&gt;right) {traverseTree(root-&gt;right,vals);}\n    }\n    \n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector&lt;int&gt; val1;\n        vector&lt;int&gt; val2;\n        traverseTree(root1,val1);\n        traverseTree(root2,val2);\n        if (val1.size() != val2.size()){\n            return false;\n        }\n        for(int i = 0;i &lt; val1.size(); ++i){\n            if (val1[i] != val2[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2020/12/08/872-Leaf-Similar-Trees/"
      },
    
      {
        "title": "Smallest Range I",
        "excerpt": "&lt;-E 908&gt; Smallest Range I\n\nclass Solution {\npublic:\n    int smallestRangeI(vector&lt;int&gt;&amp; A, int K) {\n        return max(0, *max_element(A.begin(), A.end()) - K - (*min_element(A.begin(), A.end()) + K));\n    }\n};\n\n\n",
        "content": "&lt;-E 908&gt; Smallest Range I\n\nclass Solution {\npublic:\n    int smallestRangeI(vector&lt;int&gt;&amp; A, int K) {\n        return max(0, *max_element(A.begin(), A.end()) - K - (*min_element(A.begin(), A.end()) + K));\n    }\n};\n\n\n",
        "url": "/2020/12/08/908-Smallest-Range-I/"
      },
    
      {
        "title": "Richest Customer Wealth",
        "excerpt": "&lt;-E 1672&gt; Richest Customer Wealth\n\nclass Solution {\npublic:\n    int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) {\n        int ans = -1;\n        for(auto i : accounts){\n            ans = max(accumulate(i.begin(), i.end(), 0), ans);\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1672&gt; Richest Customer Wealth\n\nclass Solution {\npublic:\n    int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) {\n        int ans = -1;\n        for(auto i : accounts){\n            ans = max(accumulate(i.begin(), i.end(), 0), ans);\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/12/09/1672-Richest-Customer-Wealth/"
      },
    
      {
        "title": "Goal Parser Interpretation",
        "excerpt": "&lt;-E 1678&gt; Goal Parser Interpretation\n\nclass Solution {\npublic:\n    string interpret(string command) {\n       string ans = \"\";\n        int i = 0;\n        int size = command.size();\n        while(i &lt; size) {\n            if(command[i] == 'G') {\n                i++;\n                ans += \"G\";\n            }\n            else \n                if(command[i] == '(') {\n                    if(command[i + 1] == ')') {\n                    i += 2;\n                    ans += \"o\";\n                    }\n                else {\n                    i += 4;\n                    ans += \"al\";\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1678&gt; Goal Parser Interpretation\n\nclass Solution {\npublic:\n    string interpret(string command) {\n       string ans = \"\";\n        int i = 0;\n        int size = command.size();\n        while(i &lt; size) {\n            if(command[i] == 'G') {\n                i++;\n                ans += \"G\";\n            }\n            else \n                if(command[i] == '(') {\n                    if(command[i + 1] == ')') {\n                    i += 2;\n                    ans += \"o\";\n                    }\n                else {\n                    i += 4;\n                    ans += \"al\";\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/12/09/1678-Goal-Parser-Interpretation/"
      },
    
      {
        "title": "Goal Parser Interpretation",
        "excerpt": "&lt;-E 1678&gt; Goal Parser Interpretation\n\n// Method 1\nclass Solution {\npublic:\n    int distributeCandies(vector&lt;int&gt;&amp; candyType) {\n        set&lt;int&gt; check;\n        int max = candyType.size() / 2;\n        for(auto i : candyType) {\n            check.insert(i);\n            if(check.size() &gt; max)\n                return max;\n        }\n        return check.size();\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int distributeCandies(vector&lt;int&gt;&amp; candies) {\n         bitset&lt;200001&gt; hash;\n        for (int i: candies)\n           hash.set(i + 100000);\n        return min(hash.count(), candies.size() / 2); \n    }\n};\n\n\n",
        "content": "&lt;-E 1678&gt; Goal Parser Interpretation\n\n// Method 1\nclass Solution {\npublic:\n    int distributeCandies(vector&lt;int&gt;&amp; candyType) {\n        set&lt;int&gt; check;\n        int max = candyType.size() / 2;\n        for(auto i : candyType) {\n            check.insert(i);\n            if(check.size() &gt; max)\n                return max;\n        }\n        return check.size();\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int distributeCandies(vector&lt;int&gt;&amp; candies) {\n         bitset&lt;200001&gt; hash;\n        for (int i: candies)\n           hash.set(i + 100000);\n        return min(hash.count(), candies.size() / 2); \n    }\n};\n\n\n",
        "url": "/2020/12/09/575-Distribute-Candies/"
      },
    
      {
        "title": "Goat Latin",
        "excerpt": "&lt;-E 824&gt; Goat Latin\n\nclass Solution {\npublic:\n    string toGoatLatin(string S) {\n        unordered_set&lt;char&gt; vowel({'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'});\n        istringstream iss(S);\n        string res, w;\n        int i = 0;\n        while (iss &gt;&gt; w) {\n            res += \" \";\n            if (vowel.count(w[0]) != 0) {\n                res += w;\n            } else {\n                res += w.substr(1) + w[0];\n            }\n            res += \"ma\";\n            \n            for (int j = 0; j &lt;= i; j++) {\n                res += \"a\";\n            }\n            \n            i++;\n        }\n        \n        return res.substr(1);\n    }\n};\n\n\n",
        "content": "&lt;-E 824&gt; Goat Latin\n\nclass Solution {\npublic:\n    string toGoatLatin(string S) {\n        unordered_set&lt;char&gt; vowel({'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'});\n        istringstream iss(S);\n        string res, w;\n        int i = 0;\n        while (iss &gt;&gt; w) {\n            res += \" \";\n            if (vowel.count(w[0]) != 0) {\n                res += w;\n            } else {\n                res += w.substr(1) + w[0];\n            }\n            res += \"ma\";\n            \n            for (int j = 0; j &lt;= i; j++) {\n                res += \"a\";\n            }\n            \n            i++;\n        }\n        \n        return res.substr(1);\n    }\n};\n\n\n",
        "url": "/2020/12/09/824-Goat-Latin/"
      },
    
      {
        "title": "Consecutive Characters",
        "excerpt": "&lt;-E 1446&gt; Consecutive Characters\n\nclass Solution {\npublic:\n    int maxPower(string s) {\n        int c = 0;\n        int max = 0;\n        for(int i = 0; i &lt; s.length(); ++i){\n            if(s[i + 1] == s[i])\n                c++;\n            else{\n                if(c &gt; max)\n                    max = c;\n                c = 0;\n            }\n        }\n        return ++max;\n    }\n};\n\n\n",
        "content": "&lt;-E 1446&gt; Consecutive Characters\n\nclass Solution {\npublic:\n    int maxPower(string s) {\n        int c = 0;\n        int max = 0;\n        for(int i = 0; i &lt; s.length(); ++i){\n            if(s[i + 1] == s[i])\n                c++;\n            else{\n                if(c &gt; max)\n                    max = c;\n                c = 0;\n            }\n        }\n        return ++max;\n    }\n};\n\n\n",
        "url": "/2020/12/10/1446-Consecutive-Characters/"
      },
    
      {
        "title": "Reformat Date",
        "excerpt": "&lt;-E 1507&gt; Reformat Date\n\nclass Solution {\npublic:\n    string reformatDate(string date) {\n       int n = date.length();\n        vector&lt;string&gt;arr{\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\n        string m,d,y;\n        for(int i=0 ; i&lt;12 ; i++)\n            if(date.find(arr[i])!=string::npos) m = to_string(i+1);\n        if(m.length()&lt;2) m = \"0\"+m;\n        \n        y = date.substr(n-4,n);\n        for(int i=0 ; i&lt;3 ; i++)\n        {\n            if(isdigit(date[i])) \n                d += date[i];\n            else break;\n        }\n        if(d.length() &lt; 2) d = \"0\"+d;\n        return y + \"-\" + m + \"-\" + d; \n    }\n};\n\n\n",
        "content": "&lt;-E 1507&gt; Reformat Date\n\nclass Solution {\npublic:\n    string reformatDate(string date) {\n       int n = date.length();\n        vector&lt;string&gt;arr{\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\n        string m,d,y;\n        for(int i=0 ; i&lt;12 ; i++)\n            if(date.find(arr[i])!=string::npos) m = to_string(i+1);\n        if(m.length()&lt;2) m = \"0\"+m;\n        \n        y = date.substr(n-4,n);\n        for(int i=0 ; i&lt;3 ; i++)\n        {\n            if(isdigit(date[i])) \n                d += date[i];\n            else break;\n        }\n        if(d.length() &lt; 2) d = \"0\"+d;\n        return y + \"-\" + m + \"-\" + d; \n    }\n};\n\n\n",
        "url": "/2020/12/10/1507-Reformat-Date/"
      },
    
      {
        "title": "Sum of Even Numbers After Queries",
        "excerpt": "&lt;-E 985&gt; Sum of Even Numbers After Queries\n\nclass Solution {\npublic:\n    vector&lt;int&gt; sumEvenAfterQueries(vector&lt;int&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {\n        vector&lt;int&gt; res(queries.size());\n        int sum = accumulate(A.begin(), A.end(), 0, \n                             [](int sum, int n) {\n                                 return n % 2 == 0 ? sum + n : sum;\n                             });\n        \n        for (int i = 0; i &lt; queries.size(); ++i) {\n            int index = queries[i][1], val = queries[i][0];\n            int cur = val + A[index];\n            \n            if (A[index] % 2 == 0 &amp;&amp; cur % 2 == 0) {\n                sum += val;\n            }\n            else if (A[index] % 2 == 0) {\n                sum -= A[index];\n            }\n            else if (cur % 2 == 0){\n                sum += cur;\n            }\n            \n            res[i] = sum;\n            A[index] = cur;\n        }\n        \n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 985&gt; Sum of Even Numbers After Queries\n\nclass Solution {\npublic:\n    vector&lt;int&gt; sumEvenAfterQueries(vector&lt;int&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {\n        vector&lt;int&gt; res(queries.size());\n        int sum = accumulate(A.begin(), A.end(), 0, \n                             [](int sum, int n) {\n                                 return n % 2 == 0 ? sum + n : sum;\n                             });\n        \n        for (int i = 0; i &lt; queries.size(); ++i) {\n            int index = queries[i][1], val = queries[i][0];\n            int cur = val + A[index];\n            \n            if (A[index] % 2 == 0 &amp;&amp; cur % 2 == 0) {\n                sum += val;\n            }\n            else if (A[index] % 2 == 0) {\n                sum -= A[index];\n            }\n            else if (cur % 2 == 0){\n                sum += cur;\n            }\n            \n            res[i] = sum;\n            A[index] = cur;\n        }\n        \n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/11/985-Sum-of-Even-Numbers-After-Queries/"
      },
    
      {
        "title": "Largest Substring Between Two Equal Characters",
        "excerpt": "&lt;-E 1624&gt; Largest Substring Between Two Equal Characters\n\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int len = -1;\n        unordered_map&lt;char,int&gt; umap;\n        for(int i = 0;i &lt; s.size(); i++){\n            \n            \n            if(umap.find(s[i]) != umap.end()){\n                len = max(len, i - umap[s[i]] -1);\n            }\n            else{\n                umap[s[i]] = i;\n            }\n            \n            \n        }\n         return len;\n    }\n};\n\n\n",
        "content": "&lt;-E 1624&gt; Largest Substring Between Two Equal Characters\n\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int len = -1;\n        unordered_map&lt;char,int&gt; umap;\n        for(int i = 0;i &lt; s.size(); i++){\n            \n            \n            if(umap.find(s[i]) != umap.end()){\n                len = max(len, i - umap[s[i]] -1);\n            }\n            else{\n                umap[s[i]] = i;\n            }\n            \n            \n        }\n         return len;\n    }\n};\n\n\n",
        "url": "/2020/12/12/1624-Largest-Substring-Between-Two-Equal-Characters/"
      },
    
      {
        "title": "Complement of Base 10 Integer",
        "excerpt": "&lt;-E 1009&gt; Complement of Base 10 Integer\n\nclass Solution {\npublic:\n    int bitwiseComplement(int N) {\n        if(N == 0)\n\t\t    return 1;\n        long long int n1, n2;\n        n1 = log2(N) + 1;\n        n2 = pow(2, n1) - 1;\n        return N ^ n2;\n    }\n};\nclass Solution {\npublic:\n    int bitwiseComplement(int N) {\n        if(N == 0) \n            return 1;\n        return ~((0xffffffff &lt;&lt; (32 - __builtin_clz(N))) | N);\n    }\n};\n\n\n\n",
        "content": "&lt;-E 1009&gt; Complement of Base 10 Integer\n\nclass Solution {\npublic:\n    int bitwiseComplement(int N) {\n        if(N == 0)\n\t\t    return 1;\n        long long int n1, n2;\n        n1 = log2(N) + 1;\n        n2 = pow(2, n1) - 1;\n        return N ^ n2;\n    }\n};\nclass Solution {\npublic:\n    int bitwiseComplement(int N) {\n        if(N == 0) \n            return 1;\n        return ~((0xffffffff &lt;&lt; (32 - __builtin_clz(N))) | N);\n    }\n};\n\n\n\n",
        "url": "/2020/12/13/1009-Complement-of-Base-10-Integer/"
      },
    
      {
        "title": "Water Bottles",
        "excerpt": "&lt;-E 1518&gt; Water Bottles\n\nclass Solution {\npublic:\n    int numWaterBottles(int numBottles, int numExchange) {\n        int s = numBottles,l = 0,p;\n        while((numBottles / numExchange) &gt; 0)\n        {\n            p = (numBottles / numExchange);\n            l = (numBottles % numExchange);\n            s += p;\n            numBottles = p + l;\n        }\n        return s;\n    }\n};\n\n\n",
        "content": "&lt;-E 1518&gt; Water Bottles\n\nclass Solution {\npublic:\n    int numWaterBottles(int numBottles, int numExchange) {\n        int s = numBottles,l = 0,p;\n        while((numBottles / numExchange) &gt; 0)\n        {\n            p = (numBottles / numExchange);\n            l = (numBottles % numExchange);\n            s += p;\n            numBottles = p + l;\n        }\n        return s;\n    }\n};\n\n\n",
        "url": "/2020/12/14/1518-Water-Bottles/"
      },
    
      {
        "title": "Reshape the Matrix",
        "excerpt": "&lt;-E 566&gt; Reshape the Matrix\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) {\n        int m = nums.size();\n        int n = nums[0].size();\n        if(r * c != m * n)\n            return nums;\n       \n        vector&lt;vector&lt;int&gt;&gt;res(r,vector&lt;int&gt;(c,0));\n        int column = 0;\n        int row = 0;\n        for(int i = 0; i &lt; m; i++){\n            for(int j = 0;j &lt; n; j++) {\n                res[row][column] = nums[i][j];\n                column++;\n                if(column == c){\n                    column=0;\n                    row++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 566&gt; Reshape the Matrix\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) {\n        int m = nums.size();\n        int n = nums[0].size();\n        if(r * c != m * n)\n            return nums;\n       \n        vector&lt;vector&lt;int&gt;&gt;res(r,vector&lt;int&gt;(c,0));\n        int column = 0;\n        int row = 0;\n        for(int i = 0; i &lt; m; i++){\n            for(int j = 0;j &lt; n; j++) {\n                res[row][column] = nums[i][j];\n                column++;\n                if(column == c){\n                    column=0;\n                    row++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/15/566-Reshape-the-Matrix/"
      },
    
      {
        "title": "Binary Number with Alternating Bits",
        "excerpt": "&lt;-E 693&gt; Binary Number with Alternating Bits\n\nclass Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        bitset&lt;32&gt; bit(n);\n        string s = bit.to_string();\n        \n        int pos = 0;\n        while(s[pos++] == '0');\n        \n        char check = s[pos - 1];\n        \n        for(int i = pos; i != s.size(); i++) {\n            if(check == s[i]) {\n                return false;\n            } else {\n                check = s[i];\n            }\n        }\n        \n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 693&gt; Binary Number with Alternating Bits\n\nclass Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        bitset&lt;32&gt; bit(n);\n        string s = bit.to_string();\n        \n        int pos = 0;\n        while(s[pos++] == '0');\n        \n        char check = s[pos - 1];\n        \n        for(int i = pos; i != s.size(); i++) {\n            if(check == s[i]) {\n                return false;\n            } else {\n                check = s[i];\n            }\n        }\n        \n        return true;\n    }\n};\n\n\n",
        "url": "/2020/12/15/693-Binary-Number-with-Alternating-Bits/"
      },
    
      {
        "title": "Binary Gap",
        "excerpt": "&lt;-E 868&gt; Binary Gap\n\nclass Solution {\npublic:\n    int binaryGap(int n) {\n        string str = bitset&lt;64&gt;(n).to_string();\n        int dist = 0, pre = -1;\n        for (auto i = 0; i &lt; 64; i++)\n        {\n            if (str[i] != '0')\n            {\n                if (pre == -1)\n                    pre = i;\n                else\n                    dist = max(dist, i - pre), pre = i;\n            }\n        }\n        return dist;\n    }\n};\n\n\n",
        "content": "&lt;-E 868&gt; Binary Gap\n\nclass Solution {\npublic:\n    int binaryGap(int n) {\n        string str = bitset&lt;64&gt;(n).to_string();\n        int dist = 0, pre = -1;\n        for (auto i = 0; i &lt; 64; i++)\n        {\n            if (str[i] != '0')\n            {\n                if (pre == -1)\n                    pre = i;\n                else\n                    dist = max(dist, i - pre), pre = i;\n            }\n        }\n        return dist;\n    }\n};\n\n\n",
        "url": "/2020/12/15/868-Binary-Gap/"
      },
    
      {
        "title": "Largest Perimeter Triangle",
        "excerpt": "&lt;-E 976&gt; Largest Perimeter Triangle\n\n// Method 1\nclass Solution {\npublic:\n    int largestPerimeter(vector&lt;int&gt;&amp; A) {\n        sort(A.begin(), A.end());\n    \n        for(int i = A.size() - 1; i &gt;= 2; i--) {\n            if(A[i] &lt; A[i-1] + A[i-2])\n                return A[i] + A[i-1] + A[i-2];\n        }\n\n        return 0;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int largestPerimeter(vector&lt;int&gt;&amp; A) {\n        priority_queue&lt;int&gt; pq(less&lt;int&gt;(), A);\n        int a;\n        int b = pq.top();\n        pq.pop();\n        int c = pq.top();\n        pq.pop();\n        do {\n            a = b;\n            b = c;\n            \n            c = pq.top();\n            pq.pop();\n        } while (!pq.empty() &amp;&amp; a &gt;= b + c);\n        if (a &gt;= b + c)\n            return 0;\n        return a + b + c;\n    }\n};\n\n\n",
        "content": "&lt;-E 976&gt; Largest Perimeter Triangle\n\n// Method 1\nclass Solution {\npublic:\n    int largestPerimeter(vector&lt;int&gt;&amp; A) {\n        sort(A.begin(), A.end());\n    \n        for(int i = A.size() - 1; i &gt;= 2; i--) {\n            if(A[i] &lt; A[i-1] + A[i-2])\n                return A[i] + A[i-1] + A[i-2];\n        }\n\n        return 0;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int largestPerimeter(vector&lt;int&gt;&amp; A) {\n        priority_queue&lt;int&gt; pq(less&lt;int&gt;(), A);\n        int a;\n        int b = pq.top();\n        pq.pop();\n        int c = pq.top();\n        pq.pop();\n        do {\n            a = b;\n            b = c;\n            \n            c = pq.top();\n            pq.pop();\n        } while (!pq.empty() &amp;&amp; a &gt;= b + c);\n        if (a &gt;= b + c)\n            return 0;\n        return a + b + c;\n    }\n};\n\n\n",
        "url": "/2020/12/16/976-Largest-Perimeter-Triangle/"
      },
    
      {
        "title": "Rotated Digits",
        "excerpt": "&lt;-E 788&gt; Rotated Digits\n\nclass Solution {\npublic:\n    \n        bool good(int x){\n        int y;\n        bool rotated=false;\n        while(x &gt; 0){\n            y=x % 10;\n            switch(y){\n                case 0:\n                case 1:\n                case 8:\n                    break;\n                case 2:\n                case 5:\n                case 6:\n                case 9:\n                    rotated = true;\n                    break;\n                default:\n                    return false;\n            }\n            x = x / 10;\n        }\n        return rotated;\n    }\n    \n    int rotatedDigits(int N) {\n        int count =0;\n        for(int i=1;i&lt;=N;i++){\n            if(good(i)){\n                count++;\n            }\n        }\n        return count;\n    }\n};\n\n\n",
        "content": "&lt;-E 788&gt; Rotated Digits\n\nclass Solution {\npublic:\n    \n        bool good(int x){\n        int y;\n        bool rotated=false;\n        while(x &gt; 0){\n            y=x % 10;\n            switch(y){\n                case 0:\n                case 1:\n                case 8:\n                    break;\n                case 2:\n                case 5:\n                case 6:\n                case 9:\n                    rotated = true;\n                    break;\n                default:\n                    return false;\n            }\n            x = x / 10;\n        }\n        return rotated;\n    }\n    \n    int rotatedDigits(int N) {\n        int count =0;\n        for(int i=1;i&lt;=N;i++){\n            if(good(i)){\n                count++;\n            }\n        }\n        return count;\n    }\n};\n\n\n",
        "url": "/2020/12/17/788-Rotated-Digits/"
      },
    
      {
        "title": "Shortest Completing Word",
        "excerpt": "&lt;-E 748&gt; Shortest Completing Word\n\n// Method 1\nclass Solution {\npublic:\n    string shortestCompletingWord(string licensePlate, vector&lt;string&gt;&amp; words) {\n        int storelp[26]={0}; //to store count of chars in licensePlate string\n        for(int i = 0; i &lt; licensePlate.size(); i++){\n            if(isalpha(licensePlate[i])){\n                storelp[tolower(licensePlate[i]) - 'a'] += 1;\n            }\n        }\n        string res = \"\";\n        int minsize = INT_MAX;\n        for(auto i = 0; i &lt; words.size(); i++){\n            int flag = 1; //let's assume it has all chars\n            int storeword[26] {0};\n            for(int j = 0; j &lt; words[i].size(); j++){\n                storeword[words[i][j] - 'a'] += 1;\n            }\n            for(int k = 0; k &lt; 26; k++){\n                if(storeword[k] &lt; storelp[k]){ //if the required no. of chars is not present, we break\n                    flag = 0;\n                    break;\n                }\n            }\n            if(flag == 1 &amp;&amp; words[i].size() &lt; minsize){\n                    res = words[i];\n                    minsize = words[i].size();\n            }\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string shortestCompletingWord(string licensePlate, vector&lt;string&gt;&amp; words) {\n        int licCount[26]{0};\n        for (char c : licensePlate) {\n            if (isalpha(c)) {\n                ++licCount[tolower(c) - 'a'];\n            }\n        }\n        \n        int retIndx{-1};\n        for (int i{0}; i &lt; words.size(); ++i) {\n            int wCount[26]{0};\n            for (char c : words[i]) {\n                ++wCount[c - 'a'];\n            }\n            \n            if (equal(begin(licCount), end(licCount), begin(wCount), end(wCount), [](int l, int r){ return l &lt;= r; })) {\n                if (retIndx &lt; 0) {\n                    retIndx = i;\n                }\n                else if (words[retIndx].size() &gt; words[i].size()) {\n                    retIndx = i;\n                }\n            }\n        }\n        \n        return words[retIndx];\n    }\n};\n\n\n",
        "content": "&lt;-E 748&gt; Shortest Completing Word\n\n// Method 1\nclass Solution {\npublic:\n    string shortestCompletingWord(string licensePlate, vector&lt;string&gt;&amp; words) {\n        int storelp[26]={0}; //to store count of chars in licensePlate string\n        for(int i = 0; i &lt; licensePlate.size(); i++){\n            if(isalpha(licensePlate[i])){\n                storelp[tolower(licensePlate[i]) - 'a'] += 1;\n            }\n        }\n        string res = \"\";\n        int minsize = INT_MAX;\n        for(auto i = 0; i &lt; words.size(); i++){\n            int flag = 1; //let's assume it has all chars\n            int storeword[26] {0};\n            for(int j = 0; j &lt; words[i].size(); j++){\n                storeword[words[i][j] - 'a'] += 1;\n            }\n            for(int k = 0; k &lt; 26; k++){\n                if(storeword[k] &lt; storelp[k]){ //if the required no. of chars is not present, we break\n                    flag = 0;\n                    break;\n                }\n            }\n            if(flag == 1 &amp;&amp; words[i].size() &lt; minsize){\n                    res = words[i];\n                    minsize = words[i].size();\n            }\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string shortestCompletingWord(string licensePlate, vector&lt;string&gt;&amp; words) {\n        int licCount[26]{0};\n        for (char c : licensePlate) {\n            if (isalpha(c)) {\n                ++licCount[tolower(c) - 'a'];\n            }\n        }\n        \n        int retIndx{-1};\n        for (int i{0}; i &lt; words.size(); ++i) {\n            int wCount[26]{0};\n            for (char c : words[i]) {\n                ++wCount[c - 'a'];\n            }\n            \n            if (equal(begin(licCount), end(licCount), begin(wCount), end(wCount), [](int l, int r){ return l &lt;= r; })) {\n                if (retIndx &lt; 0) {\n                    retIndx = i;\n                }\n                else if (words[retIndx].size() &gt; words[i].size()) {\n                    retIndx = i;\n                }\n            }\n        }\n        \n        return words[retIndx];\n    }\n};\n\n\n",
        "url": "/2020/12/18/748-Shortest-Completing-Word/"
      },
    
      {
        "title": "Rank Transform of an Array",
        "excerpt": "&lt;-E 1331&gt; Rank Transform of an Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; arrayRankTransform(vector&lt;int&gt;&amp; arr) {\n        set&lt;int&gt; s(arr.begin(), arr.end());\n        \n        unordered_map&lt;int, int&gt; m;\n        \n        int r = 0;\n        \n        vector&lt;int&gt; ans;\n        \n        for (auto a : s) \n            m[a] = ++r;\n        \n        for (auto a : arr) {\n            ans.push_back(m[a]);\n        }\n                            \n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; arrayRankTransform(vector&lt;int&gt;&amp; arr) {\n        if(arr.empty()) \n            return vector&lt;int&gt;();\n        int min = *std::min_element(arr.begin(),arr.end());\n        int max = *std::max_element(arr.begin(),arr.end());\n       \n        vector&lt;int&gt; v(max-min+1);\n       \n        for(int i=0; i &lt; arr.size(); ++i) \n            v[arr[i] - min] = 1;\n        \n        int cum = 1;\n        \n        for(int i=0; i&lt; v.size(); ++i) {\n            if(v[i] == 1) {\n                v[i] = cum;\n                cum++;\n            }\n        }\n        for(int i = 0; i &lt; arr.size(); ++i) \n            arr[i] = v[arr[i] - min];\n        return arr;\n    }\n};\n\n\n",
        "content": "&lt;-E 1331&gt; Rank Transform of an Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; arrayRankTransform(vector&lt;int&gt;&amp; arr) {\n        set&lt;int&gt; s(arr.begin(), arr.end());\n        \n        unordered_map&lt;int, int&gt; m;\n        \n        int r = 0;\n        \n        vector&lt;int&gt; ans;\n        \n        for (auto a : s) \n            m[a] = ++r;\n        \n        for (auto a : arr) {\n            ans.push_back(m[a]);\n        }\n                            \n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; arrayRankTransform(vector&lt;int&gt;&amp; arr) {\n        if(arr.empty()) \n            return vector&lt;int&gt;();\n        int min = *std::min_element(arr.begin(),arr.end());\n        int max = *std::max_element(arr.begin(),arr.end());\n       \n        vector&lt;int&gt; v(max-min+1);\n       \n        for(int i=0; i &lt; arr.size(); ++i) \n            v[arr[i] - min] = 1;\n        \n        int cum = 1;\n        \n        for(int i=0; i&lt; v.size(); ++i) {\n            if(v[i] == 1) {\n                v[i] = cum;\n                cum++;\n            }\n        }\n        for(int i = 0; i &lt; arr.size(); ++i) \n            arr[i] = v[arr[i] - min];\n        return arr;\n    }\n};\n\n\n",
        "url": "/2020/12/19/1331-Rank-Transform-of-an-Array/"
      },
    
      {
        "title": "Thousand Separator",
        "excerpt": "&lt;-E 1556&gt; Thousand Separator\n\nclass Solution {\npublic:\n    string thousandSeparator(int n) {\n        string num = to_string(n);\n\n        for (int i = num.length() - 1, j = 1; i &gt; 0; --i, ++j) {\n\n            if (j % 3 == 0) {\n                num.insert(num.begin() + i, '.');\n            }\n        }\n        return num;\n    }\n};\n\n\n",
        "content": "&lt;-E 1556&gt; Thousand Separator\n\nclass Solution {\npublic:\n    string thousandSeparator(int n) {\n        string num = to_string(n);\n\n        for (int i = num.length() - 1, j = 1; i &gt; 0; --i, ++j) {\n\n            if (j % 3 == 0) {\n                num.insert(num.begin() + i, '.');\n            }\n        }\n        return num;\n    }\n};\n\n\n",
        "url": "/2020/12/20/1556-Thousand-Separator/"
      },
    
      {
        "title": "Maximize Sum Of Array After K Negations",
        "excerpt": "&lt;-E 1005&gt; Maximize Sum Of Array After K Negations\n\nclass Solution {\npublic:\n    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) {\n        sort(A.begin(), A.end());\n        int i;\n        for(i=0;i&lt;A.size() &amp;&amp; K;i++) {\n            if(A[i]&lt;0) {\n                A[i] = abs(A[i]);\n                K--;\n            } else {\n                break;\n            }\n        }\n        K = K%2;\n        if(K) {\n            int m = min_element(A.begin(), A.end()) - A.begin();\n            A[m] *= -1;\n        }        \n        int ans = accumulate(A.begin(), A.end(), 0);\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1005&gt; Maximize Sum Of Array After K Negations\n\nclass Solution {\npublic:\n    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) {\n        sort(A.begin(), A.end());\n        int i;\n        for(i=0;i&lt;A.size() &amp;&amp; K;i++) {\n            if(A[i]&lt;0) {\n                A[i] = abs(A[i]);\n                K--;\n            } else {\n                break;\n            }\n        }\n        K = K%2;\n        if(K) {\n            int m = min_element(A.begin(), A.end()) - A.begin();\n            A[m] *= -1;\n        }        \n        int ans = accumulate(A.begin(), A.end(), 0);\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/12/21/1005-Maximize-Sum-Of-Array-After-K-Negations/"
      },
    
      {
        "title": "Compare Strings by Frequency of the Smallest Character",
        "excerpt": "&lt;-E 1170&gt; Compare Strings by Frequency of the Smallest Character\n\nclass Solution {\npublic:\n    vector&lt;int&gt; numSmallerByFrequency(const vector&lt;string&gt;&amp; queries, \n                                    const vector&lt;string&gt;&amp; words) {\n    if (queries.empty() || words.empty()) {\n      return {};\n    }\n    vector&lt;int&gt; vqf(queries.size());\n    for (size_t i = 0; i &lt; queries.size(); ++i) {\n      vqf[i] = frequency(queries[i]);\n    }\n    vector&lt;int&gt; vwf(words.size());\n    for (size_t i = 0; i &lt; words.size(); ++i) {\n      vwf[i] = frequency(words[i]);\n    }\n    sort(vwf.begin(), vwf.end());\n    vector&lt;int&gt; res(queries.size());\n    for (size_t i = 0; i &lt; queries.size(); ++i) {\n      auto it = upper_bound(vwf.begin(), vwf.end(), vqf[i]);\n      res[i] = distance(it, vwf.end());\n    }\n    return res;\n  }\n\nprivate:\n  int frequency(const string&amp; s) {\n    if (s.empty()) {\n      return 0;\n    }\n    return count(s.begin(), s.end(), *min_element(s.begin(), s.end()));\n  }\n};\n\n\n",
        "content": "&lt;-E 1170&gt; Compare Strings by Frequency of the Smallest Character\n\nclass Solution {\npublic:\n    vector&lt;int&gt; numSmallerByFrequency(const vector&lt;string&gt;&amp; queries, \n                                    const vector&lt;string&gt;&amp; words) {\n    if (queries.empty() || words.empty()) {\n      return {};\n    }\n    vector&lt;int&gt; vqf(queries.size());\n    for (size_t i = 0; i &lt; queries.size(); ++i) {\n      vqf[i] = frequency(queries[i]);\n    }\n    vector&lt;int&gt; vwf(words.size());\n    for (size_t i = 0; i &lt; words.size(); ++i) {\n      vwf[i] = frequency(words[i]);\n    }\n    sort(vwf.begin(), vwf.end());\n    vector&lt;int&gt; res(queries.size());\n    for (size_t i = 0; i &lt; queries.size(); ++i) {\n      auto it = upper_bound(vwf.begin(), vwf.end(), vqf[i]);\n      res[i] = distance(it, vwf.end());\n    }\n    return res;\n  }\n\nprivate:\n  int frequency(const string&amp; s) {\n    if (s.empty()) {\n      return 0;\n    }\n    return count(s.begin(), s.end(), *min_element(s.begin(), s.end()));\n  }\n};\n\n\n",
        "url": "/2020/12/21/1170-Compare-Strings-by-Frequency-of-the-Smallest-Character/"
      },
    
      {
        "title": "Slowest Key",
        "excerpt": "&lt;-E 1629&gt; Slowest Key\n\nclass Solution {\npublic:\n    char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) {\n        int prevtime = 0;\n        int currenttime;\n        int maxtime = 0;\n        char maxkey;\n        for(int i = 0;i &lt; releaseTimes.size(); i++)\n        {\n            currenttime = releaseTimes[i] - prevtime;\n            if(maxtime &lt; currenttime) {\n                maxtime = currenttime;\n                maxkey = keysPressed[i];\n            }\n            if(maxtime == currenttime) {\n                maxkey = max(maxkey,keysPressed[i]);\n            }\n            prevtime = releaseTimes[i];\n        }\n        return maxkey;\n    }\n    \n};\n\n\n",
        "content": "&lt;-E 1629&gt; Slowest Key\n\nclass Solution {\npublic:\n    char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) {\n        int prevtime = 0;\n        int currenttime;\n        int maxtime = 0;\n        char maxkey;\n        for(int i = 0;i &lt; releaseTimes.size(); i++)\n        {\n            currenttime = releaseTimes[i] - prevtime;\n            if(maxtime &lt; currenttime) {\n                maxtime = currenttime;\n                maxkey = keysPressed[i];\n            }\n            if(maxtime == currenttime) {\n                maxkey = max(maxkey,keysPressed[i]);\n            }\n            prevtime = releaseTimes[i];\n        }\n        return maxkey;\n    }\n    \n};\n\n\n",
        "url": "/2020/12/21/1629-Slowest-Key/"
      },
    
      {
        "title": "Count the Number of Consistent Strings",
        "excerpt": "&lt;-E 1684&gt; Count the Number of Consistent Strings\n\nclass Solution {\npublic:\n    int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) {\n        vector&lt;int&gt; letters(26,-1);\n        for(int i = 0; i &lt; allowed.size(); ++i)\n            letters[allowed[i] - 'a'] = 0;\n        \n        int count = 0;\n        for(auto word : words) {\n            int i = 0;\n            for(; i &lt; word.size(); ++i)\n                if(letters[word[i] - 'a'] == -1) break;\n            if(i == word.size()) \n                ++count;\n        }        \n        return count;\n    }\n};\n\n\n",
        "content": "&lt;-E 1684&gt; Count the Number of Consistent Strings\n\nclass Solution {\npublic:\n    int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) {\n        vector&lt;int&gt; letters(26,-1);\n        for(int i = 0; i &lt; allowed.size(); ++i)\n            letters[allowed[i] - 'a'] = 0;\n        \n        int count = 0;\n        for(auto word : words) {\n            int i = 0;\n            for(; i &lt; word.size(); ++i)\n                if(letters[word[i] - 'a'] == -1) break;\n            if(i == word.size()) \n                ++count;\n        }        \n        return count;\n    }\n};\n\n\n",
        "url": "/2020/12/21/1684-Count-the-Number-of-Consistent-Strings/"
      },
    
      {
        "title": "Count of Matches in Tournament",
        "excerpt": "&lt;-E 1688&gt; Count of Matches in Tournament\n\nclass Solution {\npublic:\n    int numberOfMatches(int n) {\n        int matches = 0;\n        \n        int crm = -1;\n        while(crm != 0){\n            crm = n / 2;\n            matches += crm;\n            n = (n + 1) / 2;\n        }\n        \n        return matches;\n    }\n};\n\n\n",
        "content": "&lt;-E 1688&gt; Count of Matches in Tournament\n\nclass Solution {\npublic:\n    int numberOfMatches(int n) {\n        int matches = 0;\n        \n        int crm = -1;\n        while(crm != 0){\n            crm = n / 2;\n            matches += crm;\n            n = (n + 1) / 2;\n        }\n        \n        return matches;\n    }\n};\n\n\n",
        "url": "/2020/12/21/1688-Count-of-Matches-in-Tournament/"
      },
    
      {
        "title": "Sum of Left Leaves",
        "excerpt": "&lt;-E 404&gt; Sum of Left Leaves\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n      \n      if(root == nullptr) return 0;\n      \n      int sum = 0;\n      \n      if(root -&gt;left != nullptr &amp;&amp; root-&gt;left-&gt; left == nullptr &amp;&amp; root-&gt;left-&gt;right == nullptr) \n          sum += root-&gt;left-&gt;val;\n      \n      return sum + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);\n      \n    }\n};\n\n\n",
        "content": "&lt;-E 404&gt; Sum of Left Leaves\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n      \n      if(root == nullptr) return 0;\n      \n      int sum = 0;\n      \n      if(root -&gt;left != nullptr &amp;&amp; root-&gt;left-&gt; left == nullptr &amp;&amp; root-&gt;left-&gt;right == nullptr) \n          sum += root-&gt;left-&gt;val;\n      \n      return sum + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);\n      \n    }\n};\n\n\n",
        "url": "/2020/12/21/404-Sum-of-Left-Leaves/"
      },
    
      {
        "title": "Largest Triangle Area",
        "excerpt": "&lt;-E 812&gt; Largest Triangle Area\n\nclass Solution {\npublic:\n\n    double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n       double res = 0;\n        for (int i=0;i &lt; points.size()-2;i++){\n            for (int j=i+1;j&lt; points.size()-1;j++){\n                for (int k=j+1;k&lt;points.size();k++){\n                     res = max(res, 0.5 * abs(points[i][0] * points[j][1] + points[j][0] * points[k][1] + points[k][0] * points[i][1] - points[j][0] * points[i][1] - points[k][0] * points[j][1] - points[i][0] * points[k][1]));\n                }\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 812&gt; Largest Triangle Area\n\nclass Solution {\npublic:\n\n    double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n       double res = 0;\n        for (int i=0;i &lt; points.size()-2;i++){\n            for (int j=i+1;j&lt; points.size()-1;j++){\n                for (int k=j+1;k&lt;points.size();k++){\n                     res = max(res, 0.5 * abs(points[i][0] * points[j][1] + points[j][0] * points[k][1] + points[k][0] * points[i][1] - points[j][0] * points[i][1] - points[k][0] * points[j][1] - points[i][0] * points[k][1]));\n                }\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/21/812-Largest-Triangle-Area/"
      },
    
      {
        "title": "Fair Candy Swap",
        "excerpt": "&lt;-E 888&gt; Fair Candy Swap\n\nclass Solution {\npublic:\n    vector&lt;int&gt; fairCandySwap(const vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {\n        int diff=(accumulate(a.begin(),a.end(),0)-accumulate(b.begin(),b.end(),0))/2;\n        sort(b.begin(),b.end());\n        for(auto i : a)\n            if(binary_search(b.begin(),b.end(),i-diff)) return {i,i-diff};\n        return {0,0};\n    }\n};\n\n\n",
        "content": "&lt;-E 888&gt; Fair Candy Swap\n\nclass Solution {\npublic:\n    vector&lt;int&gt; fairCandySwap(const vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) {\n        int diff=(accumulate(a.begin(),a.end(),0)-accumulate(b.begin(),b.end(),0))/2;\n        sort(b.begin(),b.end());\n        for(auto i : a)\n            if(binary_search(b.begin(),b.end(),i-diff)) return {i,i-diff};\n        return {0,0};\n    }\n};\n\n\n",
        "url": "/2020/12/21/888-Fair-Candy-Swap/"
      },
    
      {
        "title": "Surface Area of 3D Shapes",
        "excerpt": "&lt;-E 892&gt; Surface Area of 3D Shapes\n\nclass Solution {\npublic:\n    int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int n = grid.size(), res = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                if (grid[i][j] &gt; 0) res += 4 * grid[i][j] + 2;\n                if (i &gt; 0) res -= min(grid[i][j], grid[i - 1][j]) * 2;\n                if (j &gt; 0) res -= min(grid[i][j], grid[i][j - 1]) * 2;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 892&gt; Surface Area of 3D Shapes\n\nclass Solution {\npublic:\n    int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int n = grid.size(), res = 0;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = 0; j &lt; n; ++j) {\n                if (grid[i][j] &gt; 0) res += 4 * grid[i][j] + 2;\n                if (i &gt; 0) res -= min(grid[i][j], grid[i - 1][j]) * 2;\n                if (j &gt; 0) res -= min(grid[i][j], grid[i][j - 1]) * 2;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/21/892-Surface-Area-of-3D-Shapes/"
      },
    
      {
        "title": "Reverse Only Letters",
        "excerpt": "&lt;-E 917&gt; Reverse Only Letters\n\nclass Solution {\npublic:\n    string reverseOnlyLetters(string S) {\n        int len = S.length();\n        string ans = \"\";\n        int j = len - 1;\n        for(int i = 0; i &lt; len; i++) {\n            if(isalpha(S[i])) {\n                while(j &gt;= 0 &amp;&amp; !isalpha(S[j]))\n                    j -= 1;\n                ans += S[j];\n                j -= 1;\n            }\n            else\n                ans += S[i];\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 917&gt; Reverse Only Letters\n\nclass Solution {\npublic:\n    string reverseOnlyLetters(string S) {\n        int len = S.length();\n        string ans = \"\";\n        int j = len - 1;\n        for(int i = 0; i &lt; len; i++) {\n            if(isalpha(S[i])) {\n                while(j &gt;= 0 &amp;&amp; !isalpha(S[j]))\n                    j -= 1;\n                ans += S[j];\n                j -= 1;\n            }\n            else\n                ans += S[i];\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/12/21/917-Reverse-Only-Letters/"
      },
    
      {
        "title": "Binary Tree Tilt",
        "excerpt": "&lt;-E 563&gt; Binary Tree Tilt\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int helper(TreeNode* root, int &amp;fsum){\n\t\tif(root == NULL) return 0;\n\t\tint a1 = root-&gt;val;\n\t\tint a2 = helper(root-&gt;left,fsum);\n\t\tint a3 = helper(root-&gt;right,fsum);\n\t\tfsum += abs(a2 - a3);\n\t\treturn (a1 + a2 + a3);\n    }\n\tint findTilt(TreeNode* root) {   \n\t\tint fsum = 0;\n\t\thelper(root, fsum);\n\t\treturn fsum;\n    }\n};\n\n\n",
        "content": "&lt;-E 563&gt; Binary Tree Tilt\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int helper(TreeNode* root, int &amp;fsum){\n\t\tif(root == NULL) return 0;\n\t\tint a1 = root-&gt;val;\n\t\tint a2 = helper(root-&gt;left,fsum);\n\t\tint a3 = helper(root-&gt;right,fsum);\n\t\tfsum += abs(a2 - a3);\n\t\treturn (a1 + a2 + a3);\n    }\n\tint findTilt(TreeNode* root) {   \n\t\tint fsum = 0;\n\t\thelper(root, fsum);\n\t\treturn fsum;\n    }\n};\n\n\n",
        "url": "/2020/12/22/563-Binary-Tree-Tilt/"
      },
    
      {
        "title": "Binary Tree Paths",
        "excerpt": "&lt;-E 257&gt; Binary Tree Paths\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;string&gt;v;\n    void dfs(TreeNode* root,string s) {\n        if(root!=NULL) {\n            if(s == \"\")\n                s += to_string(root-&gt;val);\n            else\n                s += \"-&gt;\" + to_string(root-&gt;val);\n            if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {\n                v.push_back(s);\n                return;\n            }\n            dfs(root-&gt;left,s);\n            dfs(root-&gt;right,s);\n        }\n    }\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {\n        dfs(root,\"\");\n        return v;\n    }\n};\n\n\n",
        "content": "&lt;-E 257&gt; Binary Tree Paths\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;string&gt;v;\n    void dfs(TreeNode* root,string s) {\n        if(root!=NULL) {\n            if(s == \"\")\n                s += to_string(root-&gt;val);\n            else\n                s += \"-&gt;\" + to_string(root-&gt;val);\n            if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {\n                v.push_back(s);\n                return;\n            }\n            dfs(root-&gt;left,s);\n            dfs(root-&gt;right,s);\n        }\n    }\n    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {\n        dfs(root,\"\");\n        return v;\n    }\n};\n\n\n",
        "url": "/2020/12/23/257-Binary-Tree-Paths/"
      },
    
      {
        "title": "Binary Prefix Divisible By 5",
        "excerpt": "&lt;-E 1018&gt; Binary Prefix Divisible By 5\n\nclass Solution {\npublic:\n    vector&lt;bool&gt; prefixesDivBy5(vector&lt;int&gt;&amp; A) {\n        int n=A.size();\n        vector&lt;bool&gt;result(n,false);\n        int val = 0;\n        for(int i = 0; i &lt; n; i++){\n            if(!((val= val * 2 + A[i]) %= 5))\n                result[i] = true;\n        }\n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-E 1018&gt; Binary Prefix Divisible By 5\n\nclass Solution {\npublic:\n    vector&lt;bool&gt; prefixesDivBy5(vector&lt;int&gt;&amp; A) {\n        int n=A.size();\n        vector&lt;bool&gt;result(n,false);\n        int val = 0;\n        for(int i = 0; i &lt; n; i++){\n            if(!((val= val * 2 + A[i]) %= 5))\n                result[i] = true;\n        }\n        return result;\n    }\n};\n\n\n",
        "url": "/2020/12/24/1018-Binary-Prefix-Divisible-By-5/"
      },
    
      {
        "title": "Duplicate Zeros",
        "excerpt": "&lt;-E 1089&gt; Duplicate Zeros\n\n// Method 1\nclass Solution {\npublic:\n    void duplicateZeros(vector&lt;int&gt;&amp; arr) {\n         for(int i=0; i &lt; arr.size(); i++)\n            if(arr[i] == 0) {\n                for(int j=arr.size()-1; j &gt; i; j--)\n                    arr[j] = arr[j-1];\n                i++;\n            }\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    void duplicateZeros(vector&lt;int&gt;&amp; arr) {\n        const int SIZE = arr.size();\n        for (int i = 0; i &lt; SIZE; i++) {\n            if (arr[i] == 0) { \n                arr.insert(arr.begin()+i,0);\n                arr.pop_back();\n                i++;\n            }\n        }\n    }\n};\n\n\n",
        "content": "&lt;-E 1089&gt; Duplicate Zeros\n\n// Method 1\nclass Solution {\npublic:\n    void duplicateZeros(vector&lt;int&gt;&amp; arr) {\n         for(int i=0; i &lt; arr.size(); i++)\n            if(arr[i] == 0) {\n                for(int j=arr.size()-1; j &gt; i; j--)\n                    arr[j] = arr[j-1];\n                i++;\n            }\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    void duplicateZeros(vector&lt;int&gt;&amp; arr) {\n        const int SIZE = arr.size();\n        for (int i = 0; i &lt; SIZE; i++) {\n            if (arr[i] == 0) { \n                arr.insert(arr.begin()+i,0);\n                arr.pop_back();\n                i++;\n            }\n        }\n    }\n};\n\n\n",
        "url": "/2020/12/24/1089-Duplicate-Zeros/"
      },
    
      {
        "title": "Kth Missing Positive Number",
        "excerpt": "&lt;-E 1539&gt; Kth Missing Positive Number\n\nclass Solution {\npublic:\n    int findKthPositive(vector&lt;int&gt;&amp; arr, int k) {\n        int index = 0;\n        for(int i = 1; i != arr.back(); i++) {\n            if(i == arr[index])\n                index++;\n            else\n                k--;\n            if(k == 0)\n                return i;\n        }\n        return arr.back() + k;    \n    }\n};\n\n\n",
        "content": "&lt;-E 1539&gt; Kth Missing Positive Number\n\nclass Solution {\npublic:\n    int findKthPositive(vector&lt;int&gt;&amp; arr, int k) {\n        int index = 0;\n        for(int i = 1; i != arr.back(); i++) {\n            if(i == arr[index])\n                index++;\n            else\n                k--;\n            if(k == 0)\n                return i;\n        }\n        return arr.back() + k;    \n    }\n};\n\n\n",
        "url": "/2020/12/24/1539-Kth-Missing-Positive-Number/"
      },
    
      {
        "title": "Replace All ?'s to Avoid Consecutive Repeating Characters",
        "excerpt": "&lt;-E 1576&gt; Replace All ?’s to Avoid Consecutive Repeating Characters\n\nclass Solution {\npublic:\n    string modifyString(string s) {\n        char f, b = ' ';\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(i != 0) b = s[i-1];\n            f = s[i+1];\n            if(s[i] == '?') s[i] = 'a';\n            while(s[i] == b || s[i] == f) s[i]++;\n        }\n        return s;\n    }\n};\n\n\n",
        "content": "&lt;-E 1576&gt; Replace All ?’s to Avoid Consecutive Repeating Characters\n\nclass Solution {\npublic:\n    string modifyString(string s) {\n        char f, b = ' ';\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(i != 0) b = s[i-1];\n            f = s[i+1];\n            if(s[i] == '?') s[i] = 'a';\n            while(s[i] == b || s[i] == f) s[i]++;\n        }\n        return s;\n    }\n};\n\n\n",
        "url": "/2020/12/24/1576-Replace-All-to-Avoid-Consecutive-Repeating-Characters/"
      },
    
      {
        "title": "Binary Search",
        "excerpt": "&lt;-E 704&gt; Binary Search\n\nclass Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        \n        int low = 0, high = nums.size(), mid;\n        while (low &lt; high){\n            mid = low + (high - low) / 2;\n            if (nums[mid] == target)\n                return mid;\n            else if (nums[mid] &gt; target)\n                high = mid;\n            else\n                low = mid + 1;\n        }\n        \n        return -1; \n    }\n};\n\n\n",
        "content": "&lt;-E 704&gt; Binary Search\n\nclass Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        \n        int low = 0, high = nums.size(), mid;\n        while (low &lt; high){\n            mid = low + (high - low) / 2;\n            if (nums[mid] == target)\n                return mid;\n            else if (nums[mid] &gt; target)\n                high = mid;\n            else\n                low = mid + 1;\n        }\n        \n        return -1; \n    }\n};\n\n\n",
        "url": "/2020/12/24/1704-Binary-Search/"
      },
    
      {
        "title": "Degree of an Array",
        "excerpt": "&lt;-E 697&gt; Degree of an Array\n\nclass Solution {\npublic:\n    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int,vector&lt;int&gt;&gt; map;\n        for(int i=0; i &lt; nums.size(); i++) {\n            if(map.count(nums[i])==0) { \n                map[nums[i]] = {0,i,i};\n            }\n            map[nums[i]][0] += 1;\n            map[nums[i]][2] = i;\n           \n        } \n        int degree = 0;\n        int res = 0;\n        for(auto key : map){\n           if(key.second[0] &gt; degree || key.second[0] == degree &amp;&amp; \n              key.second[2] - key.second[1] + 1 &lt; res){\n               degree = key.second[0];\n               res = key.second[2] - key.second[1] + 1;\n           }\n       } \n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 697&gt; Degree of an Array\n\nclass Solution {\npublic:\n    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int,vector&lt;int&gt;&gt; map;\n        for(int i=0; i &lt; nums.size(); i++) {\n            if(map.count(nums[i])==0) { \n                map[nums[i]] = {0,i,i};\n            }\n            map[nums[i]][0] += 1;\n            map[nums[i]][2] = i;\n           \n        } \n        int degree = 0;\n        int res = 0;\n        for(auto key : map){\n           if(key.second[0] &gt; degree || key.second[0] == degree &amp;&amp; \n              key.second[2] - key.second[1] + 1 &lt; res){\n               degree = key.second[0];\n               res = key.second[2] - key.second[1] + 1;\n           }\n       } \n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/24/697-Degree-of-an-Array/"
      },
    
      {
        "title": "Rotate String",
        "excerpt": "&lt;-E 796&gt; Rotate String\n\nclass Solution {\npublic:\n    bool rotateString(string str1, string str2) {\n        if (str1.length() != str2.length()) \n        return false; \n  \n       string temp = str1 + str1;  \n       return (temp.find(str2) != string::npos); \n    }\n};\n\n\n",
        "content": "&lt;-E 796&gt; Rotate String\n\nclass Solution {\npublic:\n    bool rotateString(string str1, string str2) {\n        if (str1.length() != str2.length()) \n        return false; \n  \n       string temp = str1 + str1;  \n       return (temp.find(str2) != string::npos); \n    }\n};\n\n\n",
        "url": "/2020/12/24/796-Rotate-String/"
      },
    
      {
        "title": "Verifying an Alien Dictionary",
        "excerpt": "&lt;-E 953&gt; Verifying an Alien Dictionary\n\nclass Solution {\npublic:\n    bool isAlienSorted(vector&lt;string&gt;&amp; words, string order) {\n        int ord[26];\n        for (int i = 0; i &lt; order.size(); ++i) {\n            ord[order[i] - 'a'] = i;\n        }\n        for (int i = 0; i &lt; words.size()-1; ++i) {\n            if (!checkTwo(words[i], words[i+1], ord)) \n                return false;\n        }\n        return true;\n    \n    }\n    \n    bool checkTwo(string&amp; s1, string&amp; s2, int (&amp;ord)[26]) {\n        if (s1.find(s2) == 0 &amp;&amp; s1.size() &gt; s2.size()) \n            return false;\n        int i = 0;\n        while (i &lt; s1.size() &amp;&amp; i &lt; s2.size()) {\n            if (ord[s1[i] - 'a'] &gt; ord[s2[i] - 'a'])\n                return false;\n            else if (ord[s1[i] - 'a'] &lt; ord[s2[i] - 'a'])\n                return true;\n            ++i;\n        }\n        return true;\n    }\n    \n};\n\n\n",
        "content": "&lt;-E 953&gt; Verifying an Alien Dictionary\n\nclass Solution {\npublic:\n    bool isAlienSorted(vector&lt;string&gt;&amp; words, string order) {\n        int ord[26];\n        for (int i = 0; i &lt; order.size(); ++i) {\n            ord[order[i] - 'a'] = i;\n        }\n        for (int i = 0; i &lt; words.size()-1; ++i) {\n            if (!checkTwo(words[i], words[i+1], ord)) \n                return false;\n        }\n        return true;\n    \n    }\n    \n    bool checkTwo(string&amp; s1, string&amp; s2, int (&amp;ord)[26]) {\n        if (s1.find(s2) == 0 &amp;&amp; s1.size() &gt; s2.size()) \n            return false;\n        int i = 0;\n        while (i &lt; s1.size() &amp;&amp; i &lt; s2.size()) {\n            if (ord[s1[i] - 'a'] &gt; ord[s2[i] - 'a'])\n                return false;\n            else if (ord[s1[i] - 'a'] &lt; ord[s2[i] - 'a'])\n                return true;\n            ++i;\n        }\n        return true;\n    }\n    \n};\n\n\n",
        "url": "/2020/12/24/953-Verifying-an-Alien-Dictionary/"
      },
    
      {
        "title": "N-th Tribonacci Number",
        "excerpt": "&lt;-E 1137&gt; N-th Tribonacci Number\n\nclass Solution {\npublic:\n    int tribonacci(int n) {\n        int f[38];\n        f[0]=0;\n        f[1]=1;\n        f[2]=1;\n        for (int i=3;i&lt;=n;i++) {\n            f[i]=f[i-1]+f[i-2]+f[i-3];\n        }\n        return f[n];\n    }\n};\n\n\n",
        "content": "&lt;-E 1137&gt; N-th Tribonacci Number\n\nclass Solution {\npublic:\n    int tribonacci(int n) {\n        int f[38];\n        f[0]=0;\n        f[1]=1;\n        f[2]=1;\n        for (int i=3;i&lt;=n;i++) {\n            f[i]=f[i-1]+f[i-2]+f[i-3];\n        }\n        return f[n];\n    }\n};\n\n\n",
        "url": "/2020/12/25/1137-N-th-Tribonacci-Number/"
      },
    
      {
        "title": "Reformat The String",
        "excerpt": "&lt;-E 1417&gt; Reformat The String\n\nclass Solution {\npublic:\n    string reformat(string s)  {\n\tstring ans(s.size(), ' ');\n    int charnum = 0;\n    int num = 0;\n    \n    bool flag = false;\n    for (auto i : s) {\n         if(isalpha(i)) \n             charnum++;             \n         else \n             num++;\n    }\n    \n\tif (abs(num - charnum) &gt; 1) \n        return \"\";\n    int index_num;\n    int index_char;\n    if(num &gt; charnum) {\n        index_num = 0;\n        index_char = 1;\n    }\n    else {\n        index_num = 1;\n        index_char = 0;\n    }\n\n\tfor (auto i : s) {\n         if(isalpha(i)) {\n             ans[index_char] = i;\n             index_char += 2;    \n         } else {      \n             ans[index_num] = i;\n             index_num += 2;    \n         }\n    }\n\treturn ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1417&gt; Reformat The String\n\nclass Solution {\npublic:\n    string reformat(string s)  {\n\tstring ans(s.size(), ' ');\n    int charnum = 0;\n    int num = 0;\n    \n    bool flag = false;\n    for (auto i : s) {\n         if(isalpha(i)) \n             charnum++;             \n         else \n             num++;\n    }\n    \n\tif (abs(num - charnum) &gt; 1) \n        return \"\";\n    int index_num;\n    int index_char;\n    if(num &gt; charnum) {\n        index_num = 0;\n        index_char = 1;\n    }\n    else {\n        index_num = 1;\n        index_char = 0;\n    }\n\n\tfor (auto i : s) {\n         if(isalpha(i)) {\n             ans[index_char] = i;\n             index_char += 2;    \n         } else {      \n             ans[index_num] = i;\n             index_num += 2;    \n         }\n    }\n\treturn ans;\n    }\n};\n\n\n",
        "url": "/2020/12/25/11417-Reformat-The-String/"
      },
    
      {
        "title": "Day of the Year",
        "excerpt": "&lt;-E 1154&gt; Day of the Year\n\nclass Solution {\npublic:\n    bool isLeap(int y){\n\t\treturn (y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 400 == 0);\n\t}\n\n\tint getMonth(int m,int y){\n\t\tif(m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12) return 31;\n\t\tif(m==2) return isLeap(y) ? 29 : 28;\n\t\treturn 30;\n\t}\n\n\tint dayOfYear(string date) {\n\t\tint y = stoi(date.substr(0,4));\n\t\tint m = stoi(date.substr(5,2));\n\t\tint d = stoi(date.substr(8,2));\n\n\t\tint days = 0;\n\t\tdays += d;\n\n\t\tfor(int month = 1; month &lt; m ; month++){\n\t\t\tdays += getMonth(month,y);\n\t\t}\n\n\t\treturn days;\n\t}\n    \n};\n\n\n",
        "content": "&lt;-E 1154&gt; Day of the Year\n\nclass Solution {\npublic:\n    bool isLeap(int y){\n\t\treturn (y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 400 == 0);\n\t}\n\n\tint getMonth(int m,int y){\n\t\tif(m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12) return 31;\n\t\tif(m==2) return isLeap(y) ? 29 : 28;\n\t\treturn 30;\n\t}\n\n\tint dayOfYear(string date) {\n\t\tint y = stoi(date.substr(0,4));\n\t\tint m = stoi(date.substr(5,2));\n\t\tint d = stoi(date.substr(8,2));\n\n\t\tint days = 0;\n\t\tdays += d;\n\n\t\tfor(int month = 1; month &lt; m ; month++){\n\t\t\tdays += getMonth(month,y);\n\t\t}\n\n\t\treturn days;\n\t}\n    \n};\n\n\n",
        "url": "/2020/12/25/1154-Day-of-the-Year/"
      },
    
      {
        "title": "Maximum Score After Splitting a String",
        "excerpt": "&lt;-E 1422&gt; Maximum Score After Splitting a String\n\nclass Solution {\npublic:\n    int maxScore(const string&amp; s) {\n        int one = count(s.begin(), s.end(), '1');\n        int zero = 0;\n        int score = 0;\n        for(int i = 0; i&lt;s.size() - 1; ++i)\n            score = (s[i] =='0') ? max(score, ++zero + one) :\n                                    max(score, --one + zero);\n        return score;\n    }\n};\n\n\n",
        "content": "&lt;-E 1422&gt; Maximum Score After Splitting a String\n\nclass Solution {\npublic:\n    int maxScore(const string&amp; s) {\n        int one = count(s.begin(), s.end(), '1');\n        int zero = 0;\n        int score = 0;\n        for(int i = 0; i&lt;s.size() - 1; ++i)\n            score = (s[i] =='0') ? max(score, ++zero + one) :\n                                    max(score, --one + zero);\n        return score;\n    }\n};\n\n\n",
        "url": "/2020/12/25/1422-Maximum-Score-After-Splitting-a-String/"
      },
    
      {
        "title": "Path Crossing",
        "excerpt": "&lt;-E 1496&gt; Path Crossing\n\nclass Solution {\npublic:\n    bool isPathCrossing(const string&amp; path) {\n        unordered_set&lt;string&gt; us;\n        us.insert(\"0.0\");\n        const string point {\".\"};\n        int x = 0, y = 0;\n        for(auto i : path) {\n            switch(i) {\n                case'N': ++y; break;\n                case'S': --y; break;\n                case'E': --x; break;\n                case'W': ++x; break;\n            }\n            string s {to_string(x)+point+to_string(y)};\n            if(us.count(s)) return true;\n            us.insert(s);\n        }\n        return false;\n    }\n};\n\n\n",
        "content": "&lt;-E 1496&gt; Path Crossing\n\nclass Solution {\npublic:\n    bool isPathCrossing(const string&amp; path) {\n        unordered_set&lt;string&gt; us;\n        us.insert(\"0.0\");\n        const string point {\".\"};\n        int x = 0, y = 0;\n        for(auto i : path) {\n            switch(i) {\n                case'N': ++y; break;\n                case'S': --y; break;\n                case'E': --x; break;\n                case'W': ++x; break;\n            }\n            string s {to_string(x)+point+to_string(y)};\n            if(us.count(s)) return true;\n            us.insert(s);\n        }\n        return false;\n    }\n};\n\n\n",
        "url": "/2020/12/25/1496-Path-Crossing/"
      },
    
      {
        "title": "Most Visited Sector in a Circular Track",
        "excerpt": "&lt;-E 1560&gt; Most Visited Sector in a Circular Track\n\nclass Solution {\npublic:\n    vector&lt;int&gt; mostVisited(int n, vector&lt;int&gt;&amp; rounds) {\n       vector&lt;int&gt; res; \n        if(rounds[0] &lt;= rounds.back()) {\n            for(int i = rounds[0]; i &lt;= rounds.back(); i++) {\n                res.push_back(i);\n            }\n        } else {\n            for(int i = 1; i &lt;= n; i++) {\n                if(i &gt;= rounds[0] || i &lt;= rounds.back())\n                    res.push_back(i);\n            }\n        }\n        return res; \n    }\n};\n\n\n",
        "content": "&lt;-E 1560&gt; Most Visited Sector in a Circular Track\n\nclass Solution {\npublic:\n    vector&lt;int&gt; mostVisited(int n, vector&lt;int&gt;&amp; rounds) {\n       vector&lt;int&gt; res; \n        if(rounds[0] &lt;= rounds.back()) {\n            for(int i = rounds[0]; i &lt;= rounds.back(); i++) {\n                res.push_back(i);\n            }\n        } else {\n            for(int i = 1; i &lt;= n; i++) {\n                if(i &gt;= rounds[0] || i &lt;= rounds.back())\n                    res.push_back(i);\n            }\n        }\n        return res; \n    }\n};\n\n\n",
        "url": "/2020/12/25/1560-Most-Visited-Sector-in-a-Circular-Track/"
      },
    
      {
        "title": "Two Sum IV - Input is a BST",
        "excerpt": "&lt;-E 653&gt; Two Sum IV - Input is a BST\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n // Method 1.1\nclass Solution {  \npublic:\n    vector&lt;int&gt; v;\n     bool findNums(TreeNode* node, int k) {\n            if(!node) \n                return false;\n            if(findNums(node-&gt;left, k)) \n                return true;\n            if(binary_search(v.begin(),v.end(),k-node-&gt;val)) \n                return true;\n            v.push_back(node-&gt;val);\n            return findNums(node-&gt;right, k);\n    };\n    bool findTarget(TreeNode* root, int k) {\n        return findNums(root, k);\n    }\n};\n\n// Method 1.2\nclass Solution {\npublic:\n    bool findTarget(TreeNode* root, int k) {\n        vector&lt;int&gt; v;\n        function&lt;bool(TreeNode*)&gt; findNums = [&amp;](TreeNode* node){\n            if(!node) return false;\n            if(findNums(node-&gt;left)) return true;\n            if(binary_search(v.begin(),v.end(),k-node-&gt;val)) return true;\n            v.push_back(node-&gt;val);\n            return findNums(node-&gt;right);\n        };\n        return findNums(root);\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void inorder(TreeNode *root,vector&lt;int&gt; &amp;arr) {\n        if(root == NULL)\n            return ;\n        inorder(root-&gt;left, arr);\n        arr.push_back(root-&gt;val);\n        inorder(root-&gt;right, arr);\n    }\n    bool findTarget(TreeNode* root, int k) {\n        vector&lt;int&gt; arr;\n        inorder(root,arr);\n        int i = 0,j = arr.size() - 1;\n        while(i &lt; j) {\n            if(arr[i] + arr[j] == k)\n                return true;\n            if(arr[i] + arr[j] &lt; k)\n                i++;\n            else\n                j--;\n        }\n        return false;\n    }\n};\n\n\n",
        "content": "&lt;-E 653&gt; Two Sum IV - Input is a BST\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n // Method 1.1\nclass Solution {  \npublic:\n    vector&lt;int&gt; v;\n     bool findNums(TreeNode* node, int k) {\n            if(!node) \n                return false;\n            if(findNums(node-&gt;left, k)) \n                return true;\n            if(binary_search(v.begin(),v.end(),k-node-&gt;val)) \n                return true;\n            v.push_back(node-&gt;val);\n            return findNums(node-&gt;right, k);\n    };\n    bool findTarget(TreeNode* root, int k) {\n        return findNums(root, k);\n    }\n};\n\n// Method 1.2\nclass Solution {\npublic:\n    bool findTarget(TreeNode* root, int k) {\n        vector&lt;int&gt; v;\n        function&lt;bool(TreeNode*)&gt; findNums = [&amp;](TreeNode* node){\n            if(!node) return false;\n            if(findNums(node-&gt;left)) return true;\n            if(binary_search(v.begin(),v.end(),k-node-&gt;val)) return true;\n            v.push_back(node-&gt;val);\n            return findNums(node-&gt;right);\n        };\n        return findNums(root);\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void inorder(TreeNode *root,vector&lt;int&gt; &amp;arr) {\n        if(root == NULL)\n            return ;\n        inorder(root-&gt;left, arr);\n        arr.push_back(root-&gt;val);\n        inorder(root-&gt;right, arr);\n    }\n    bool findTarget(TreeNode* root, int k) {\n        vector&lt;int&gt; arr;\n        inorder(root,arr);\n        int i = 0,j = arr.size() - 1;\n        while(i &lt; j) {\n            if(arr[i] + arr[j] == k)\n                return true;\n            if(arr[i] + arr[j] &lt; k)\n                i++;\n            else\n                j--;\n        }\n        return false;\n    }\n};\n\n\n",
        "url": "/2020/12/25/653-Two-Sum-IV-Input-is-a-BST/"
      },
    
      {
        "title": "Employee Importance",
        "excerpt": "&lt;-E 690&gt; Employee Importance\n\n/*\n// Definition for Employee.\nclass Employee {\npublic:\n    int id;\n    int importance;\n    vector&lt;int&gt; subordinates;\n};\n*/\n// Method 1\nclass Solution {\npublic:\n    int getImportance(vector&lt;Employee*&gt; employees, int id) {\n        unordered_map&lt;int, Employee*&gt;m;\n        for(auto x: employees) \n\t\t\tm[x-&gt;id] = x;\n        int sum = 0;\n        deque&lt;Employee*&gt; q;\n        q.push_back(m[id]);\n        while(!q.empty()) {\n            auto p = q.front();\n            q.pop_front();\n            for(auto x: p-&gt;subordinates) q.push_back(m[x]);\n            sum += p-&gt;importance;\n        }\n        return sum;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int findImportanceValue(vector&lt;Employee*&gt; employees, int id) {\n    Employee* currentEmployee;\n    for(int i = 0; i &lt; employees.size(); i++) {\n        if(employees[i]-&gt;id ==  id) {\n            currentEmployee = employees[i];\n            break;\n        }\n    }\n    int totalExp = currentEmployee-&gt;importance;\n    for(int i = 0;i&lt;currentEmployee-&gt;subordinates.size(); i++) {\n        totalExp += (findImportanceValue(employees, currentEmployee-&gt;subordinates[i]));\n    }\n    return totalExp;\n\t}\n    int getImportance(vector&lt;Employee*&gt; employees, int id) {\n        return findImportanceValue(employees,id);\n    }\n};\n\n\n",
        "content": "&lt;-E 690&gt; Employee Importance\n\n/*\n// Definition for Employee.\nclass Employee {\npublic:\n    int id;\n    int importance;\n    vector&lt;int&gt; subordinates;\n};\n*/\n// Method 1\nclass Solution {\npublic:\n    int getImportance(vector&lt;Employee*&gt; employees, int id) {\n        unordered_map&lt;int, Employee*&gt;m;\n        for(auto x: employees) \n\t\t\tm[x-&gt;id] = x;\n        int sum = 0;\n        deque&lt;Employee*&gt; q;\n        q.push_back(m[id]);\n        while(!q.empty()) {\n            auto p = q.front();\n            q.pop_front();\n            for(auto x: p-&gt;subordinates) q.push_back(m[x]);\n            sum += p-&gt;importance;\n        }\n        return sum;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int findImportanceValue(vector&lt;Employee*&gt; employees, int id) {\n    Employee* currentEmployee;\n    for(int i = 0; i &lt; employees.size(); i++) {\n        if(employees[i]-&gt;id ==  id) {\n            currentEmployee = employees[i];\n            break;\n        }\n    }\n    int totalExp = currentEmployee-&gt;importance;\n    for(int i = 0;i&lt;currentEmployee-&gt;subordinates.size(); i++) {\n        totalExp += (findImportanceValue(employees, currentEmployee-&gt;subordinates[i]));\n    }\n    return totalExp;\n\t}\n    int getImportance(vector&lt;Employee*&gt; employees, int id) {\n        return findImportanceValue(employees,id);\n    }\n};\n\n\n",
        "url": "/2020/12/25/690-Employee-Importance/"
      },
    
      {
        "title": "Count Binary Substrings",
        "excerpt": "&lt;-E 696&gt; Count Binary Substrings\n\n// Method 1\nclass Solution {\npublic:\nint countBinarySubstrings(string s) {\n    int ans = 0, previous = 0, current = 1;\n    for(int i = 1 ; i &lt; s.size() ; i++){\n        if(s[i] == s[i-1]) current++;\n        else{\n            previous = current;\n            current = 1;\n        }\n        if(current &lt;= previous) ans++;\n    }\n    return ans;\n\t}\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countBinarySubstrings(string s) {        \n        ios_base::sync_with_stdio(0); cin.tie(0);\n        int i = 0, res = 0, pre = 0, l = s.size();  \n        for (int j=0;j &lt; l;j++) {\n            if (s[i]!=s[j]) {             \n                res += min(pre,j-i);     \n                pre = j - i;\n                i = j;\n            }            \n        }           \n        return res+min(pre,l-i);        \n    }\n};\n\n\n",
        "content": "&lt;-E 696&gt; Count Binary Substrings\n\n// Method 1\nclass Solution {\npublic:\nint countBinarySubstrings(string s) {\n    int ans = 0, previous = 0, current = 1;\n    for(int i = 1 ; i &lt; s.size() ; i++){\n        if(s[i] == s[i-1]) current++;\n        else{\n            previous = current;\n            current = 1;\n        }\n        if(current &lt;= previous) ans++;\n    }\n    return ans;\n\t}\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countBinarySubstrings(string s) {        \n        ios_base::sync_with_stdio(0); cin.tie(0);\n        int i = 0, res = 0, pre = 0, l = s.size();  \n        for (int j=0;j &lt; l;j++) {\n            if (s[i]!=s[j]) {             \n                res += min(pre,j-i);     \n                pre = j - i;\n                i = j;\n            }            \n        }           \n        return res+min(pre,l-i);        \n    }\n};\n\n\n",
        "url": "/2020/12/25/696-Count-Binary-Substrings/"
      },
    
      {
        "title": "Flood Fill",
        "excerpt": "&lt;-E 733&gt; Flood Fill\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) {\n        int prevColor = image[sr][sc];\n        dfs(image, sr, sc, prevColor, newColor);\n        return image;\n    }\n    \n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int prevColor, int newColor){\n        if(sr&lt;0 || sr&gt;=image.size() || sc&lt;0 || sc&gt;=image[0].size()){\n            return;\n        }\n        \n        if(image[sr][sc] != prevColor){\n            return;\n        }\n        if(image[sr][sc] == newColor){\n            return;\n        }\n        image[sr][sc] = newColor;\n        dfs(image,sr + 1, sc, prevColor, newColor);\n        dfs(image,sr - 1, sc, prevColor, newColor);\n        dfs(image,sr, sc + 1, prevColor, newColor);\n        dfs(image, sr, sc-1, prevColor, newColor);\n    }  \n};\n\n\n",
        "content": "&lt;-E 733&gt; Flood Fill\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) {\n        int prevColor = image[sr][sc];\n        dfs(image, sr, sc, prevColor, newColor);\n        return image;\n    }\n    \n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int prevColor, int newColor){\n        if(sr&lt;0 || sr&gt;=image.size() || sc&lt;0 || sc&gt;=image[0].size()){\n            return;\n        }\n        \n        if(image[sr][sc] != prevColor){\n            return;\n        }\n        if(image[sr][sc] == newColor){\n            return;\n        }\n        image[sr][sc] = newColor;\n        dfs(image,sr + 1, sc, prevColor, newColor);\n        dfs(image,sr - 1, sc, prevColor, newColor);\n        dfs(image,sr, sc + 1, prevColor, newColor);\n        dfs(image, sr, sc-1, prevColor, newColor);\n    }  \n};\n\n\n",
        "url": "/2020/12/25/733-Flood-Filly/"
      },
    
      {
        "title": "Pascal's Triangle",
        "excerpt": "&lt;-E 118&gt; Pascal’s Triangle\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {\n        vector&lt;vector&lt;int&gt;&gt; answer;\n        for(int i = 1; i &lt;= numRows; i++) {\n            vector&lt;int&gt; sub(i,1);\n            for(int j = 1; j &lt; i - 1; j++) {\n                sub[j] = answer[i-2][j] + answer[i-2][j-1];\n            }\n            answer.push_back(sub);\n        }\n        return answer;\n    }\n};\n\n\n",
        "content": "&lt;-E 118&gt; Pascal’s Triangle\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {\n        vector&lt;vector&lt;int&gt;&gt; answer;\n        for(int i = 1; i &lt;= numRows; i++) {\n            vector&lt;int&gt; sub(i,1);\n            for(int j = 1; j &lt; i - 1; j++) {\n                sub[j] = answer[i-2][j] + answer[i-2][j-1];\n            }\n            answer.push_back(sub);\n        }\n        return answer;\n    }\n};\n\n\n",
        "url": "/2020/12/26/118-Pascal's-Triangle/"
      },
    
      {
        "title": "Distance Between Bus Stops",
        "excerpt": "&lt;-E 1184&gt; Distance Between Bus Stops\n\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) {\n        int sum = accumulate(distance.begin(), distance.end(), 0);\n        int sum1 = 0;\n        int check = max(start, destination);\n        for(int i = min(start, destination);i &lt; check; i++)\n            sum1 += distance[i];\n        return min(sum - sum1, sum1);\n    }\n};\n\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) {\n        int sum0 = 0;\n        for (int i = start; i != destination; i = (i+1) % distance.size()) {\n            sum0 += distance[i];\n        }\n        \n        int sum1 = 0;\n        for (int i = start; i != destination; i = (i-1+distance.size()) % distance.size()) {\n            sum1 += distance[(i-1+distance.size()) % distance.size()];\n        }\n        \n        return min(sum0, sum1);\n    }\n};\n\n\n",
        "content": "&lt;-E 1184&gt; Distance Between Bus Stops\n\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) {\n        int sum = accumulate(distance.begin(), distance.end(), 0);\n        int sum1 = 0;\n        int check = max(start, destination);\n        for(int i = min(start, destination);i &lt; check; i++)\n            sum1 += distance[i];\n        return min(sum - sum1, sum1);\n    }\n};\n\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) {\n        int sum0 = 0;\n        for (int i = start; i != destination; i = (i+1) % distance.size()) {\n            sum0 += distance[i];\n        }\n        \n        int sum1 = 0;\n        for (int i = start; i != destination; i = (i-1+distance.size()) % distance.size()) {\n            sum1 += distance[(i-1+distance.size()) % distance.size()];\n        }\n        \n        return min(sum0, sum1);\n    }\n};\n\n\n",
        "url": "/2020/12/26/1184-Distance-Between-Bus-Stops/"
      },
    
      {
        "title": "Count Odd Numbers in an Interval Range",
        "excerpt": "&lt;-E 1523&gt; Count Odd Numbers in an Interval Range\n\nclass Solution {\npublic:\n    int countOdds(int low,int high) {\n        return (high - low + high % 2 + low % 2) / 2;\n    }\n};\n\n\n",
        "content": "&lt;-E 1523&gt; Count Odd Numbers in an Interval Range\n\nclass Solution {\npublic:\n    int countOdds(int low,int high) {\n        return (high - low + high % 2 + low % 2) / 2;\n    }\n};\n\n\n",
        "url": "/2020/12/26/1523-Count-Odd-Numbers-in-an-Interval-Range/"
      },
    
      {
        "title": "Make The String Great",
        "excerpt": "&lt;-E 1544&gt; Make The String Great\n\nclass Solution {\npublic:\n    string makeGood(string s) {\n        if (s.size() == 0) \n            return s;\n        string stack = \"\";\n        for (auto p: s) {\n            if (abs(p - stack.back()) == 32) {\n                stack.pop_back();\n            }\n            else {\n                stack += p;\n            }\n        }\n        return stack;\n    }\n};\n\n\n",
        "content": "&lt;-E 1544&gt; Make The String Great\n\nclass Solution {\npublic:\n    string makeGood(string s) {\n        if (s.size() == 0) \n            return s;\n        string stack = \"\";\n        for (auto p: s) {\n            if (abs(p - stack.back()) == 32) {\n                stack.pop_back();\n            }\n            else {\n                stack += p;\n            }\n        }\n        return stack;\n    }\n};\n\n\n",
        "url": "/2020/12/26/1544-Make-The-String-Great/"
      },
    
      {
        "title": "Reformat Phone Number",
        "excerpt": "&lt;-E 1694&gt; Reformat Phone Number\n\nclass Solution {\npublic:\n    string reformatNumber(string number) {\n        string tmp, res;\n        for (char c : number) {\n            if (isdigit(c)) tmp.push_back(c);\n        }\n        for (int i = 0; i &lt; tmp.size();) {\n            if (tmp.size() - i &gt; 4) {\n                res += tmp.substr(i, 3);\n                res.push_back('-');\n                i += 3;\n            } else if (tmp.size() - i == 4) {\n                res += tmp.substr(i, 2);\n                res.push_back('-');\n                i += 2;\n                res += tmp.substr(i, 2);\n                break;\n            } else {\n                res += tmp.substr(i);\n                break;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 1694&gt; Reformat Phone Number\n\nclass Solution {\npublic:\n    string reformatNumber(string number) {\n        string tmp, res;\n        for (char c : number) {\n            if (isdigit(c)) tmp.push_back(c);\n        }\n        for (int i = 0; i &lt; tmp.size();) {\n            if (tmp.size() - i &gt; 4) {\n                res += tmp.substr(i, 3);\n                res.push_back('-');\n                i += 3;\n            } else if (tmp.size() - i == 4) {\n                res += tmp.substr(i, 2);\n                res.push_back('-');\n                i += 2;\n                res += tmp.substr(i, 2);\n                break;\n            } else {\n                res += tmp.substr(i);\n                break;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/26/1694-Reformat-Phone-Number/"
      },
    
      {
        "title": "Minimum Absolute Difference in BST",
        "excerpt": "&lt;-E 530&gt; Minimum Absolute Difference in BST\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void find(TreeNode* root, int &amp;mini, int &amp;prev){\n        if(!root)   return;\n        find(root-&gt;left, mini, prev);\n        if(prev != -1)  mini = min(abs(root-&gt;val - prev), mini);\n        prev = root-&gt;val;\n        find(root-&gt;right, mini, prev);\n    }\n\n    int getMinimumDifference(TreeNode* root){\n        int mini = INT_MAX, prev = -1;\n        find(root, mini, prev);\n        return mini;\n    }\n};\n\n\n",
        "content": "&lt;-E 530&gt; Minimum Absolute Difference in BST\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void find(TreeNode* root, int &amp;mini, int &amp;prev){\n        if(!root)   return;\n        find(root-&gt;left, mini, prev);\n        if(prev != -1)  mini = min(abs(root-&gt;val - prev), mini);\n        prev = root-&gt;val;\n        find(root-&gt;right, mini, prev);\n    }\n\n    int getMinimumDifference(TreeNode* root){\n        int mini = INT_MAX, prev = -1;\n        find(root, mini, prev);\n        return mini;\n    }\n};\n\n\n",
        "url": "/2020/12/26/530-Minimum-Absolute-Difference-in-BST/"
      },
    
      {
        "title": "Construct String from Binary Tree",
        "excerpt": "&lt;-E 606&gt; Construct String from Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string tree2str(TreeNode* t) {\n        if (!t) return \"\";\n        if (!t-&gt;left and !t-&gt;right) return to_string(t-&gt;val);\n        string s = to_string(t-&gt;val) + '(' + tree2str(t-&gt;left) + ')';\n        if (t-&gt;right)\n            s = s + '(' + tree2str(t-&gt;right) + ')';\n        return s;\n    }\n};\n\n\n",
        "content": "&lt;-E 606&gt; Construct String from Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string tree2str(TreeNode* t) {\n        if (!t) return \"\";\n        if (!t-&gt;left and !t-&gt;right) return to_string(t-&gt;val);\n        string s = to_string(t-&gt;val) + '(' + tree2str(t-&gt;left) + ')';\n        if (t-&gt;right)\n            s = s + '(' + tree2str(t-&gt;right) + ')';\n        return s;\n    }\n};\n\n\n",
        "url": "/2020/12/26/606-Construct-String-from-Binary-Tree/"
      },
    
      {
        "title": "Minimum Distance Between BST Nodes",
        "excerpt": "&lt;-E 783&gt; Minimum Distance Between BST Nodes\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n     int min_val = INT_MAX, prev = -1;\npublic:\n    void inorder(TreeNode *root){\n        if(!root)\n            return;\n        inorder(root-&gt;left);\n        if(prev != -1)\n            min_val = min(min_val, abs(root-&gt;val-prev));\n        prev= root-&gt;val;\n        inorder(root-&gt;right);\n    }\n\n    int minDiffInBST(TreeNode* root) {\n        inorder(root);\n        return min_val;\n    }\n};\n\n\n",
        "content": "&lt;-E 783&gt; Minimum Distance Between BST Nodes\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n     int min_val = INT_MAX, prev = -1;\npublic:\n    void inorder(TreeNode *root){\n        if(!root)\n            return;\n        inorder(root-&gt;left);\n        if(prev != -1)\n            min_val = min(min_val, abs(root-&gt;val-prev));\n        prev= root-&gt;val;\n        inorder(root-&gt;right);\n    }\n\n    int minDiffInBST(TreeNode* root) {\n        inorder(root);\n        return min_val;\n    }\n};\n\n\n",
        "url": "/2020/12/26/783-Minimum-Distance-Between-BST-Nodes/"
      },
    
      {
        "title": "Reorder Data in Log Files",
        "excerpt": "&lt;-E 937&gt; Reorder Data in Log Files\n\nclass Solution {\npublic:\n    struct comp{\n        bool operator() (pair&lt;string,string&gt; &amp; a, pair&lt;string,string&gt; &amp; b) {\n            return a.second == b.second ? a.first &lt; b.first: a.second &lt; b.second;\n        }\n    };\n    vector&lt;string&gt; reorderLogFiles(vector&lt;string&gt;&amp; logs) {\n        vector&lt;pair&lt;string,string&gt;&gt; letter;\n        vector&lt;string&gt; digit;\n        for(string s: logs) {\n            int ind = s.find(' ');\n            if(s[ind+1] &gt;= 'a') {\n                letter.emplace_back(make_pair(s.substr(0,ind), s.substr(ind+1)));\n            } else {\n                digit.push_back(s);\n            }\n        }\n        sort(letter.begin(),letter.end(),comp());\n        vector&lt;string&gt; result;\n        for(auto&amp; l : letter) {\n            result.push_back(l.first + \" \" + l.second);\n        }\n        for(string d: digit) \n            result.push_back(d);\n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-E 937&gt; Reorder Data in Log Files\n\nclass Solution {\npublic:\n    struct comp{\n        bool operator() (pair&lt;string,string&gt; &amp; a, pair&lt;string,string&gt; &amp; b) {\n            return a.second == b.second ? a.first &lt; b.first: a.second &lt; b.second;\n        }\n    };\n    vector&lt;string&gt; reorderLogFiles(vector&lt;string&gt;&amp; logs) {\n        vector&lt;pair&lt;string,string&gt;&gt; letter;\n        vector&lt;string&gt; digit;\n        for(string s: logs) {\n            int ind = s.find(' ');\n            if(s[ind+1] &gt;= 'a') {\n                letter.emplace_back(make_pair(s.substr(0,ind), s.substr(ind+1)));\n            } else {\n                digit.push_back(s);\n            }\n        }\n        sort(letter.begin(),letter.end(),comp());\n        vector&lt;string&gt; result;\n        for(auto&amp; l : letter) {\n            result.push_back(l.first + \" \" + l.second);\n        }\n        for(string d: digit) \n            result.push_back(d);\n        return result;\n    }\n};\n\n\n",
        "url": "/2020/12/26/937-Reorder-Data-in-Log-Files/"
      },
    
      {
        "title": "Pascal's Triangle II",
        "excerpt": "&lt;-E 119&gt; Pascal’s Triangle II\n\nclass Solution {\npublic:\n    vector &lt;int&gt; getRow(int rowIndex) {\n        \n        int rowNumber = rowIndex + 1;\n        vector result(rowNumber, 1);\n        for (int i = 2; i &lt; rowNumber; i++) {\n            int prev = 1;\n            for (int j = 1; j &lt; i; j++) {\n                int temp = result[j];\n                result[j] = temp + prev;\n                prev = temp;\n            }\n        }\n        return result;\n\n    }\n};\n\n\n",
        "content": "&lt;-E 119&gt; Pascal’s Triangle II\n\nclass Solution {\npublic:\n    vector &lt;int&gt; getRow(int rowIndex) {\n        \n        int rowNumber = rowIndex + 1;\n        vector result(rowNumber, 1);\n        for (int i = 2; i &lt; rowNumber; i++) {\n            int prev = 1;\n            for (int j = 1; j &lt; i; j++) {\n                int temp = result[j];\n                result[j] = temp + prev;\n                prev = temp;\n            }\n        }\n        return result;\n\n    }\n};\n\n\n",
        "url": "/2020/12/27/119-Pascal's-Triangle-II/"
      },
    
      {
        "title": "Number of Students Unable to Eat Lunch",
        "excerpt": "&lt;-E 1700&gt; Number of Students Unable to Eat Lunch\n\n// Method 1\nclass Solution {\npublic:\n    int countStudents(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {\n        int count[] = {0, 0}, n = A.size(), k;\n        for (int a : A)\n            count[a]++;\n        for (k = 0; k &lt; n &amp;&amp; count[B[k]] &gt; 0; ++k)\n            count[B[k]]--;\n        return n - k;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) {\n        queue&lt;int&gt; Q;\n        int c[2] = {0, 0};\n        for (int s : students) {\n            Q.push(s);\n            c[s] += 1;\n        }\n        \n        for (int s : sandwiches) {\n            if (c[s] == 0) break;\n            while (Q.front() != s) {\n                Q.pop();\n                Q.push(1 - s);\n            }\n            c[s]-- ;\n        }\n        return c[0] + c[1];\n    }\n};\n\n\n",
        "content": "&lt;-E 1700&gt; Number of Students Unable to Eat Lunch\n\n// Method 1\nclass Solution {\npublic:\n    int countStudents(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {\n        int count[] = {0, 0}, n = A.size(), k;\n        for (int a : A)\n            count[a]++;\n        for (k = 0; k &lt; n &amp;&amp; count[B[k]] &gt; 0; ++k)\n            count[B[k]]--;\n        return n - k;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) {\n        queue&lt;int&gt; Q;\n        int c[2] = {0, 0};\n        for (int s : students) {\n            Q.push(s);\n            c[s] += 1;\n        }\n        \n        for (int s : sandwiches) {\n            if (c[s] == 0) break;\n            while (Q.front() != s) {\n                Q.pop();\n                Q.push(1 - s);\n            }\n            c[s]-- ;\n        }\n        return c[0] + c[1];\n    }\n};\n\n\n",
        "url": "/2020/12/27/1700-Number-of-Students-Unable-to-Eat-Lunch/"
      },
    
      {
        "title": "Is Subsequence",
        "excerpt": "&lt;-E 392&gt; Is Subsequence\n\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        if(s == t)\n            return true;\n        int c = 0;\n        for(int i = 0; i &lt; t.size(); i++) \n            if(s[c] == t[i])\n                c++;\n        if(c == s.size())\n            return true;\n        else        \n            return false;\n    \n    }\n};\n\n\n",
        "content": "&lt;-E 392&gt; Is Subsequence\n\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        if(s == t)\n            return true;\n        int c = 0;\n        for(int i = 0; i &lt; t.size(); i++) \n            if(s[c] == t[i])\n                c++;\n        if(c == s.size())\n            return true;\n        else        \n            return false;\n    \n    }\n};\n\n\n",
        "url": "/2020/12/27/392-Is-Subsequence/"
      },
    
      {
        "title": "Longest Harmonious Subsequence",
        "excerpt": "&lt;-E 594&gt; Longest Harmonious Subsequence\n\n// Method 1\nclass Solution {\npublic:\n    int findLHS(vector&lt;int&gt;&amp; nums) {\n       unordered_map&lt;int,int&gt; m;\n\t\tint ans = 0;\n\t\tfor(auto x : nums){\n\t\t\tm[x]++;\n\t\t\tif(m.count(x+1))\n\t\t\t\tans = max(ans, m[x] + m[x+1]);\n\t\t\tif(m.count(x-1))\n\t\t\t\tans = max(ans, m[x] + m[x-1]);\n\t\t}\n\t\treturn ans; \n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int findLHS(vector&lt;int&gt;&amp; nums) {\n        int res = 0;\n        sort(nums.begin(), nums.end());\n        for(int i = 1, start = 0, newStart = 0; i &lt; nums.size(); i++) {\n            if(nums[i] - nums[start] &gt; 1) {\n                start = newStart;\n            }\n            if(nums[i] != nums[i - 1]) {\n                newStart = i;\n            }\n            if(nums[i] - nums[start] == 1) {\n                res = max(res, i - start + 1);\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 594&gt; Longest Harmonious Subsequence\n\n// Method 1\nclass Solution {\npublic:\n    int findLHS(vector&lt;int&gt;&amp; nums) {\n       unordered_map&lt;int,int&gt; m;\n\t\tint ans = 0;\n\t\tfor(auto x : nums){\n\t\t\tm[x]++;\n\t\t\tif(m.count(x+1))\n\t\t\t\tans = max(ans, m[x] + m[x+1]);\n\t\t\tif(m.count(x-1))\n\t\t\t\tans = max(ans, m[x] + m[x-1]);\n\t\t}\n\t\treturn ans; \n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int findLHS(vector&lt;int&gt;&amp; nums) {\n        int res = 0;\n        sort(nums.begin(), nums.end());\n        for(int i = 1, start = 0, newStart = 0; i &lt; nums.size(); i++) {\n            if(nums[i] - nums[start] &gt; 1) {\n                start = newStart;\n            }\n            if(nums[i] != nums[i - 1]) {\n                newStart = i;\n            }\n            if(nums[i] - nums[start] == 1) {\n                res = max(res, i - start + 1);\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/27/594-Longest-Harmonious-Subsequence/"
      },
    
      {
        "title": "Image Smoother",
        "excerpt": "&lt;-E 661&gt; Image Smoother\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; M) {\n       \n        vector&lt;int&gt; d{-1, 0, 1};\n        vector&lt;vector&lt;int&gt;&gt; res(M.size(), vector&lt;int&gt;(M[0].size(), 0));\n        for(int i = 0; i &lt; M.size(); ++i) {\n            for(int j = 0; j &lt; M[0].size(); ++j) {\n                int sum = 0, count = 0;\n                for(int k = 0; k &lt; 3; ++k) {\n                    for(int l = 0; l &lt; 3; ++l) {\n                        int m = i + d[k], n = j+d[l];\n                        if(m &gt;= 0 &amp;&amp; m &lt; M.size() &amp;&amp; n &gt;= 0 &amp;&amp; n &lt; M[0].size()) {\n                            ++count; \n                            sum += M[m][n];\n                        }\n                    }\n                }\n                res[i][j] = sum/count;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 661&gt; Image Smoother\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; M) {\n       \n        vector&lt;int&gt; d{-1, 0, 1};\n        vector&lt;vector&lt;int&gt;&gt; res(M.size(), vector&lt;int&gt;(M[0].size(), 0));\n        for(int i = 0; i &lt; M.size(); ++i) {\n            for(int j = 0; j &lt; M[0].size(); ++j) {\n                int sum = 0, count = 0;\n                for(int k = 0; k &lt; 3; ++k) {\n                    for(int l = 0; l &lt; 3; ++l) {\n                        int m = i + d[k], n = j+d[l];\n                        if(m &gt;= 0 &amp;&amp; m &lt; M.size() &amp;&amp; n &gt;= 0 &amp;&amp; n &lt; M[0].size()) {\n                            ++count; \n                            sum += M[m][n];\n                        }\n                    }\n                }\n                res[i][j] = sum/count;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/27/661-Image-Smoother/"
      },
    
      {
        "title": "1-bit and 2-bit Characters",
        "excerpt": "&lt;-E 717&gt; 1-bit and 2-bit Characters\n\nclass Solution {\npublic:\n    bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) {\n        int i = 0;\n        while (i &lt; bits.size() - 1) {\n            i += bits[i] + 1;\n        }\n        return i == bits.size() - 1;\n    }\n};\n\n\n",
        "content": "&lt;-E 717&gt; 1-bit and 2-bit Characters\n\nclass Solution {\npublic:\n    bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) {\n        int i = 0;\n        while (i &lt; bits.size() - 1) {\n            i += bits[i] + 1;\n        }\n        return i == bits.size() - 1;\n    }\n};\n\n\n",
        "url": "/2020/12/27/717-1-bit-and-2-bit-Characters/"
      },
    
      {
        "title": "Cousins in Binary Tree",
        "excerpt": "&lt;-E 993&gt; Cousins in Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    std::map&lt;int, std::pair&lt;int, int&gt;&gt; map{};\n    \npublic:\n    void preOrder(TreeNode* node, int depth, int parent) {\n        if (node == nullptr) {\n            return;\n        }\n        \n        map[node-&gt;val] = std::make_pair(depth, parent);\n        parent = node-&gt;val;\n        \n        depth++;\n        \n        preOrder(node-&gt;left, depth, parent);\n        preOrder(node-&gt;right, depth, parent);\n        \n        depth--;\n    }\n    \n    bool isCousins(TreeNode* root, int x, int y) {\n        preOrder(root, 0, -1);\n            \n        const auto [depth_x, parent_x] = map[x];\n        const auto [depth_y, parent_y] = map[y];\n        \n        return depth_x == depth_y &amp;&amp; parent_x != parent_y;\n    }\n};\n\n\n",
        "content": "&lt;-E 993&gt; Cousins in Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    std::map&lt;int, std::pair&lt;int, int&gt;&gt; map{};\n    \npublic:\n    void preOrder(TreeNode* node, int depth, int parent) {\n        if (node == nullptr) {\n            return;\n        }\n        \n        map[node-&gt;val] = std::make_pair(depth, parent);\n        parent = node-&gt;val;\n        \n        depth++;\n        \n        preOrder(node-&gt;left, depth, parent);\n        preOrder(node-&gt;right, depth, parent);\n        \n        depth--;\n    }\n    \n    bool isCousins(TreeNode* root, int x, int y) {\n        preOrder(root, 0, -1);\n            \n        const auto [depth_x, parent_x] = map[x];\n        const auto [depth_y, parent_y] = map[y];\n        \n        return depth_x == depth_y &amp;&amp; parent_x != parent_y;\n    }\n};\n\n\n",
        "url": "/2020/12/27/993-Cousins-in-Binary-Tree/"
      },
    
      {
        "title": "Partition Array Into Three Parts With Equal Sum",
        "excerpt": "&lt;-E 1013&gt; Partition Array Into Three Parts With Equal Sum\n\nclass Solution {\npublic:\n    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; A) {\n      int target = accumulate(A.begin(), A.end(), 0);\n\t\tif(target % 3 != 0) \n            return false;\n        int cur = 0, count = 0;\n        target /= 3;\n        for(int n : A) {\n            cur += n;\n            if(cur == target) {\n                count++;\n                cur = 0;\n            }\n                \n        }\n        return count &gt;= 3 ? true : false;  \n    }\n};\n\n\n",
        "content": "&lt;-E 1013&gt; Partition Array Into Three Parts With Equal Sum\n\nclass Solution {\npublic:\n    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; A) {\n      int target = accumulate(A.begin(), A.end(), 0);\n\t\tif(target % 3 != 0) \n            return false;\n        int cur = 0, count = 0;\n        target /= 3;\n        for(int n : A) {\n            cur += n;\n            if(cur == target) {\n                count++;\n                cur = 0;\n            }\n                \n        }\n        return count &gt;= 3 ? true : false;  \n    }\n};\n\n\n",
        "url": "/2020/12/28/1013.-Partition-Array-Into-Three-Parts-With-Equal-Sum/"
      },
    
      {
        "title": "Greatest Common Divisor of Strings",
        "excerpt": "&lt;-E 1071&gt; Greatest Common Divisor of Strings\n\n// Method 1\nclass Solution {\npublic:\n   string gcdOfStrings(string s1, string s2) \n    {\n\t    return s1+s2==s2+s1 ? s1.substr(0, gcd(size(s1), size(s2))) : \"\";\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\nstring gcdOfStrings(string s1, string s2)  {\n    if(size(s1)&lt;size(s2)) swap(s1, s2);    \n    return s1==s2 ? s1 : \n                        s1.substr(0, size(s2)) != s2 ? \"\" :\n                        gcdOfStrings(s1.substr(size(s2)), s2);\n    }\n};\n\n\n",
        "content": "&lt;-E 1071&gt; Greatest Common Divisor of Strings\n\n// Method 1\nclass Solution {\npublic:\n   string gcdOfStrings(string s1, string s2) \n    {\n\t    return s1+s2==s2+s1 ? s1.substr(0, gcd(size(s1), size(s2))) : \"\";\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\nstring gcdOfStrings(string s1, string s2)  {\n    if(size(s1)&lt;size(s2)) swap(s1, s2);    \n    return s1==s2 ? s1 : \n                        s1.substr(0, size(s2)) != s2 ? \"\" :\n                        gcdOfStrings(s1.substr(size(s2)), s2);\n    }\n};\n\n\n",
        "url": "/2020/12/28/1071-Greatest-Common-Divisor-of-Strings/"
      },
    
      {
        "title": "Prime Arrangements",
        "excerpt": "&lt;-E 1175&gt; Prime Arrangements\n\nclass Solution {\npublic:\n    int numPrimeArrangements(int n) {\n        int m = 1e9 + 7, pr = 0, npr = 1;\n        long res = 1;\n        for (int i = 2; i &lt;= n; ++i) {\n            bool fg = true;\n            for (int j = 2; j * j &lt;= i; ++j) {\n\t\t\t\tif (i % j == 0) {\n                    fg = false;\n                    break;\n                }\n            }\n\t\t\t\n            if (fg)\n                res = (res * ++pr) % m;\n            else\n                res = (res * ++npr) % m;\n        }\n        \n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 1175&gt; Prime Arrangements\n\nclass Solution {\npublic:\n    int numPrimeArrangements(int n) {\n        int m = 1e9 + 7, pr = 0, npr = 1;\n        long res = 1;\n        for (int i = 2; i &lt;= n; ++i) {\n            bool fg = true;\n            for (int j = 2; j * j &lt;= i; ++j) {\n\t\t\t\tif (i % j == 0) {\n                    fg = false;\n                    break;\n                }\n            }\n\t\t\t\n            if (fg)\n                res = (res * ++pr) % m;\n            else\n                res = (res * ++npr) % m;\n        }\n        \n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/28/1175-Prime-Arrangements/"
      },
    
      {
        "title": "Implement Queue using Stacks",
        "excerpt": "&lt;-E 232&gt; Implement Queue using Stacks\n\nclass MyQueue {\n\n    void populate_s2(){\n        while(!s1.empty()){\n           s2.push(s1.top());\n           s1.pop();\n        }\n    }\npublic:\n    stack&lt;int&gt; s1;\n    stack&lt;int&gt; s2;\n   \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if(s2.empty())\n           populate_s2();\n\n        int x = s2.top();\n        s2.pop();\n        return x;\n    }\n    \n    int peek() {\n        if(s2.empty())\n            populate_s2();\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() &amp;&amp; s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;peek();\n * bool param_4 = obj-&gt;empty();\n */\n\n\n",
        "content": "&lt;-E 232&gt; Implement Queue using Stacks\n\nclass MyQueue {\n\n    void populate_s2(){\n        while(!s1.empty()){\n           s2.push(s1.top());\n           s1.pop();\n        }\n    }\npublic:\n    stack&lt;int&gt; s1;\n    stack&lt;int&gt; s2;\n   \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if(s2.empty())\n           populate_s2();\n\n        int x = s2.top();\n        s2.pop();\n        return x;\n    }\n    \n    int peek() {\n        if(s2.empty())\n            populate_s2();\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() &amp;&amp; s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;peek();\n * bool param_4 = obj-&gt;empty();\n */\n\n\n",
        "url": "/2020/12/28/232-Implement-Queue-using-Stacks/"
      },
    
      {
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "excerpt": "&lt;-E 235&gt; Lowest Common Ancestor of a Binary Search Tree\n\n// Method 1\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)\n            return lowestCommonAncestor(root-&gt;left,p,q);\n        \n        if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)\n            return lowestCommonAncestor(root-&gt;right,p,q);\n        \n        return root;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    // ITERATIVE\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        TreeNode* curr = root;\n        while(curr)\n        {\n            // same branch but need to traverse\n            if (p-&gt;val &lt; curr-&gt;val and q-&gt;val &lt; curr-&gt;val) // traverse left subtree\n            {\n                curr = curr-&gt;left;\n            } else if(p-&gt;val &gt; curr-&gt;val and q-&gt;val &gt; curr-&gt;val) // traverse right subtree\n            {\n                curr = curr-&gt;right;\n            } else { // found root that's equal to p/q OR found a fork so LCA\n                return curr;\n            }\n        }\n        return nullptr;\n    }\n};\n\n\n",
        "content": "&lt;-E 235&gt; Lowest Common Ancestor of a Binary Search Tree\n\n// Method 1\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)\n            return lowestCommonAncestor(root-&gt;left,p,q);\n        \n        if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)\n            return lowestCommonAncestor(root-&gt;right,p,q);\n        \n        return root;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    // ITERATIVE\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        TreeNode* curr = root;\n        while(curr)\n        {\n            // same branch but need to traverse\n            if (p-&gt;val &lt; curr-&gt;val and q-&gt;val &lt; curr-&gt;val) // traverse left subtree\n            {\n                curr = curr-&gt;left;\n            } else if(p-&gt;val &gt; curr-&gt;val and q-&gt;val &gt; curr-&gt;val) // traverse right subtree\n            {\n                curr = curr-&gt;right;\n            } else { // found root that's equal to p/q OR found a fork so LCA\n                return curr;\n            }\n        }\n        return nullptr;\n    }\n};\n\n\n",
        "url": "/2020/12/28/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"
      },
    
      {
        "title": "Diameter of Binary Tree",
        "excerpt": "&lt;-E 543&gt; Diameter of Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root, int &amp;ans) {\n        if(root == NULL)\n            return 0;\n        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\n            return 1;\n        int x, y;\n        x = maxDepth(root-&gt;left, ans);\n        y = maxDepth(root-&gt;right, ans);\n        ans = max(ans, x + y);\n        return 1 + max(x, y); \n    }\n    \n    int diameterOfBinaryTree(TreeNode* root) {\n        int ans = 0;\n        maxDepth(root, ans);\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 543&gt; Diameter of Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root, int &amp;ans) {\n        if(root == NULL)\n            return 0;\n        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\n            return 1;\n        int x, y;\n        x = maxDepth(root-&gt;left, ans);\n        y = maxDepth(root-&gt;right, ans);\n        ans = max(ans, x + y);\n        return 1 + max(x, y); \n    }\n    \n    int diameterOfBinaryTree(TreeNode* root) {\n        int ans = 0;\n        maxDepth(root, ans);\n        return ans;\n    }\n};\n\n\n",
        "url": "/2020/12/28/543-Diameter-of-Binary-Tree/"
      },
    
      {
        "title": "Range Addition II",
        "excerpt": "&lt;-E 598&gt; Range Addition II\n\nclass Solution {\npublic:\n    int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) {\n        if(ops.size() == 0) return m * n;\n\n\t\tint x = INT_MAX, y = INT_MAX;\n\n\t\tfor(int i = 0; i &lt; ops.size(); i++){\n\t\t\tx = min(x, ops[i][0]);\n\t\t\ty = min(y, ops[i][1]);\n\t\t}\n\n\t\treturn x*y;\n    }\n};\n\n\n",
        "content": "&lt;-E 598&gt; Range Addition II\n\nclass Solution {\npublic:\n    int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) {\n        if(ops.size() == 0) return m * n;\n\n\t\tint x = INT_MAX, y = INT_MAX;\n\n\t\tfor(int i = 0; i &lt; ops.size(); i++){\n\t\t\tx = min(x, ops[i][0]);\n\t\t\ty = min(y, ops[i][1]);\n\t\t}\n\n\t\treturn x*y;\n    }\n};\n\n\n",
        "url": "/2020/12/28/598-Range-Addition-II/"
      },
    
      {
        "title": "Kth Largest Element in a Stream",
        "excerpt": "&lt;-E 703&gt; Kth Largest Element in a Stream\n\nclass KthLargest {\npublic:\n    int k;\n    priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt; minHeap;\n\n    KthLargest(int k, vector&lt;int&gt;&amp; nums) {\n        this-&gt;k = k;  \n        for(int i: nums)\n        {\n            minHeap.push(i);\n            if(minHeap.size() &gt; k)\n                minHeap.pop();\n        }\n        \n    }\n    \n    int add(int val) { \n      \n        if(minHeap.size() &lt; k || val &gt; minHeap.top())\n            minHeap.push(val);\n        if(minHeap.size() &gt; k)\n            minHeap.pop();\n        return minHeap.top();\n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj-&gt;add(val);\n */\n\n\n",
        "content": "&lt;-E 703&gt; Kth Largest Element in a Stream\n\nclass KthLargest {\npublic:\n    int k;\n    priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt; minHeap;\n\n    KthLargest(int k, vector&lt;int&gt;&amp; nums) {\n        this-&gt;k = k;  \n        for(int i: nums)\n        {\n            minHeap.push(i);\n            if(minHeap.size() &gt; k)\n                minHeap.pop();\n        }\n        \n    }\n    \n    int add(int val) { \n      \n        if(minHeap.size() &lt; k || val &gt; minHeap.top())\n            minHeap.push(val);\n        if(minHeap.size() &gt; k)\n            minHeap.pop();\n        return minHeap.top();\n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj-&gt;add(val);\n */\n\n\n",
        "url": "/2020/12/28/703-Kth-Largest-Element-in-a-Stream/"
      },
    
      {
        "title": "Longest Word in Dictionary",
        "excerpt": "&lt;-E 720&gt; Longest Word in Dictionary\n\nclass Solution {\nprivate:\n    struct TrieNode {\n        TrieNode *children[26];\n        bool isEndOfWord = false;\n    };\n    \npublic:\n    static bool compare(string &amp;a, string &amp;b){\n        return a.size() &lt; b.size();\n    }\n    \n    void TrieInsert(TrieNode *root, int idx, string &amp;word, bool canBeBuilt, string &amp;res){\n        if(idx == word.size()){\n            root-&gt;isEndOfWord = true;\n            if(canBeBuilt){\n                if(res.size()==word.size()){\n                    res = (res&lt;word) ? res : word;\n                } else if (res.size()&lt;word.size()){\n                    res = word;\n                } \n            }\n            return;\n        }\n        \n        if(root-&gt;children[word[idx]-'a'] == NULL){\n            root-&gt;children[word[idx]-'a'] = new TrieNode();\n        }\n        \n        if(idx &lt; word.size()-1){\n            canBeBuilt  &amp;= root-&gt;children[word[idx]-'a']-&gt;isEndOfWord;\n        }\n        \n        TrieInsert(root-&gt;children[word[idx]-'a'], idx+1, word, canBeBuilt, res);\n    }\n    \n    string longestWord(vector&lt;string&gt;&amp; words) {\n        if(words.empty()){\n            return \"\";\n        }\n        sort(words.begin(), words.end(), compare);\n        \n        TrieNode *root = new TrieNode();\n        int i;\n        string res = \"\";\n        for(i=0; i&lt;words.size(); i++){\n            TrieInsert(root, 0, words[i], true, res);\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 720&gt; Longest Word in Dictionary\n\nclass Solution {\nprivate:\n    struct TrieNode {\n        TrieNode *children[26];\n        bool isEndOfWord = false;\n    };\n    \npublic:\n    static bool compare(string &amp;a, string &amp;b){\n        return a.size() &lt; b.size();\n    }\n    \n    void TrieInsert(TrieNode *root, int idx, string &amp;word, bool canBeBuilt, string &amp;res){\n        if(idx == word.size()){\n            root-&gt;isEndOfWord = true;\n            if(canBeBuilt){\n                if(res.size()==word.size()){\n                    res = (res&lt;word) ? res : word;\n                } else if (res.size()&lt;word.size()){\n                    res = word;\n                } \n            }\n            return;\n        }\n        \n        if(root-&gt;children[word[idx]-'a'] == NULL){\n            root-&gt;children[word[idx]-'a'] = new TrieNode();\n        }\n        \n        if(idx &lt; word.size()-1){\n            canBeBuilt  &amp;= root-&gt;children[word[idx]-'a']-&gt;isEndOfWord;\n        }\n        \n        TrieInsert(root-&gt;children[word[idx]-'a'], idx+1, word, canBeBuilt, res);\n    }\n    \n    string longestWord(vector&lt;string&gt;&amp; words) {\n        if(words.empty()){\n            return \"\";\n        }\n        sort(words.begin(), words.end(), compare);\n        \n        TrieNode *root = new TrieNode();\n        int i;\n        string res = \"\";\n        for(i=0; i&lt;words.size(); i++){\n            TrieInsert(root, 0, words[i], true, res);\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/28/720-Longest-Word-in-Dictionary/"
      },
    
      {
        "title": "Min Cost Climbing Stairs",
        "excerpt": "&lt;-E 746&gt; Min Cost Climbing Stairs\n\n// Method 1\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {\n        vector&lt;int&gt; memo(cost.size());\n        for (int i = 0; i &lt; cost.size(); ++i) {\n            if (i == 0 || i == 1)\n                memo[i] = cost[i];\n            else\n                memo[i] = min(memo[i - 1], memo[i - 2]) + cost[i];\n        }\n        return min(memo.back(), memo[memo.size() - 2]);\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {\n        int cost1 = 0;\n        int cost2 = 0;\n        for(int i = cost.size() - 1; i&gt;=0; i--) {\n            int cost3 = cost[i] + min(cost1, cost2);\n            cost2 = cost1;\n            cost1 = cost3;\n        }\n        return min(cost1,cost2);\n    }\n    int min(int a, int b) {\n        return a &lt; b? a : b;\n    }\n};\n\n\n",
        "content": "&lt;-E 746&gt; Min Cost Climbing Stairs\n\n// Method 1\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {\n        vector&lt;int&gt; memo(cost.size());\n        for (int i = 0; i &lt; cost.size(); ++i) {\n            if (i == 0 || i == 1)\n                memo[i] = cost[i];\n            else\n                memo[i] = min(memo[i - 1], memo[i - 2]) + cost[i];\n        }\n        return min(memo.back(), memo[memo.size() - 2]);\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {\n        int cost1 = 0;\n        int cost2 = 0;\n        for(int i = cost.size() - 1; i&gt;=0; i--) {\n            int cost3 = cost[i] + min(cost1, cost2);\n            cost2 = cost1;\n            cost1 = cost3;\n        }\n        return min(cost1,cost2);\n    }\n    int min(int a, int b) {\n        return a &lt; b? a : b;\n    }\n};\n\n\n",
        "url": "/2020/12/28/746-Min-Cost-Climbing-Stairs/"
      },
    
      {
        "title": "Positions of Large Groups",
        "excerpt": "&lt;-E 830&gt; Positions of Large Groups\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string s) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int start = 0;\n        for (int i = 0; i &lt;= s.size(); i++) {\n            if (s[start] != s[i]){\n                if (i - start &gt;= 3) res.push_back({start , (i - 1) });\n                start = i;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 830&gt; Positions of Large Groups\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string s) {\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int start = 0;\n        for (int i = 0; i &lt;= s.size(); i++) {\n            if (s[start] != s[i]){\n                if (i - start &gt;= 3) res.push_back({start , (i - 1) });\n                start = i;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2020/12/28/830-Positions-of-Large-Groups/"
      },
    
      {
        "title": "Lemonade Change",
        "excerpt": "&lt;-E 860&gt; Lemonade Change\n\nclass Solution {\n  \npublic:\n    bool lemonadeChange(vector&lt;int&gt;&amp; bills) {\n      int five = 0, ten = 0;\n      for (int &amp;i : bills) {\n          if (i == 5) five++;\n          else if (i == 10) five--, ten++;\n          else if (ten &gt; 0) ten--, five--;\n          else five -= 3;\n          if (five &lt; 0) return false;\n      }\n      return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 860&gt; Lemonade Change\n\nclass Solution {\n  \npublic:\n    bool lemonadeChange(vector&lt;int&gt;&amp; bills) {\n      int five = 0, ten = 0;\n      for (int &amp;i : bills) {\n          if (i == 5) five++;\n          else if (i == 10) five--, ten++;\n          else if (ten &gt; 0) ten--, five--;\n          else five -= 3;\n          if (five &lt; 0) return false;\n      }\n      return true;\n    }\n};\n\n\n",
        "url": "/2020/12/28/860-Lemonade-Change/"
      },
    
      {
        "title": "Find the Town Judge",
        "excerpt": "&lt;-E 997&gt; Find the Town Judge\n\nclass Solution {\npublic:\n    int findJudge(int N, vector&lt;vector&lt;int&gt;&gt;&amp; trust) {\n        if (N == 1) return 1;\n\t\n        vector&lt;int&gt; visitCount(N + 1,0);\n        for (int i = 0; i&lt; trust.size(); i++){\n            visitCount[trust[i][1]]++;\n            visitCount[trust[i][0]]--;\n        }\n\n        for (int i = 0; i &lt; visitCount.size(); i++){\n            if ((N - 1) == visitCount[i]){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n",
        "content": "&lt;-E 997&gt; Find the Town Judge\n\nclass Solution {\npublic:\n    int findJudge(int N, vector&lt;vector&lt;int&gt;&gt;&amp; trust) {\n        if (N == 1) return 1;\n\t\n        vector&lt;int&gt; visitCount(N + 1,0);\n        for (int i = 0; i&lt; trust.size(); i++){\n            visitCount[trust[i][1]]++;\n            visitCount[trust[i][0]]--;\n        }\n\n        for (int i = 0; i &lt; visitCount.size(); i++){\n            if ((N - 1) == visitCount[i]){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n",
        "url": "/2020/12/28/997-Find-the-Town-Judge/"
      },
    
      {
        "title": "Path Sum",
        "excerpt": "&lt;-E 112&gt; Path Sum\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum){\n        if (!root)\n            return false;\n        \n        sum -= root-&gt;val;\n        \n        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0)\n            return true;  \n        return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);\n    }\n};\n\n",
        "content": "&lt;-E 112&gt; Path Sum\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum){\n        if (!root)\n            return false;\n        \n        sum -= root-&gt;val;\n        \n        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0)\n            return true;  \n        return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);\n    }\n};\n\n",
        "url": "/2020/12/30/112-Path-Sum/"
      },
    
      {
        "title": "Number of Equivalent Domino Pairs",
        "excerpt": "&lt;-E 1128&gt; Number of Equivalent Domino Pairs\n\n// Method 1\nclass Solution {\npublic:\n    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) {\n        for (auto &amp;p: dominoes) {\n            if (p[0]&lt;=p[1]) {continue;}\n            swap(p[0], p[1]);\n        }   \n        map&lt;vector&lt;int&gt;, int&gt; A;\n        for (auto &amp;p: dominoes) {++A[p];}\n        int res=0;\n        for (auto &amp;p: A) {\n            res += p.second*(p.second -1)/2;\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) {\n        \n        int output = 0;\n        unordered_map&lt;int, int&gt; table;\n        \n        for (int i=0; i&lt;dominoes.size(); i++) {\n            int key;\n            if (dominoes[i][0] &lt; dominoes[i][1]) {\n                key = dominoes[i][0]*10 + dominoes[i][1];\n            }\n            else {\n                key = dominoes[i][1]*10 + dominoes[i][0];\n            }\n            table[key]++;\n        }\n        \n        for (auto&amp; item : table) {\n            if (item.second &gt; 1) {\n                output += item.second * (item.second-1) / 2;\n            }\n        }\n        return output;\n    }\n};\n\n\n",
        "content": "&lt;-E 1128&gt; Number of Equivalent Domino Pairs\n\n// Method 1\nclass Solution {\npublic:\n    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) {\n        for (auto &amp;p: dominoes) {\n            if (p[0]&lt;=p[1]) {continue;}\n            swap(p[0], p[1]);\n        }   \n        map&lt;vector&lt;int&gt;, int&gt; A;\n        for (auto &amp;p: dominoes) {++A[p];}\n        int res=0;\n        for (auto &amp;p: A) {\n            res += p.second*(p.second -1)/2;\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) {\n        \n        int output = 0;\n        unordered_map&lt;int, int&gt; table;\n        \n        for (int i=0; i&lt;dominoes.size(); i++) {\n            int key;\n            if (dominoes[i][0] &lt; dominoes[i][1]) {\n                key = dominoes[i][0]*10 + dominoes[i][1];\n            }\n            else {\n                key = dominoes[i][1]*10 + dominoes[i][0];\n            }\n            table[key]++;\n        }\n        \n        for (auto&amp; item : table) {\n            if (item.second &gt; 1) {\n                output += item.second * (item.second-1) / 2;\n            }\n        }\n        return output;\n    }\n};\n\n\n",
        "url": "/2020/12/30/1128-Number-of-Equivalent-Domino-Pairs/"
      },
    
      {
        "title": "Power of Three",
        "excerpt": "&lt;-E 326&gt; Power of Three\n\n// Method 1\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if (n==0)\n            return false;\n        while (n % 3 == 0) {\n            n = n / 3;\n        }\n        return n == 1;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if(n == 0) return false;\n        \n        double x = log10(n) / log10(3.0);\n        \n        return ceil(x) == floor(x);\n    }\n};\n\n\n",
        "content": "&lt;-E 326&gt; Power of Three\n\n// Method 1\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if (n==0)\n            return false;\n        while (n % 3 == 0) {\n            n = n / 3;\n        }\n        return n == 1;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if(n == 0) return false;\n        \n        double x = log10(n) / log10(3.0);\n        \n        return ceil(x) == floor(x);\n    }\n};\n\n\n",
        "url": "/2020/12/30/1326-Power-of-Three/"
      },
    
      {
        "title": "Get Maximum in Generated Array",
        "excerpt": "&lt;-E 1646&gt; Get Maximum in Generated Array\n\nclass Solution {\npublic:\n    int getMaximumGenerated(int n) {\n        if (n &lt;= 1)\n\t\treturn n;\n        int maxGen = 0;\n        vector&lt;int&gt; vGen(n + 1, 0);\n        vGen[1] = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            if (i % 2 == 0)\n                vGen[i] = vGen[i / 2];\n            else\n                vGen[i] = vGen[(i - 1) / 2] + vGen[(i - 1) / 2 + 1];\n\n            maxGen = max(maxGen, vGen[i]);\n        }\n        return maxGen;\n    }\n};\n\n\n",
        "content": "&lt;-E 1646&gt; Get Maximum in Generated Array\n\nclass Solution {\npublic:\n    int getMaximumGenerated(int n) {\n        if (n &lt;= 1)\n\t\treturn n;\n        int maxGen = 0;\n        vector&lt;int&gt; vGen(n + 1, 0);\n        vGen[1] = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            if (i % 2 == 0)\n                vGen[i] = vGen[i / 2];\n            else\n                vGen[i] = vGen[(i - 1) / 2] + vGen[(i - 1) / 2 + 1];\n\n            maxGen = max(maxGen, vGen[i]);\n        }\n        return maxGen;\n    }\n};\n\n\n",
        "url": "/2020/12/30/1646-Get-Maximum-in-Generated-Array/"
      },
    
      {
        "title": "Implement Stack using Queues",
        "excerpt": "&lt;-E 225&gt; Implement Stack using Queues\n\nclass MyStack {\npublic:\n    queue&lt;int&gt; q1;\n    /** Initialize your data structure here. */\n    MyStack() {\n        \n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        queue&lt;int&gt; q2;\n        int n = q1.size();\n        for (int i=0; i&lt;n; ++i) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        q1.push(x);\n        for (int i=0; i&lt;n; ++i) {\n            q1.push(q2.front());\n            q2.pop();\n        }\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        auto temp = q1.front();\n        q1.pop();\n        return temp;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        return q1.front();\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q1.size()==0;\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * bool param_4 = obj-&gt;empty();\n */\n\n\n",
        "content": "&lt;-E 225&gt; Implement Stack using Queues\n\nclass MyStack {\npublic:\n    queue&lt;int&gt; q1;\n    /** Initialize your data structure here. */\n    MyStack() {\n        \n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        queue&lt;int&gt; q2;\n        int n = q1.size();\n        for (int i=0; i&lt;n; ++i) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        q1.push(x);\n        for (int i=0; i&lt;n; ++i) {\n            q1.push(q2.front());\n            q2.pop();\n        }\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        auto temp = q1.front();\n        q1.pop();\n        return temp;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        return q1.front();\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q1.size()==0;\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj-&gt;push(x);\n * int param_2 = obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * bool param_4 = obj-&gt;empty();\n */\n\n\n",
        "url": "/2020/12/30/225-Implement-Stack-using-Queues/"
      },
    
      {
        "title": "Range Sum Query - Immutable",
        "excerpt": "&lt;-E 303&gt; Range Sum Query - Immutable\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * int param_1 = obj-&gt;sumRange(i,j);\n */\n\nclass NumArray {\nprivate:\n      vector&lt;int&gt; num;\npublic:\n  \n    NumArray(vector&lt;int&gt;&amp; nums) {\n    num=nums;\n    for(int i=1;i&lt;nums.size();i++)\n        num[i]+=num[i-1];\n    }\n    \n    int sumRange(int i, int j) {\n        if(i==0)\n            return num[j];\n      \n        return num[j]-num[i-1];\n    }\n};\n\n\n\n",
        "content": "&lt;-E 303&gt; Range Sum Query - Immutable\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * int param_1 = obj-&gt;sumRange(i,j);\n */\n\nclass NumArray {\nprivate:\n      vector&lt;int&gt; num;\npublic:\n  \n    NumArray(vector&lt;int&gt;&amp; nums) {\n    num=nums;\n    for(int i=1;i&lt;nums.size();i++)\n        num[i]+=num[i-1];\n    }\n    \n    int sumRange(int i, int j) {\n        if(i==0)\n            return num[j];\n      \n        return num[j]-num[i-1];\n    }\n};\n\n\n\n",
        "url": "/2020/12/30/303-Range-Sum-Query-Immutable/"
      },
    
      {
        "title": "Binary Watch",
        "excerpt": "&lt;-E 401&gt; Binary Watch\n\nclass Solution {\npublic:\n    int numbits(int x) {\n        int cnt = 0;\n        while(x) {\n            x &amp;= x - 1;\n            cnt++;\n        }\n        return cnt;\n    }\n    \n    vector&lt;string&gt; readBinaryWatch(int num) {\n        \n        vector&lt;string&gt; res;\n        const int upper_limit = (1&lt;&lt;10);\n        \n        for(int i = 0;i&lt; upper_limit;i++) {\n            if(numbits(i) != num) continue;\n            int hrs = i &gt;&gt; 6;\n            int mn = i % (1 &lt;&lt; 6);\n            if(hrs &lt; 12 &amp;&amp; mn &lt; 60) {\n                string time = to_string(hrs) + \":\" + \n                    (mn &lt; 10 ? \"0\" : \"\") + to_string(mn);\n                res.push_back(time);\n            }\n        }\n        return res;\n        \n    }\n};\n\n\n",
        "content": "&lt;-E 401&gt; Binary Watch\n\nclass Solution {\npublic:\n    int numbits(int x) {\n        int cnt = 0;\n        while(x) {\n            x &amp;= x - 1;\n            cnt++;\n        }\n        return cnt;\n    }\n    \n    vector&lt;string&gt; readBinaryWatch(int num) {\n        \n        vector&lt;string&gt; res;\n        const int upper_limit = (1&lt;&lt;10);\n        \n        for(int i = 0;i&lt; upper_limit;i++) {\n            if(numbits(i) != num) continue;\n            int hrs = i &gt;&gt; 6;\n            int mn = i % (1 &lt;&lt; 6);\n            if(hrs &lt; 12 &amp;&amp; mn &lt; 60) {\n                string time = to_string(hrs) + \":\" + \n                    (mn &lt; 10 ? \"0\" : \"\") + to_string(mn);\n                res.push_back(time);\n            }\n        }\n        return res;\n        \n    }\n};\n\n\n",
        "url": "/2020/12/30/401-Binary-Watch/"
      },
    
      {
        "title": "Subtree of Another Tree",
        "excerpt": "&lt;-E 572&gt; Subtree of Another Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* s, TreeNode* t) {\n        if (!s &amp;&amp; !t) \n            return true;\n        if (!s || !t) \n            return false;\n        \n        return (s-&gt;val == t-&gt;val) &amp;&amp; isSameTree(s-&gt;left, t-&gt;left) &amp;&amp; isSameTree(s-&gt;right, t-&gt;right);\n        \n    }\n    bool isSubtree(TreeNode* s, TreeNode* t) {\n        if (!s &amp;&amp; !t) \n            return true;\n        \n        if (!s || !t) \n            return false;\n        return isSameTree(s,t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);\n    }\n};\n\n\n",
        "content": "&lt;-E 572&gt; Subtree of Another Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* s, TreeNode* t) {\n        if (!s &amp;&amp; !t) \n            return true;\n        if (!s || !t) \n            return false;\n        \n        return (s-&gt;val == t-&gt;val) &amp;&amp; isSameTree(s-&gt;left, t-&gt;left) &amp;&amp; isSameTree(s-&gt;right, t-&gt;right);\n        \n    }\n    bool isSubtree(TreeNode* s, TreeNode* t) {\n        if (!s &amp;&amp; !t) \n            return true;\n        \n        if (!s || !t) \n            return false;\n        return isSameTree(s,t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);\n    }\n};\n\n\n",
        "url": "/2020/12/30/572-Subtree-of-Another-Tree/"
      },
    
      {
        "title": "Maximum Product of Three Numbers",
        "excerpt": "&lt;-E 628&gt; Maximum Product of Three Numbers\n\n// Method 1\nclass Solution {\npublic:\n    int maximumProduct(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(),nums.end());\n        return max((nums[0] * nums[1] * nums.back()),\n                   (nums.back() * nums[nums.size() - 2] * nums[nums.size() - 3]));\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int maximumProduct(vector&lt;int&gt;&amp; nums) {\n        int mx1 = INT_MIN, mx2 = INT_MIN, mx3 = INT_MIN;\n        int mn1 = INT_MAX, mn2 = INT_MAX;\n        for (int num : nums) {\n            if (num &gt; mx1) {\n                mx3 = mx2; mx2 = mx1; mx1 = num;\n            } else if (num &gt; mx2) {\n                mx3 = mx2; mx2 = num;\n            } else if (num &gt; mx3) {\n                mx3 = num;\n            }\n            \n            if (num &lt; mn1) {\n                mn2 = mn1; mn1 = num;\n            } else if (num &lt; mn2) {\n                mn2 = num;\n            }\n        }\n        return max(mx1 * mx2 * mx3, mx1 * mn1 * mn2);        \n    }\n};\n\n\n",
        "content": "&lt;-E 628&gt; Maximum Product of Three Numbers\n\n// Method 1\nclass Solution {\npublic:\n    int maximumProduct(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(),nums.end());\n        return max((nums[0] * nums[1] * nums.back()),\n                   (nums.back() * nums[nums.size() - 2] * nums[nums.size() - 3]));\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int maximumProduct(vector&lt;int&gt;&amp; nums) {\n        int mx1 = INT_MIN, mx2 = INT_MIN, mx3 = INT_MIN;\n        int mn1 = INT_MAX, mn2 = INT_MAX;\n        for (int num : nums) {\n            if (num &gt; mx1) {\n                mx3 = mx2; mx2 = mx1; mx1 = num;\n            } else if (num &gt; mx2) {\n                mx3 = mx2; mx2 = num;\n            } else if (num &gt; mx3) {\n                mx3 = num;\n            }\n            \n            if (num &lt; mn1) {\n                mn2 = mn1; mn1 = num;\n            } else if (num &lt; mn2) {\n                mn2 = num;\n            }\n        }\n        return max(mx1 * mx2 * mx3, mx1 * mn1 * mn2);        \n    }\n};\n\n\n",
        "url": "/2020/12/30/628-Maximum-Product-of-Three-Numbers/"
      },
    
      {
        "title": "Longest Continuous Increasing Subsequence",
        "excerpt": "&lt;-E 674&gt; Longest Continuous Increasing Subsequence\n\nclass Solution {\npublic:\n    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size(), result = 1, current = 1;\n        if(n == 0) \n            return 0;\n        for(int i = 1; i &lt; n; i++){\n            if(nums[i] &gt; nums[i-1]) \n                current++;\n            else \n                current = 1;\n            result = max(result, current);\n        }\n        return result; \n    }\n};\n\n\n",
        "content": "&lt;-E 674&gt; Longest Continuous Increasing Subsequence\n\nclass Solution {\npublic:\n    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size(), result = 1, current = 1;\n        if(n == 0) \n            return 0;\n        for(int i = 1; i &lt; n; i++){\n            if(nums[i] &gt; nums[i-1]) \n                current++;\n            else \n                current = 1;\n            result = max(result, current);\n        }\n        return result; \n    }\n};\n\n\n",
        "url": "/2020/12/30/674-Longest-Continuous-Increasing-Subsequence/"
      },
    
      {
        "title": "Find Pivot Index",
        "excerpt": "&lt;-E 724&gt; Find Pivot Index\n\nclass Solution {\npublic:\n    int pivotIndex(vector&lt;int&gt;&amp; nums) {\n        int sum = 0, cur = 0;\n        sum = accumulate(nums.begin(), nums.end(), 0);\n        for(int i = 0; i &lt; nums.size(); i++)\n            if(cur * 2 == sum - nums[i]) \n                return i;\n            else \n                cur += nums[i];\n        return -1;\n    }\n};\n\n\n",
        "content": "&lt;-E 724&gt; Find Pivot Index\n\nclass Solution {\npublic:\n    int pivotIndex(vector&lt;int&gt;&amp; nums) {\n        int sum = 0, cur = 0;\n        sum = accumulate(nums.begin(), nums.end(), 0);\n        for(int i = 0; i &lt; nums.size(); i++)\n            if(cur * 2 == sum - nums[i]) \n                return i;\n            else \n                cur += nums[i];\n        return -1;\n    }\n};\n\n\n",
        "url": "/2020/12/30/724-Find-Pivot-Index/"
      },
    
      {
        "title": "Find Smallest Letter Greater Than Target",
        "excerpt": "&lt;-E 744&gt; Find Smallest Letter Greater Than Target\n\nclass Solution {\npublic:\n    char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) {\n        char ans = 'z' + 1;\n        \n        for(auto i : letters) {\n            if(i &gt; target) {\n                if(ans &gt; i) {\n                    ans = i;\n                }\n            }\n        }\n        \n        return (ans == 'z' + 1) ? letters[0] : ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 744&gt; Find Smallest Letter Greater Than Target\n\nclass Solution {\npublic:\n    char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) {\n        char ans = 'z' + 1;\n        \n        for(auto i : letters) {\n            if(i &gt; target) {\n                if(ans &gt; i) {\n                    ans = i;\n                }\n            }\n        }\n        \n        return (ans == 'z' + 1) ? letters[0] : ans;\n    }\n};\n\n\n",
        "url": "/2020/12/30/744-Find-Smallest-Letter-Greater-Than-Target/"
      },
    
      {
        "title": "Most Common Word",
        "excerpt": "&lt;-E 819&gt; Most Common Word\n\n// Method 1\nclass Solution {\npublic:\n    string mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned) {\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\n        map&lt;string,int&gt;mp;\n        string s = \"\";\n        for(char c : paragraph) {\n            if(isalpha(c))\n                s += c;\n            else {\n                if(s.size() &gt; 0)\n                    mp[s]++;\n                s = \"\";\n            }\n        }\n        if(s.size() &gt; 0)\n            mp[s]++;\n        for(string s : banned){\n            if(mp.find(s) != mp.end())\n                mp[s] = 0;\n        \n        }\n        int max = 0;\n        string ans = \"\";\n        for (auto it : mp){\n            if(max &lt; it.second) {\n                max = it.second;\n                ans = it.first;\n            }\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned) {\n        for(int i = 0; i&lt; paragraph.length(); i++) {\n            char c = ispunct(paragraph[i]) ? ' ' : tolower(paragraph[i]);\n            paragraph[i] = c;\n        }\n        string str, res;\n        unordered_map&lt;string, int&gt; freq;\n        unordered_set&lt;string&gt; b;\n\n        for(int i = 0; i &lt; banned.size(); i++){\n         b.insert(banned[i]);\n        }\n\n        stringstream ss(paragraph);\n        int max = 0;\n        while(ss &gt;&gt; str) {\n            if(b.count(str) == 0){\n                if(freq.find(str) ==freq.end())\n                    freq[str]= 1;    \n                else\n                    freq[str]+= 1;\n                if(freq[str] &gt; max){ \n                    res = str;\n                    max = freq[str];\n                 }\n            }                \n        }\n        return res;\n    }\n};\n\n\n\n",
        "content": "&lt;-E 819&gt; Most Common Word\n\n// Method 1\nclass Solution {\npublic:\n    string mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned) {\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\n        map&lt;string,int&gt;mp;\n        string s = \"\";\n        for(char c : paragraph) {\n            if(isalpha(c))\n                s += c;\n            else {\n                if(s.size() &gt; 0)\n                    mp[s]++;\n                s = \"\";\n            }\n        }\n        if(s.size() &gt; 0)\n            mp[s]++;\n        for(string s : banned){\n            if(mp.find(s) != mp.end())\n                mp[s] = 0;\n        \n        }\n        int max = 0;\n        string ans = \"\";\n        for (auto it : mp){\n            if(max &lt; it.second) {\n                max = it.second;\n                ans = it.first;\n            }\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned) {\n        for(int i = 0; i&lt; paragraph.length(); i++) {\n            char c = ispunct(paragraph[i]) ? ' ' : tolower(paragraph[i]);\n            paragraph[i] = c;\n        }\n        string str, res;\n        unordered_map&lt;string, int&gt; freq;\n        unordered_set&lt;string&gt; b;\n\n        for(int i = 0; i &lt; banned.size(); i++){\n         b.insert(banned[i]);\n        }\n\n        stringstream ss(paragraph);\n        int max = 0;\n        while(ss &gt;&gt; str) {\n            if(b.count(str) == 0){\n                if(freq.find(str) ==freq.end())\n                    freq[str]= 1;    \n                else\n                    freq[str]+= 1;\n                if(freq[str] &gt; max){ \n                    res = str;\n                    max = freq[str];\n                 }\n            }                \n        }\n        return res;\n    }\n};\n\n\n\n",
        "url": "/2020/12/30/819-Most-Common-Word/"
      },
    
      {
        "title": "Rectangle Overlap",
        "excerpt": "&lt;-E 836&gt; Rectangle Overlap\n\nclass Solution {\npublic:\n    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) {\n        int max_start = max(rec1[0], rec2[0]);\n        int min_end = min(rec1[2], rec2[2]);\n        if (min_end - max_start &lt;= 0) \n            return false;\n\t\n        int min_start = min(rec1[3], rec2[3]);\n        int max_end = max(rec1[1],rec2[1]);\n        return min_start - max_end &gt;0;\n    }\n};\n\n\n",
        "content": "&lt;-E 836&gt; Rectangle Overlap\n\nclass Solution {\npublic:\n    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) {\n        int max_start = max(rec1[0], rec2[0]);\n        int min_end = min(rec1[2], rec2[2]);\n        if (min_end - max_start &lt;= 0) \n            return false;\n\t\n        int min_start = min(rec1[3], rec2[3]);\n        int max_end = max(rec1[1],rec2[1]);\n        return min_start - max_end &gt;0;\n    }\n};\n\n\n",
        "url": "/2020/12/30/836-Rectangle-Overlap/"
      },
    
      {
        "title": "Backspace String Compare",
        "excerpt": "&lt;-E 844&gt; Backspace String Compare\n\nclass Solution {\npublic:\n    bool backspaceCompare(string S, string T) {\n        stack&lt;char&gt; A, B;\n        for (auto &amp;p: S) {\n            if (p=='#') {\n                if (!A.empty()) {A.pop();}\n                continue;\n            }\n            A.push(p);\n        }\n        for (auto &amp;p: T) {\n            if (p=='#') {\n                if (!B.empty()) {B.pop();}\n                continue;\n            }\n            B.push(p);\n        }\n        \n        if (A.size() != B.size()) {return false;}\n        while (!A.empty()) {\n            if (A.top() != B.top()) {return false;}\n            A.pop(); B.pop();\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 844&gt; Backspace String Compare\n\nclass Solution {\npublic:\n    bool backspaceCompare(string S, string T) {\n        stack&lt;char&gt; A, B;\n        for (auto &amp;p: S) {\n            if (p=='#') {\n                if (!A.empty()) {A.pop();}\n                continue;\n            }\n            A.push(p);\n        }\n        for (auto &amp;p: T) {\n            if (p=='#') {\n                if (!B.empty()) {B.pop();}\n                continue;\n            }\n            B.push(p);\n        }\n        \n        if (A.size() != B.size()) {return false;}\n        while (!A.empty()) {\n            if (A.top() != B.top()) {return false;}\n            A.pop(); B.pop();\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2020/12/30/844-Backspace-String-Compare/"
      },
    
      {
        "title": "Add to Array-Form of Integer",
        "excerpt": "&lt;-E 989&gt; Add to Array-Form of Integer\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; A, int K) {\n        int pos = A.size()-1;\n        int carry = 0;\n        std::vector&lt;int&gt; ret;\n        while(K &gt; 0 || pos &gt;= 0 || carry &gt; 0){\n            int kdigit = K % 10;\n            K = K / 10;\n            int sum = kdigit + carry;\n            if(pos &gt;= 0) \n                sum += A[pos];\n            \n            if(sum &gt; 9){\n                carry = sum / 10;\n                sum = sum%10;\n            }else{\n                carry = 0;\n            }\n            ret.push_back(sum);\n            --pos;\n        }\n        reverse(ret.begin(),ret.end());\n        return ret;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; A, int K) {\n        int len_K = 0;\n        int len = A.size() - 1;\n        int carry_on = 0;\n        \n        while(K || carry_on){\n            int index = len - len_K; \n            \n            if(index &lt; 0){\n                int tmp = K % 10 + carry_on;\n                if(tmp &gt;= 10){\n                    carry_on = 1;\n                    tmp = tmp % 10;\n                }else{\n                    carry_on = 0;\n                }\n                A.insert(A.begin(), tmp);\n                K /= 10;\n                continue;\n            }\n            \n            int tmp = A[index] + (K % 10) + carry_on;\n            if(tmp &gt;= 10){\n                A[index] = tmp%10;\n                carry_on = 1;\n                \n            }else{\n                A[index] = tmp;\n                carry_on = 0;\n            }\n            \n            K /= 10;\n            len_K++;\n        }\n        \n        return A;\n    }\n};\n\n\n",
        "content": "&lt;-E 989&gt; Add to Array-Form of Integer\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; A, int K) {\n        int pos = A.size()-1;\n        int carry = 0;\n        std::vector&lt;int&gt; ret;\n        while(K &gt; 0 || pos &gt;= 0 || carry &gt; 0){\n            int kdigit = K % 10;\n            K = K / 10;\n            int sum = kdigit + carry;\n            if(pos &gt;= 0) \n                sum += A[pos];\n            \n            if(sum &gt; 9){\n                carry = sum / 10;\n                sum = sum%10;\n            }else{\n                carry = 0;\n            }\n            ret.push_back(sum);\n            --pos;\n        }\n        reverse(ret.begin(),ret.end());\n        return ret;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; A, int K) {\n        int len_K = 0;\n        int len = A.size() - 1;\n        int carry_on = 0;\n        \n        while(K || carry_on){\n            int index = len - len_K; \n            \n            if(index &lt; 0){\n                int tmp = K % 10 + carry_on;\n                if(tmp &gt;= 10){\n                    carry_on = 1;\n                    tmp = tmp % 10;\n                }else{\n                    carry_on = 0;\n                }\n                A.insert(A.begin(), tmp);\n                K /= 10;\n                continue;\n            }\n            \n            int tmp = A[index] + (K % 10) + carry_on;\n            if(tmp &gt;= 10){\n                A[index] = tmp%10;\n                carry_on = 1;\n                \n            }else{\n                A[index] = tmp;\n                carry_on = 0;\n            }\n            \n            K /= 10;\n            len_K++;\n        }\n        \n        return A;\n    }\n};\n\n\n",
        "url": "/2020/12/30/989-Add-to-Array-Form-of-Integer/"
      },
    
      {
        "title": "Rearrange Spaces Between Words",
        "excerpt": "&lt;-E 1592&gt; Rearrange Spaces Between Words\n\nclass Solution {\npublic:\n    string reorderSpaces(string text) {\n        auto words{0}, words_lengths{0};\n        string w;\n        for(stringstream ss{text}; ss&gt;&gt;w; words_lengths += size(w), words++);\n\n        int spaces = size(text) - words_lengths,\n                 d = words != 1 ? spaces / (words - 1) : 0;\n\n        string out;        \n        for(stringstream ss{text}; ss&gt;&gt;w; spaces-=d)\n            out.append(w).append(--words ? d : spaces, ' ');\n\n        return out; \n    }\n};\n\n\n",
        "content": "&lt;-E 1592&gt; Rearrange Spaces Between Words\n\nclass Solution {\npublic:\n    string reorderSpaces(string text) {\n        auto words{0}, words_lengths{0};\n        string w;\n        for(stringstream ss{text}; ss&gt;&gt;w; words_lengths += size(w), words++);\n\n        int spaces = size(text) - words_lengths,\n                 d = words != 1 ? spaces / (words - 1) : 0;\n\n        string out;        \n        for(stringstream ss{text}; ss&gt;&gt;w; spaces-=d)\n            out.append(w).append(--words ? d : spaces, ' ');\n\n        return out; \n    }\n};\n\n\n",
        "url": "/2020/12/31/1592-Rearrange-Spaces-Between-Words/"
      },
    
      {
        "title": "Repeated Substring Pattern",
        "excerpt": "&lt;-E 459&gt; Repeated Substring Pattern\n\n// Method 1\nclass Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        return (s + s).substr(1, 2 * s.size() - 2).find(s) != string::npos;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        string temp;\n        for(int i = 0; i &lt; s.size() / 2; i++) {\n            temp += s[i];\n            if(s.size() % temp.size() == 0) {\n                string res;\n                int t = s.size() / temp.size();\n                while(t--)\n                    res += temp;\n                if(res == s)\n                   return 1;\n            }\n        }\n        return 0;\n    }\n};\n\n\n",
        "content": "&lt;-E 459&gt; Repeated Substring Pattern\n\n// Method 1\nclass Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        return (s + s).substr(1, 2 * s.size() - 2).find(s) != string::npos;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        string temp;\n        for(int i = 0; i &lt; s.size() / 2; i++) {\n            temp += s[i];\n            if(s.size() % temp.size() == 0) {\n                string res;\n                int t = s.size() / temp.size();\n                while(t--)\n                    res += temp;\n                if(res == s)\n                   return 1;\n            }\n        }\n        return 0;\n    }\n};\n\n\n",
        "url": "/2020/12/31/459-Repeated-Substring-Pattern/"
      },
    
      {
        "title": "License Key Formatting",
        "excerpt": "&lt;-E 482&gt; License Key Formatting\n\nclass Solution {\npublic:\n    string licenseKeyFormatting(string S, int K) {\n        int len = S.length();\n        string result = \"\";\n        int counter = 0;\n        for(int idx = len - 1; idx &gt;= 0; idx--){\n            char c = S[idx];\n            if(c == '-') continue;\n            if(counter == K){\n                result += '-';\n                counter = 0;\n            }\n            if(c &gt;= 'a' &amp;&amp; c &lt;= 'z'){\n                c = c + ('A' - 'a');\n            }\n            result += c;\n            counter++;\n        }\n        \n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n\n\n",
        "content": "&lt;-E 482&gt; License Key Formatting\n\nclass Solution {\npublic:\n    string licenseKeyFormatting(string S, int K) {\n        int len = S.length();\n        string result = \"\";\n        int counter = 0;\n        for(int idx = len - 1; idx &gt;= 0; idx--){\n            char c = S[idx];\n            if(c == '-') continue;\n            if(counter == K){\n                result += '-';\n                counter = 0;\n            }\n            if(c &gt;= 'a' &amp;&amp; c &lt;= 'z'){\n                c = c + ('A' - 'a');\n            }\n            result += c;\n            counter++;\n        }\n        \n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n\n\n",
        "url": "/2020/12/31/482-License-Key-Formatting/"
      },
    
      {
        "title": "Moving Stones Until Consecutive",
        "excerpt": "&lt;-E 1033&gt; Moving Stones Until Consecutive\n\nclass Solution {\npublic:\n    vector&lt;int&gt; numMovesStones(int a, int b, int c) {\n        int sum_ = a + b + c;\n        int min_ = min(a, min(b, c));\n        int max_ = max(a, max(b, c));\n        int mid_ = sum_ - min_ - max_;\n        \n        if (max_ - min_ == 2)\n            return {0, 0};\n        \n        int min_move = min(mid_ - min_, max_ - mid_) &lt;= 2 ? 1 : 2;\n        int max_move = max_ - min_ - 2;\n        return {min_move, max_move};\n    }\n};\n\n\n",
        "content": "&lt;-E 1033&gt; Moving Stones Until Consecutive\n\nclass Solution {\npublic:\n    vector&lt;int&gt; numMovesStones(int a, int b, int c) {\n        int sum_ = a + b + c;\n        int min_ = min(a, min(b, c));\n        int max_ = max(a, max(b, c));\n        int mid_ = sum_ - min_ - max_;\n        \n        if (max_ - min_ == 2)\n            return {0, 0};\n        \n        int min_move = min(mid_ - min_, max_ - mid_) &lt;= 2 ? 1 : 2;\n        int max_move = max_ - min_ - 2;\n        return {min_move, max_move};\n    }\n};\n\n\n",
        "url": "/2021/01/01/1033-Moving-Stones-Until-Consecutive/"
      },
    
      {
        "title": "Find Mode in Binary Search Tree",
        "excerpt": "&lt;-E 501&gt; Find Mode in Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n// Method 1\nclass Solution {\n    unordered_map&lt;int, int&gt; mp;\n    int max = -1;\npublic:\n    void preorder(TreeNode *root){\n        if(!root)\n            return;\n        int val = ++mp[root-&gt;val];\n        if(val &gt; max)\n            max = val;\n        preorder(root-&gt;left);\n        preorder(root-&gt;right);\n    }\n    \n    vector&lt;int&gt; findMode(TreeNode* root) {\n        vector&lt;int&gt; ans;\n        preorder(root);\n        for(auto it : mp){\n            if(it.second == max)\n                ans.push_back(it.first);\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int maxFreq = 0, currFreq = 0, precursor = INT_MIN;\n    vector&lt;int&gt; res;\n\n    vector&lt;int&gt; findMode(TreeNode *root) {\n        inorderTraversal(root);\n        return res;\n    }\n\n    void inorderTraversal(TreeNode *root) {\n        if (root == NULL) return; \n        inorderTraversal(root-&gt;left); \n        if (precursor == root-&gt;val) currFreq++;\n        else currFreq = 1;\n        if (currFreq &gt; maxFreq) {\n            res.clear();\n            maxFreq = currFreq;\n            res.push_back(root-&gt;val);\n        }\n        else if (currFreq == maxFreq) {\n            res.push_back(root-&gt;val);\n        }\n        precursor = root-&gt;val; \n        inorderTraversal(root-&gt;right); \n    }\n};\n\n\n",
        "content": "&lt;-E 501&gt; Find Mode in Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n// Method 1\nclass Solution {\n    unordered_map&lt;int, int&gt; mp;\n    int max = -1;\npublic:\n    void preorder(TreeNode *root){\n        if(!root)\n            return;\n        int val = ++mp[root-&gt;val];\n        if(val &gt; max)\n            max = val;\n        preorder(root-&gt;left);\n        preorder(root-&gt;right);\n    }\n    \n    vector&lt;int&gt; findMode(TreeNode* root) {\n        vector&lt;int&gt; ans;\n        preorder(root);\n        for(auto it : mp){\n            if(it.second == max)\n                ans.push_back(it.first);\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int maxFreq = 0, currFreq = 0, precursor = INT_MIN;\n    vector&lt;int&gt; res;\n\n    vector&lt;int&gt; findMode(TreeNode *root) {\n        inorderTraversal(root);\n        return res;\n    }\n\n    void inorderTraversal(TreeNode *root) {\n        if (root == NULL) return; \n        inorderTraversal(root-&gt;left); \n        if (precursor == root-&gt;val) currFreq++;\n        else currFreq = 1;\n        if (currFreq &gt; maxFreq) {\n            res.clear();\n            maxFreq = currFreq;\n            res.push_back(root-&gt;val);\n        }\n        else if (currFreq == maxFreq) {\n            res.push_back(root-&gt;val);\n        }\n        precursor = root-&gt;val; \n        inorderTraversal(root-&gt;right); \n    }\n};\n\n\n",
        "url": "/2021/01/01/501-Find-Mode-in-Binary-Search-Tree/"
      },
    
      {
        "title": "Largest Number At Least Twice of Others",
        "excerpt": "&lt;-E 747&gt; Largest Number At Least Twice of Others\n\n// Method 1\nclass Solution {\npublic:\n    int dominantIndex(vector&lt;int&gt;&amp; nums) {\n        int mx = *max_element(nums.begin(), nums.end());\n        int index = -1;\n        \n        for(int i = 0; i &lt; nums.size(); i++) {\n            if(nums[i] == mx) {\n                index = i;\n                continue;\n            }\n            if(nums[i] * 2 &gt; mx) return -1;\n        } \n        return index;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int dominantIndex(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        if (1 == len) \n            return 0;\n        \n        int ret, max1, max2;\n        if (nums[0] &gt; nums[1]) {\n            ret = 0;\n            max1 = nums[0];\n            max2 = nums[1];\n        } else {\n            ret = 1;\n            max1 = nums[1];\n            max2 = nums[0];\n        }\n\n        for (int i = 2; i &lt; len; i++) {\n            if (nums[i] &gt; max1) {\n                ret = i;\n                max2 = max1;\n                max1 = nums[i];\n            } else if (nums[i] &gt; max2) {\n                max2 = nums[i];\n            }\n        }\n        \n        return max1 &gt;= 2 * max2 ? ret : -1;\n    }\n};\n\n\n",
        "content": "&lt;-E 747&gt; Largest Number At Least Twice of Others\n\n// Method 1\nclass Solution {\npublic:\n    int dominantIndex(vector&lt;int&gt;&amp; nums) {\n        int mx = *max_element(nums.begin(), nums.end());\n        int index = -1;\n        \n        for(int i = 0; i &lt; nums.size(); i++) {\n            if(nums[i] == mx) {\n                index = i;\n                continue;\n            }\n            if(nums[i] * 2 &gt; mx) return -1;\n        } \n        return index;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int dominantIndex(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        if (1 == len) \n            return 0;\n        \n        int ret, max1, max2;\n        if (nums[0] &gt; nums[1]) {\n            ret = 0;\n            max1 = nums[0];\n            max2 = nums[1];\n        } else {\n            ret = 1;\n            max1 = nums[1];\n            max2 = nums[0];\n        }\n\n        for (int i = 2; i &lt; len; i++) {\n            if (nums[i] &gt; max1) {\n                ret = i;\n                max2 = max1;\n                max1 = nums[i];\n            } else if (nums[i] &gt; max2) {\n                max2 = nums[i];\n            }\n        }\n        \n        return max1 &gt;= 2 * max2 ? ret : -1;\n    }\n};\n\n\n",
        "url": "/2021/01/01/747-Largest-Number-At-Least-Twice-of-Others/"
      },
    
      {
        "title": "Intersection of Two Linked Lists",
        "excerpt": "&lt;-E 160&gt; Intersection of Two Linked Lists\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n// Method 1\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set&lt;ListNode*&gt; s;\n        while (headA) {\n            s.insert(headA);\n            headA = headA-&gt;next;\n        }\n        while (headB) {\n            if (s.find(headB) != s.end())\n                return headB;\n            headB = headB-&gt;next;\n        }\n        return nullptr;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *a = headA;\n        ListNode *b = headB;\n        while(a != b){\n            a = a == NULL ? \n                headB : a-&gt;next;\n            b = b == NULL ? \n                headA : b-&gt;next;\n        }        \n    return a;\n    }\n};\n\n\n",
        "content": "&lt;-E 160&gt; Intersection of Two Linked Lists\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\n// Method 1\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set&lt;ListNode*&gt; s;\n        while (headA) {\n            s.insert(headA);\n            headA = headA-&gt;next;\n        }\n        while (headB) {\n            if (s.find(headB) != s.end())\n                return headB;\n            headB = headB-&gt;next;\n        }\n        return nullptr;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *a = headA;\n        ListNode *b = headB;\n        while(a != b){\n            a = a == NULL ? \n                headB : a-&gt;next;\n            b = b == NULL ? \n                headA : b-&gt;next;\n        }        \n    return a;\n    }\n};\n\n\n",
        "url": "/2021/01/02/160-Intersection-of-Two-Linked-Lists/"
      },
    
      {
        "title": "Set Mismatch",
        "excerpt": "&lt;-E 645&gt; Set Mismatch\n\nclass Solution {\npublic:\n    vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; v(nums.size() + 1), res(2);\n        \n        for(int i = 0; i &lt; nums.size(); ++i)\n            if(++v[nums[i]] == 2) \n                res[0] = nums[i];\n        \n        for(int i = 1; i &lt; v.size(); ++i)\n            if(!v[i]) { \n                res[1] = i; \n                break; \n            }\n        \n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 645&gt; Set Mismatch\n\nclass Solution {\npublic:\n    vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; v(nums.size() + 1), res(2);\n        \n        for(int i = 0; i &lt; nums.size(); ++i)\n            if(++v[nums[i]] == 2) \n                res[0] = nums[i];\n        \n        for(int i = 1; i &lt; v.size(); ++i)\n            if(!v[i]) { \n                res[1] = i; \n                break; \n            }\n        \n        return res;\n    }\n};\n\n\n",
        "url": "/2021/01/02/645-Set-Mismatch/"
      },
    
      {
        "title": "Second Minimum Node In a Binary Tree",
        "excerpt": "&lt;-E 671&gt; Second Minimum Node In a Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findSecondMinimumValue(TreeNode* root) {\n        if(!root) return -1;\n        \n        unsigned a = UINT_MAX, b = UINT_MAX;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        \n        while(!q.empty()) {\n            if(q.front()-&gt;left)  q.push(q.front()-&gt;left);\n            if(q.front()-&gt;right) q.push(q.front()-&gt;right);\n            \n            if(q.front()-&gt;val &lt; a) {\n                if(a &lt; b) \n                    b = a;\n                a = q.front()-&gt;val;\n            }\n            else if(q.front()-&gt;val != a and q.front()-&gt;val &lt; b)\n                b = q.front()-&gt;val;\n            \n            q.pop();\n        }\n        \n        return b!=UINT_MAX?b:-1;\n    }\n};\n\n\n",
        "content": "&lt;-E 671&gt; Second Minimum Node In a Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findSecondMinimumValue(TreeNode* root) {\n        if(!root) return -1;\n        \n        unsigned a = UINT_MAX, b = UINT_MAX;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        \n        while(!q.empty()) {\n            if(q.front()-&gt;left)  q.push(q.front()-&gt;left);\n            if(q.front()-&gt;right) q.push(q.front()-&gt;right);\n            \n            if(q.front()-&gt;val &lt; a) {\n                if(a &lt; b) \n                    b = a;\n                a = q.front()-&gt;val;\n            }\n            else if(q.front()-&gt;val != a and q.front()-&gt;val &lt; b)\n                b = q.front()-&gt;val;\n            \n            q.pop();\n        }\n        \n        return b!=UINT_MAX?b:-1;\n    }\n};\n\n\n",
        "url": "/2021/01/02/671-Second-Minimum-Node-In-a-Binary-Tree/"
      },
    
      {
        "title": "Valid Boomerang",
        "excerpt": "&lt;-E 1037&gt; Valid Boomerang\n\nclass Solution {\npublic:\n    bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n        return (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]) != \n            (points[2][1] - points[1][1]) * (points[1][0] - points[0][0]);\n    }\n};\n\n\n",
        "content": "&lt;-E 1037&gt; Valid Boomerang\n\nclass Solution {\npublic:\n    bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n        return (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]) != \n            (points[2][1] - points[1][1]) * (points[1][0] - points[0][0]);\n    }\n};\n\n\n",
        "url": "/2021/01/03/1037-Valid-Boomerang/"
      },
    
      {
        "title": "Minimum Depth of Binary Tree",
        "excerpt": "&lt;-E 111&gt; Minimum Depth of Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if(!root)\n            return 0;\n        int leftd = minDepth(root-&gt;left);\n        int rightd = minDepth(root-&gt;right);\n        if(leftd &gt; 0 and rightd &gt; 0) \n            return min(leftd, rightd) + 1;\n        else if(leftd &lt;= 0)\n            return rightd + 1;\n        else \n            return leftd + 1;\n    }\n};\n\n\n",
        "content": "&lt;-E 111&gt; Minimum Depth of Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if(!root)\n            return 0;\n        int leftd = minDepth(root-&gt;left);\n        int rightd = minDepth(root-&gt;right);\n        if(leftd &gt; 0 and rightd &gt; 0) \n            return min(leftd, rightd) + 1;\n        else if(leftd &lt;= 0)\n            return rightd + 1;\n        else \n            return leftd + 1;\n    }\n};\n\n\n",
        "url": "/2021/01/03/111-Minimum-Depth-of-Binary-Tree/"
      },
    
      {
        "title": "Remove Linked List Elements",
        "excerpt": "&lt;-E 203&gt; Remove Linked List Elements\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n// Method 1\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        for (ListNode *prev = 0, *node = head; node; node = node-&gt;next) {\n            if (node-&gt;val == val) {\n                if (prev)\n                    prev-&gt;next = node-&gt;next;\n                else\n                    head = node-&gt;next;\n            } else {\n                prev = node;\n            }\n        }\n        return head;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        if(head == NULL)\n            return head;\n        if(head-&gt;val == val) \n            head = removeElements(head-&gt;next, val);\n        else\n            head-&gt;next = removeElements(head-&gt;next, val);\n        return head;\n    }\n};\n\n\n",
        "content": "&lt;-E 203&gt; Remove Linked List Elements\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n// Method 1\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        for (ListNode *prev = 0, *node = head; node; node = node-&gt;next) {\n            if (node-&gt;val == val) {\n                if (prev)\n                    prev-&gt;next = node-&gt;next;\n                else\n                    head = node-&gt;next;\n            } else {\n                prev = node;\n            }\n        }\n        return head;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        if(head == NULL)\n            return head;\n        if(head-&gt;val == val) \n            head = removeElements(head-&gt;next, val);\n        else\n            head-&gt;next = removeElements(head-&gt;next, val);\n        return head;\n    }\n};\n\n\n",
        "url": "/2021/01/03/1203-Remove-Linked-List-Elements/"
      },
    
      {
        "title": "Count Primes",
        "excerpt": "&lt;-E 204&gt; Count Primes\n\nclass Solution {\npublic:\n    int countPrimes(int n) {\n      if (n==0 || n==1) return false;\n        // vector&lt;int&gt; prime(n+1, 1);\n        // ----\n        int prime[n];\n        for (int i = 0; i &lt; n; i++) {\n            prime[i] = 1;\n        }\n        // -----\n        for (int p = 2; p * p &lt; n; ++p) {\n            if (!prime[p]) \n                continue;\n            for (int d = 2; (p * d) &lt; n; ++d)\n                prime[p * d] = 0;\n        }\n        // ---\n        int res = 0;\n        for (int i = 2; i &lt; n; i++) {\n            if (prime[i]) res++;\n        }\n        return res;\n        // ----\n        //return accumulate(prime.begin(), prime.end(), -3);  \n    }\n};\n\n\n",
        "content": "&lt;-E 204&gt; Count Primes\n\nclass Solution {\npublic:\n    int countPrimes(int n) {\n      if (n==0 || n==1) return false;\n        // vector&lt;int&gt; prime(n+1, 1);\n        // ----\n        int prime[n];\n        for (int i = 0; i &lt; n; i++) {\n            prime[i] = 1;\n        }\n        // -----\n        for (int p = 2; p * p &lt; n; ++p) {\n            if (!prime[p]) \n                continue;\n            for (int d = 2; (p * d) &lt; n; ++d)\n                prime[p * d] = 0;\n        }\n        // ---\n        int res = 0;\n        for (int i = 2; i &lt; n; i++) {\n            if (prime[i]) res++;\n        }\n        return res;\n        // ----\n        //return accumulate(prime.begin(), prime.end(), -3);  \n    }\n};\n\n\n",
        "url": "/2021/01/03/1204-Count-Primes/"
      },
    
      {
        "title": "Valid Palindrome",
        "excerpt": "&lt;-E 125&gt; Valid Palindrome\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        if(s.length() &lt;= 1) \n            return true;\n        int l = 0, r = s.length() - 1;\n        while(l &lt; r) {\n            if(!isalnum(s[r])) \n                r--;\n            else if(!isalnum(s[l])) \n                l++;\n            else {\n                if(tolower(s[l]) != tolower(s[r])) \n                    return false;\n                l++; \n                r--;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 125&gt; Valid Palindrome\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        if(s.length() &lt;= 1) \n            return true;\n        int l = 0, r = s.length() - 1;\n        while(l &lt; r) {\n            if(!isalnum(s[r])) \n                r--;\n            else if(!isalnum(s[l])) \n                l++;\n            else {\n                if(tolower(s[l]) != tolower(s[r])) \n                    return false;\n                l++; \n                r--;\n            }\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2021/01/03/125-Valid-Palindrome/"
      },
    
      {
        "title": "Linked List Cycle",
        "excerpt": "&lt;-E 141&gt; Linked List Cycle\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast != NULL and fast-&gt;next != NULL){\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n            if(slow == fast)\n                return true;\n        }\n        return false;     \n    }\n};\n\n\n",
        "content": "&lt;-E 141&gt; Linked List Cycle\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast != NULL and fast-&gt;next != NULL){\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n            if(slow == fast)\n                return true;\n        }\n        return false;     \n    }\n};\n\n\n",
        "url": "/2021/01/03/141-Linked-List-Cycle/"
      },
    
      {
        "title": "Detect Pattern of Length M Repeated K or More Times",
        "excerpt": "&lt;-E 1566&gt; Detect Pattern of Length M Repeated K or More Times\n\nclass Solution {\npublic:\n    bool containsPattern(vector&lt;int&gt;&amp; arr, int m, int k) {\n        int n = arr.size();\n        int counter = 0;\n\n        for (int i = 0; i + m &lt; n; i++) {\n            if (arr[i] == arr[i+m]) \n                counter++;\n            else \n                counter = 0;\n\n            if (counter == m * (k - 1)) \n                return true;\n        }\n        return false;\n    }\n};\n\n\n",
        "content": "&lt;-E 1566&gt; Detect Pattern of Length M Repeated K or More Times\n\nclass Solution {\npublic:\n    bool containsPattern(vector&lt;int&gt;&amp; arr, int m, int k) {\n        int n = arr.size();\n        int counter = 0;\n\n        for (int i = 0; i + m &lt; n; i++) {\n            if (arr[i] == arr[i+m]) \n                counter++;\n            else \n                counter = 0;\n\n            if (counter == m * (k - 1)) \n                return true;\n        }\n        return false;\n    }\n};\n\n\n",
        "url": "/2021/01/03/1566-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times/"
      },
    
      {
        "title": "Maximum Repeating Substring",
        "excerpt": "&lt;-E 1668&gt; Maximum Repeating Substring\n\nclass Solution {\npublic:\n    int maxRepeating(string sequence, string word) {\n        string temp = word;\n        int times = 0;\n        while (sequence.find(temp) != string::npos) {\n            temp += word;\n            times++;\n        }\n        return times;\n    }\n};\n\n\n",
        "content": "&lt;-E 1668&gt; Maximum Repeating Substring\n\nclass Solution {\npublic:\n    int maxRepeating(string sequence, string word) {\n        string temp = word;\n        int times = 0;\n        while (sequence.find(temp) != string::npos) {\n            temp += word;\n            times++;\n        }\n        return times;\n    }\n};\n\n\n",
        "url": "/2021/01/03/1668-Maximum-Repeating-Substring/"
      },
    
      {
        "title": "Valid Palindrome II",
        "excerpt": "&lt;-E 680&gt; Valid Palindrome II\n\nclass Solution {\npublic:\n    bool validPalindrome(string s) {\n        int i = 0;\n\t\tint j = s.length() - 1;\n\n\t\twhile (i &lt; j) {\n\t\t\tif (s[i] == s[j]) {\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn isPal(s, i + 1, j) || isPal(s, i, j - 1);\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isPal(string s, int i, int j) {\n\t\twhile (i &lt; j) {\n\t\t\tif (s[i] == s[j]) {\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t} else \n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n    }\n};\n\n\n",
        "content": "&lt;-E 680&gt; Valid Palindrome II\n\nclass Solution {\npublic:\n    bool validPalindrome(string s) {\n        int i = 0;\n\t\tint j = s.length() - 1;\n\n\t\twhile (i &lt; j) {\n\t\t\tif (s[i] == s[j]) {\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn isPal(s, i + 1, j) || isPal(s, i, j - 1);\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isPal(string s, int i, int j) {\n\t\twhile (i &lt; j) {\n\t\t\tif (s[i] == s[j]) {\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t} else \n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n    }\n};\n\n\n",
        "url": "/2021/01/03/1680-Valid-Palindrome-II/"
      },
    
      {
        "title": "Determine if String Halves Are Alike",
        "excerpt": "&lt;-E 1704&gt; Determine if String Halves Are Alike\n\nclass Solution {\npublic:\n    bool halvesAreAlike(string s) {\n        int n = s.size();\n        string s1 = s.substr(0,n/2);\n        string s2 = s.substr(n/2,n/2);\n        unordered_set&lt;char&gt; vs = {'a','e','i','o','u','A','E','I','O','U'};\n        int c = 0;\n        for(auto a : s1){\n            if(vs.find(a) != vs.end())\n                c++;\n        }\n        for(auto a:s2){\n            if(vs.find(a) != vs.end())\n                c--;\n        }\n        return c == 0;\n    }\n};\n\n\n",
        "content": "&lt;-E 1704&gt; Determine if String Halves Are Alike\n\nclass Solution {\npublic:\n    bool halvesAreAlike(string s) {\n        int n = s.size();\n        string s1 = s.substr(0,n/2);\n        string s2 = s.substr(n/2,n/2);\n        unordered_set&lt;char&gt; vs = {'a','e','i','o','u','A','E','I','O','U'};\n        int c = 0;\n        for(auto a : s1){\n            if(vs.find(a) != vs.end())\n                c++;\n        }\n        for(auto a:s2){\n            if(vs.find(a) != vs.end())\n                c--;\n        }\n        return c == 0;\n    }\n};\n\n\n",
        "url": "/2021/01/03/1704-Determine-if-String-Halves-Are-Alike/"
      },
    
      {
        "title": "Reverse Bits",
        "excerpt": "&lt;-E 190&gt; Reverse Bits\n\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t ret = 0;\n        for(int i = 31; i &gt;= 0; i--) {\n            ret |= ((1 &amp; n) &lt;&lt; i);\n            n = n &gt;&gt; 1;\n        }\n        return ret;\n    }\n};\n\n\n",
        "content": "&lt;-E 190&gt; Reverse Bits\n\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t ret = 0;\n        for(int i = 31; i &gt;= 0; i--) {\n            ret |= ((1 &amp; n) &lt;&lt; i);\n            n = n &gt;&gt; 1;\n        }\n        return ret;\n    }\n};\n\n\n",
        "url": "/2021/01/03/190-Reverse-Bits/"
      },
    
      {
        "title": "Isomorphic Strings",
        "excerpt": "&lt;-E 205&gt; Isomorphic Strings\n\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        vector&lt;int&gt; v1(256),v2(256);\n        for(int i = 0; i &lt; s.size(); i++){\n            if(v1[s[i]] != v2[t[i]]) \n                return false;\n            v1[s[i]] = i + 1;\n            v2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 205&gt; Isomorphic Strings\n\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        vector&lt;int&gt; v1(256),v2(256);\n        for(int i = 0; i &lt; s.size(); i++){\n            if(v1[s[i]] != v2[t[i]]) \n                return false;\n            v1[s[i]] = i + 1;\n            v2[t[i]] = i + 1;\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2021/01/03/205-Isomorphic-Strings/"
      },
    
      {
        "title": "Summary Ranges",
        "excerpt": "&lt;-E 228&gt; Summary Ranges\n\nclass Solution {\npublic:\n    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) {\n        vector&lt;string&gt; ranges;\n        int n = nums.size();\n        if(n == 0)\n            return ranges;\n        int l = nums[0];\n        for(int i = 1; i &lt;= n; ++i) {\n            if(i == n || nums[i] &gt; nums[i-1] + 1) {\n                if(nums[i-1] == l)\n                    ranges.push_back(to_string(l));\n                else\n                    ranges.push_back(to_string(l) + \"-&gt;\" + to_string(nums[i-1]));\n                if(i &lt; n)\n                    l = nums[i];\n            }\n        }\n        return ranges;\n    }\n};\n\n\n",
        "content": "&lt;-E 228&gt; Summary Ranges\n\nclass Solution {\npublic:\n    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) {\n        vector&lt;string&gt; ranges;\n        int n = nums.size();\n        if(n == 0)\n            return ranges;\n        int l = nums[0];\n        for(int i = 1; i &lt;= n; ++i) {\n            if(i == n || nums[i] &gt; nums[i-1] + 1) {\n                if(nums[i-1] == l)\n                    ranges.push_back(to_string(l));\n                else\n                    ranges.push_back(to_string(l) + \"-&gt;\" + to_string(nums[i-1]));\n                if(i &lt; n)\n                    l = nums[i];\n            }\n        }\n        return ranges;\n    }\n};\n\n\n",
        "url": "/2021/01/03/228-Summary-Ranges/"
      },
    
      {
        "title": "Palindrome Linked List",
        "excerpt": "&lt;-E 234&gt; Palindrome Linked List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        stack&lt;int&gt; st;\n        ListNode *p = head;\n        while(head){\n            st.push(head-&gt;val);\n            head = head-&gt;next;\n        }\n        while(p){\n            if(st.top() != p-&gt;val) \n                return false;\n            st.pop();\n            p = p-&gt;next;\n        }\n        return true;\n    }\n};\n\n\n\n",
        "content": "&lt;-E 234&gt; Palindrome Linked List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        stack&lt;int&gt; st;\n        ListNode *p = head;\n        while(head){\n            st.push(head-&gt;val);\n            head = head-&gt;next;\n        }\n        while(p){\n            if(st.top() != p-&gt;val) \n                return false;\n            st.pop();\n            p = p-&gt;next;\n        }\n        return true;\n    }\n};\n\n\n\n",
        "url": "/2021/01/03/234-Palindrome-Linked-List/"
      },
    
      {
        "title": "First Bad Version",
        "excerpt": "&lt;-E 278&gt; First Bad Version\n\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int start = 1;\n        int end = n;\n        int ans = 0;\n        while(start &lt;= end) {\n        int mid = start + (end - start) / 2;\n            if(isBadVersion(mid)){\n                ans = mid;\n                end = mid - 1;\n            }\n            else\n                start = mid + 1; \n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 278&gt; First Bad Version\n\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int start = 1;\n        int end = n;\n        int ans = 0;\n        while(start &lt;= end) {\n        int mid = start + (end - start) / 2;\n            if(isBadVersion(mid)){\n                ans = mid;\n                end = mid - 1;\n            }\n            else\n                start = mid + 1; \n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2021/01/03/278-First-Bad-Version/"
      },
    
      {
        "title": "Word Pattern",
        "excerpt": "&lt;-E 290&gt; Word Pattern\n\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        unordered_map&lt;string,char&gt; mp1;\n        unordered_map&lt;char,string&gt; mp2;\n        string str; \n        int i = 0;\n        while(ss &gt;&gt; str){\n            if(mp1[str] &lt; 1 and mp2[pattern[i]].size() &lt; 1){\n                mp1[str] = pattern[i];\n                mp2[pattern[i]] = str;\n            }\n            else if(mp1[str] != pattern[i] or mp2[pattern[i]] != str)\n                return false;\n            i++;\n        }\n        if(i &lt; pattern.size()) \n            return false;\n        return true;\n        }\n    \n};\n\n\n",
        "content": "&lt;-E 290&gt; Word Pattern\n\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        stringstream ss(s);\n        unordered_map&lt;string,char&gt; mp1;\n        unordered_map&lt;char,string&gt; mp2;\n        string str; \n        int i = 0;\n        while(ss &gt;&gt; str){\n            if(mp1[str] &lt; 1 and mp2[pattern[i]].size() &lt; 1){\n                mp1[str] = pattern[i];\n                mp2[pattern[i]] = str;\n            }\n            else if(mp1[str] != pattern[i] or mp2[pattern[i]] != str)\n                return false;\n            i++;\n        }\n        if(i &lt; pattern.size()) \n            return false;\n        return true;\n        }\n    \n};\n\n\n",
        "url": "/2021/01/03/290-Word-Pattern/"
      },
    
      {
        "title": "Third Maximum Number",
        "excerpt": "&lt;-E 414&gt; Third Maximum Number\n\nclass Solution {\npublic:\n    int thirdMax(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 1) \n            return nums[0];\n        if (nums.size() == 2) \n            return nums[0] &gt; nums[1] ? nums[0] : nums[1];\n    \n        int max1 = nums[0];\n        int max2 = numeric_limits&lt;int&gt;::min();\n        int max3 = numeric_limits&lt;int&gt;::min();\n        bool has_int_min = false;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (nums[i] == INT_MIN) \n                has_int_min = true;\n            if (nums[i] &gt; max1) {\n                max3 = max2;\n                max2 = max1;\n                max1 = nums[i];\n            } else if (nums[i] != max1) {\n                if (nums[i] &gt; max2) {\n                    max3 = max2;\n                    max2 = nums[i];\n                } else if (nums[i] != max2) {\n                    if (nums[i] &gt; max3) {\n                        max3 = nums[i];\n                    }\n                }\n            }\n        }\n        if (max3 == max2) \n            return max1;\n        if (max3 != INT_MIN) \n            return max3;\n        else if (has_int_min) \n            return max3;\n        else \n            return max1;\n    }\n};\n\n\n",
        "content": "&lt;-E 414&gt; Third Maximum Number\n\nclass Solution {\npublic:\n    int thirdMax(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 1) \n            return nums[0];\n        if (nums.size() == 2) \n            return nums[0] &gt; nums[1] ? nums[0] : nums[1];\n    \n        int max1 = nums[0];\n        int max2 = numeric_limits&lt;int&gt;::min();\n        int max3 = numeric_limits&lt;int&gt;::min();\n        bool has_int_min = false;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (nums[i] == INT_MIN) \n                has_int_min = true;\n            if (nums[i] &gt; max1) {\n                max3 = max2;\n                max2 = max1;\n                max1 = nums[i];\n            } else if (nums[i] != max1) {\n                if (nums[i] &gt; max2) {\n                    max3 = max2;\n                    max2 = nums[i];\n                } else if (nums[i] != max2) {\n                    if (nums[i] &gt; max3) {\n                        max3 = nums[i];\n                    }\n                }\n            }\n        }\n        if (max3 == max2) \n            return max1;\n        if (max3 != INT_MIN) \n            return max3;\n        else if (has_int_min) \n            return max3;\n        else \n            return max1;\n    }\n};\n\n\n",
        "url": "/2021/01/03/414-Third-Maximum-Number/"
      },
    
      {
        "title": "Can Place Flowers",
        "excerpt": "&lt;-E 605&gt; Can Place Flowers\n\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {\n        for (int i = 0; i &lt; flowerbed.size(); i++) {\n            if (n == 0) \n                return true;\n            \n            if (flowerbed[i] == 0) {\n                if (i &gt; 0 &amp;&amp; flowerbed[i - 1] == 1) \n                    continue;\n                if (i &lt; flowerbed.size() - 1 &amp;&amp; flowerbed[i + 1] == 1) \n                    continue;\n                \n                flowerbed[i] = 1; n--; \n            } \n        }\n        \n        return n == 0;\n    }\n};\n\n\n",
        "content": "&lt;-E 605&gt; Can Place Flowers\n\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {\n        for (int i = 0; i &lt; flowerbed.size(); i++) {\n            if (n == 0) \n                return true;\n            \n            if (flowerbed[i] == 0) {\n                if (i &gt; 0 &amp;&amp; flowerbed[i - 1] == 1) \n                    continue;\n                if (i &lt; flowerbed.size() - 1 &amp;&amp; flowerbed[i + 1] == 1) \n                    continue;\n                \n                flowerbed[i] = 1; n--; \n            } \n        }\n        \n        return n == 0;\n    }\n};\n\n\n",
        "url": "/2021/01/03/605-Can-Place-Flowers/"
      },
    
      {
        "title": "Maximum Average Subarray I",
        "excerpt": "&lt;-E 643&gt; Maximum Average Subarray I\n\nclass Solution {\npublic:\n    double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) {\n        int cumulative[nums.size()];\n        cumulative[0] = nums[0];\n        for(int i = 1; i &lt; nums.size(); i++)\n            cumulative[i] = nums[i] + cumulative[i - 1]; \n        \n        double max = cumulative[k - 1]; \n        for(int i = 1; i &lt;= nums.size() - k; i++){\n            if(cumulative[i + k - 1] - cumulative[i - 1] &gt; max)\n                max = cumulative[i + k - 1] - cumulative[i - 1];\n        }\n        double avg = max / k;\n        return avg;\n    }\n};\n\n\n",
        "content": "&lt;-E 643&gt; Maximum Average Subarray I\n\nclass Solution {\npublic:\n    double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) {\n        int cumulative[nums.size()];\n        cumulative[0] = nums[0];\n        for(int i = 1; i &lt; nums.size(); i++)\n            cumulative[i] = nums[i] + cumulative[i - 1]; \n        \n        double max = cumulative[k - 1]; \n        for(int i = 1; i &lt;= nums.size() - k; i++){\n            if(cumulative[i + k - 1] - cumulative[i - 1] &gt; max)\n                max = cumulative[i + k - 1] - cumulative[i - 1];\n        }\n        double avg = max / k;\n        return avg;\n    }\n};\n\n\n",
        "url": "/2021/01/03/643-Maximum-Average-Subarray-I/"
      },
    
      {
        "title": "Buddy Strings",
        "excerpt": "&lt;-E 859&gt; Buddy Strings\n\nclass Solution {\npublic:\n    bool buddyStrings(string A, string B) { \n        if(A.size()!= B.size()) \n            return false;\n        \n        if(A == B){\n            vector&lt;int&gt;freq(26,0);\n            \n            for(int i = 0; i &lt; A.size(); i++){\n                if(++freq[A[i] - 'a'] == 2) \n                    return true;\n            }\n            return false;\n        }\n        \n        vector&lt;int&gt; mismatch;\n        for(int i = 0; i &lt; A.size();i++){\n            if(A[i] == B[i])  \n                continue;\n            mismatch.push_back(i);\n        }\n        \n        if(mismatch.size() != 2) \n            return false;\n        \n        if(A[mismatch[1]] == B[mismatch[0]] &amp;&amp; B[mismatch[1]] == A[mismatch[0]])\n            return true;\n        \n        return false;\n    }\n};\n\n\n",
        "content": "&lt;-E 859&gt; Buddy Strings\n\nclass Solution {\npublic:\n    bool buddyStrings(string A, string B) { \n        if(A.size()!= B.size()) \n            return false;\n        \n        if(A == B){\n            vector&lt;int&gt;freq(26,0);\n            \n            for(int i = 0; i &lt; A.size(); i++){\n                if(++freq[A[i] - 'a'] == 2) \n                    return true;\n            }\n            return false;\n        }\n        \n        vector&lt;int&gt; mismatch;\n        for(int i = 0; i &lt; A.size();i++){\n            if(A[i] == B[i])  \n                continue;\n            mismatch.push_back(i);\n        }\n        \n        if(mismatch.size() != 2) \n            return false;\n        \n        if(A[mismatch[1]] == B[mismatch[0]] &amp;&amp; B[mismatch[1]] == A[mismatch[0]])\n            return true;\n        \n        return false;\n    }\n};\n\n\n",
        "url": "/2021/01/03/859-Buddy-Strings/"
      },
    
      {
        "title": "Walking Robot Simulation",
        "excerpt": "&lt;-E 874&gt; Walking Robot Simulation\n\nclass Solution {\npublic:\n    int robotSim(vector&lt;int&gt;&amp; commands, vector&lt;vector&lt;int&gt;&gt;&amp; obstacles) {\n        int x = 0, y = 0;\n        char dir = 'u';\n        \n        set&lt;pair&lt;int, int&gt;&gt;s;\n        for (int i = 0; i &lt; obstacles.size(); i++)\n            s.insert({obstacles[i][0], obstacles[i][1]});\n        \n        int res = 0;\n        for (int i = 0; i &lt; commands.size(); i++) {\n            if (commands[i] &gt; 0) {\n                if (dir == 'u') {\n                    int p = y;\n                    while (p &lt;= y+commands[i] &amp;&amp; ((x == 0 &amp;&amp; p == 0) || s.find({x, p}) == s.end()))\n                        p++;\n                    y = s.find({x, p}) == s.end() ? y + commands[i] : p-1;\n                } else if (dir == 'd') {\n                    int p = y;\n                    while (p &gt;= y-commands[i] &amp;&amp; ((x == 0 &amp;&amp; p == 0) || s.find({x, p}) == s.end()))\n                        p--;\n                    y = s.find({x, p}) == s.end() ? y - commands[i] : p+1;\n                } else if (dir == 'l') {\n                    int p = x;\n                    while (p &gt;= x-commands[i] &amp;&amp; ((p == 0 &amp;&amp; y == 0) || s.find({p, y}) == s.end()))\n                        p--;\n                    x = s.find({p, y}) == s.end() ? x - commands[i] : p+1;\n                } else if (dir == 'r') {\n                    int p = x;\n                    while (p &lt;= x+commands[i] &amp;&amp; ((p == 0 &amp;&amp; y == 0) || s.find({p, y}) == s.end()))\n                        p++;\n                    x = s.find({p, y}) == s.end() ? x + commands[i] : p-1;\n                }\n            } else if (commands[i] == -2) {\n                if (dir == 'u') dir = 'l';\n                else if (dir == 'r') dir = 'u';\n                else if (dir == 'd') dir = 'r';\n                else if (dir == 'l') dir = 'd';\n            } else if (commands[i] == -1) {\n                if (dir == 'u') dir = 'r';\n                else if (dir == 'r') dir = 'd';\n                else if (dir == 'd') dir = 'l';\n                else if (dir == 'l') dir = 'u';\n            }\n            \n            res = max(res, x*x + y*y);\n        }\n        \n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 874&gt; Walking Robot Simulation\n\nclass Solution {\npublic:\n    int robotSim(vector&lt;int&gt;&amp; commands, vector&lt;vector&lt;int&gt;&gt;&amp; obstacles) {\n        int x = 0, y = 0;\n        char dir = 'u';\n        \n        set&lt;pair&lt;int, int&gt;&gt;s;\n        for (int i = 0; i &lt; obstacles.size(); i++)\n            s.insert({obstacles[i][0], obstacles[i][1]});\n        \n        int res = 0;\n        for (int i = 0; i &lt; commands.size(); i++) {\n            if (commands[i] &gt; 0) {\n                if (dir == 'u') {\n                    int p = y;\n                    while (p &lt;= y+commands[i] &amp;&amp; ((x == 0 &amp;&amp; p == 0) || s.find({x, p}) == s.end()))\n                        p++;\n                    y = s.find({x, p}) == s.end() ? y + commands[i] : p-1;\n                } else if (dir == 'd') {\n                    int p = y;\n                    while (p &gt;= y-commands[i] &amp;&amp; ((x == 0 &amp;&amp; p == 0) || s.find({x, p}) == s.end()))\n                        p--;\n                    y = s.find({x, p}) == s.end() ? y - commands[i] : p+1;\n                } else if (dir == 'l') {\n                    int p = x;\n                    while (p &gt;= x-commands[i] &amp;&amp; ((p == 0 &amp;&amp; y == 0) || s.find({p, y}) == s.end()))\n                        p--;\n                    x = s.find({p, y}) == s.end() ? x - commands[i] : p+1;\n                } else if (dir == 'r') {\n                    int p = x;\n                    while (p &lt;= x+commands[i] &amp;&amp; ((p == 0 &amp;&amp; y == 0) || s.find({p, y}) == s.end()))\n                        p++;\n                    x = s.find({p, y}) == s.end() ? x + commands[i] : p-1;\n                }\n            } else if (commands[i] == -2) {\n                if (dir == 'u') dir = 'l';\n                else if (dir == 'r') dir = 'u';\n                else if (dir == 'd') dir = 'r';\n                else if (dir == 'l') dir = 'd';\n            } else if (commands[i] == -1) {\n                if (dir == 'u') dir = 'r';\n                else if (dir == 'r') dir = 'd';\n                else if (dir == 'd') dir = 'l';\n                else if (dir == 'l') dir = 'u';\n            }\n            \n            res = max(res, x*x + y*y);\n        }\n        \n        return res;\n    }\n};\n\n\n",
        "url": "/2021/01/03/874-Walking-Robot-Simulation/"
      },
    
      {
        "title": "X of a Kind in a Deck of Cards",
        "excerpt": "&lt;-E 914&gt; X of a Kind in a Deck of Cards\n\nclass Solution {\npublic:\n    bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) {\n        unordered_map&lt;int, int&gt; mp;\n        for(auto d : deck)\n            mp[d]++;\n        int x;\n        x = mp.begin()-&gt;second;\n        for(auto it : mp)\n            x = gcd(x, it.second);\n        if(x &gt; 1) \n            return true;\n        return false;\n    }\n};\n\n\n",
        "content": "&lt;-E 914&gt; X of a Kind in a Deck of Cards\n\nclass Solution {\npublic:\n    bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) {\n        unordered_map&lt;int, int&gt; mp;\n        for(auto d : deck)\n            mp[d]++;\n        int x;\n        x = mp.begin()-&gt;second;\n        for(auto it : mp)\n            x = gcd(x, it.second);\n        if(x &gt; 1) \n            return true;\n        return false;\n    }\n};\n\n\n",
        "url": "/2021/01/03/914-X-of-a-Kind-in-a-Deck-of-Cards/"
      },
    
      {
        "title": "Long Pressed Name",
        "excerpt": "&lt;-E 925&gt; Long Pressed Name\n\nclass Solution {\npublic:\n    bool isLongPressedName(string name, string typed) {\n        int i = 0;\n        int j = 0;\n        char temp;\n        \n        while(i &lt;= name.size() || j &lt;= typed.size()) { \n            if(name[i] == typed[j]) {   \n                temp = name[i];\n                i++;\n                j++;\n            }\n            else {\n               if(temp == typed[j])\n                   j++;\n                else\n                    return false;\n            }\n        }\n        return true; \n    }\n};\n\n\n",
        "content": "&lt;-E 925&gt; Long Pressed Name\n\nclass Solution {\npublic:\n    bool isLongPressedName(string name, string typed) {\n        int i = 0;\n        int j = 0;\n        char temp;\n        \n        while(i &lt;= name.size() || j &lt;= typed.size()) { \n            if(name[i] == typed[j]) {   \n                temp = name[i];\n                i++;\n                j++;\n            }\n            else {\n               if(temp == typed[j])\n                   j++;\n                else\n                    return false;\n            }\n        }\n        return true; \n    }\n};\n\n\n",
        "url": "/2021/01/03/925-Long-Pressed-Name/"
      },
    
      {
        "title": "Valid Mountain Array",
        "excerpt": "&lt;-E 941&gt; Valid Mountain Array\n\nclass Solution {\npublic:\n    bool validMountainArray(vector&lt;int&gt;&amp; arr) {\n        if (arr.size() &lt;= 1)\n            return false;\n        int i = 0;\n        while (i &lt; arr.size() - 1 &amp;&amp; arr[i] &lt; arr[i + 1])\n            i++;   \n        if (i == 0 || i == arr.size()-1)\n            return false;\n        while (i &lt; arr.size() - 1 &amp;&amp; arr[i] &gt; arr[i + 1])\n            i++;\n        return i == arr.size()-1;\n    }\n};\n\n\n",
        "content": "&lt;-E 941&gt; Valid Mountain Array\n\nclass Solution {\npublic:\n    bool validMountainArray(vector&lt;int&gt;&amp; arr) {\n        if (arr.size() &lt;= 1)\n            return false;\n        int i = 0;\n        while (i &lt; arr.size() - 1 &amp;&amp; arr[i] &lt; arr[i + 1])\n            i++;   \n        if (i == 0 || i == arr.size()-1)\n            return false;\n        while (i &lt; arr.size() - 1 &amp;&amp; arr[i] &gt; arr[i + 1])\n            i++;\n        return i == arr.size()-1;\n    }\n};\n\n\n",
        "url": "/2021/01/03/941-Valid-Mountain-Array/"
      },
    
      {
        "title": "Powerful Integers",
        "excerpt": "&lt;-E 970&gt; Powerful Integers\n\nclass Solution {\npublic:\n    vector&lt;int&gt; powerfulIntegers(int x, int y, int bound) {\n        set&lt;int&gt; res;\n        deque&lt;pair&lt;int, int&gt;&gt; powers = {\n            {0,0}\n            };\n        while (!powers.empty()) {\n            auto [i, j] = powers.front();\n            int v = pow(x, i) + pow(y, j);\n            if (v &lt;= bound) {\n                if (x &gt; 1) powers.push_back({i+1, j});\n                if (y &gt; 1) powers.push_back({i, j+1});\n                res.insert(v);\n            }\n            powers.pop_front();\n        }\n        return vector&lt;int&gt;(res.begin(), res.end());\n    }\n};\n\n\n",
        "content": "&lt;-E 970&gt; Powerful Integers\n\nclass Solution {\npublic:\n    vector&lt;int&gt; powerfulIntegers(int x, int y, int bound) {\n        set&lt;int&gt; res;\n        deque&lt;pair&lt;int, int&gt;&gt; powers = {\n            {0,0}\n            };\n        while (!powers.empty()) {\n            auto [i, j] = powers.front();\n            int v = pow(x, i) + pow(y, j);\n            if (v &lt;= bound) {\n                if (x &gt; 1) powers.push_back({i+1, j});\n                if (y &gt; 1) powers.push_back({i, j+1});\n                res.insert(v);\n            }\n            powers.pop_front();\n        }\n        return vector&lt;int&gt;(res.begin(), res.end());\n    }\n};\n\n\n",
        "url": "/2021/01/03/970-Powerful-Integers/"
      },
    
      {
        "title": "CS50 Notes - Search",
        "excerpt": "00 Search\n\nFinding a solution to a problem, like a navigator app that finds the best route from your origin to the destination, or like playing a game and figuring out the next move.\n\nBasic terminology\n\n\n  \n    initial state\n\n    the state in which the agent begins\n\n    \n      agent\n    \n\n    entity that perceives its environment and acts upon that environment\n\n    \n      \n        state\n\n        a configuration of the agent and its environment\n      \n    \n  \n  \n    actions\n\n    choices that can be made in a state\n\n    \n      \n        actions\n\n        ACTIONS(s) returns the set of actions that can be executed in state s\n      \n    \n  \n  \n    transition model\n\n    a description of what state results from performing any applicable action in any state\n\n    RESULT(s, a) returns the state resulting from performing action a in state s\n\n    \n      \n        state space\n\n        the set of all states reachable from the initial state by any sequence of actions\n      \n    \n  \n  \n    goal test\n\n    way to determine whether a given state is a goal state\n  \n  \n    path cost\n\n    numerical cost associated with a given path\n  \n  \n    solution\n\n    a sequence of actions that leads from the initial state to a goal state\n  \n  \n    optimal solution\n\n    a solution that has the lowest path cost among all solutions\n  \n  \n    evaluation function\n\n    function that estimates the expected utility of the game from a given state\n  \n\n\nData structure\n\n\n  \n    node (Actually it is not a typical Data structure)\n\n    a data structure that keeps track of\n         - a state\n         - a parent (node that generated this node)\n         - an action (action applied to parent to get node)\n         - a path cost (from initial state to node)\n  \n  \n    stack\n\n    last-in first-out data type\n  \n  \n    queue\n\n    first-in first-out data type\n  \n\n\nuninformed search\n\nSearch strategy that uses no problem- specific knowledge.\n\nThey both are always work, and not necessarily a optimal solution.\n\nDFS depth-first search\n\nsearch algorithm that always expands the deepest node in the frontier, using stack.\n\n\n  \n    Pros:\nAt best, this algorithm is the fastest. If it “lucks out” and always chooses the right path to the solution (by chance), then depth-first search takes the least possible time to get to a solution.\n  \n  \n    Cons:\nIt is possible that the found solution is not optimal.\nAt worst, this algorithm will explore every possible path before finding the solution, thus taking the longest possible time before reaching the solution.\n  \n\n\n    # Define the function that removes a node from the frontier and returns it.\n    def remove(self):\n    \t  # Terminate the search if the frontier is empty, because this means that there is no solution.\n        if self.empty():\n            raise Exception(\"empty frontier\")\n        else:\n        \t  # Save the last item in the list (which is the newest node added)\n            node = self.frontier[-1]\n            # Save all the items on the list besides the last node (i.e. removing the last node)\n            self.frontier = self.frontier[:-1]\n            return node\n\n\nBFS breadth-first search\n\nsearch algorithm that always expands the shallowest node in the frontier, using queue.\n\n\n  \n    Pros:\nThis algorithm is guaranteed to find the optimal solution.\n  \n  \n    Cons:\nThis algorithm is almost guaranteed to take longer than the minimal time to run.\nAt worst, this algorithm takes the longest possible time to run.\n  \n\n\n# Define the function that removes a node from the frontier and returns it.\n    def remove(self):\n    \t  # Terminate the search if the frontier is empty, because this means that there is no solution.\n        if self.empty():\n            raise Exception(\"empty frontier\")\n        else:\n            # Save the oldest item on the list (which was the first one to be added)\n            node = self.frontier[0]\n            # Save all the items on the list besides the first one (i.e. removing the first node)\n            self.frontier = self.frontier[1:]\n            return node\n\n\ninformed search\n\nsearch strategy that uses problem-specific knowledge to find solutions more efficiently\n\n\n  greedy best-first search\n\n\nsearch algorithm that expands the node that is closest to the goal, as estimated by a heuristic function h(n)\n\nIt is important to emphasize that, as with any heuristic, it can go wrong and lead the algorithm down a slower path than it would have gone otherwise. It is possible that an uninformed search algorithm will provide a better solution faster, but it is less likely to do so than an informed algorithm.\n\n\n  A* search\n\n\nsearch algorithm that expands node with lowest value of g(n) + h(n)\n\ng(n) = cost to reach node h(n) = estimated cost to goal\n\noptimal if\n\nh(n) is admissible (never overestimates the true cost), and\nh(n) is consistent (for every node n and successor n' with step cost c, h(n) ≤ h(n') + c)\n\n\nAdversarial Search\n\nMinimax\n\nMinimax represents winning conditions as (-1) for one side and (+1) for the other side. Further actions will be driven by these conditions, with the minimizing side trying to get the lowest score, and the maximizer trying to get the highest score.\n\nRepresenting a Tic-Tac-Toe AI:\n\nS₀: Initial state (in our case, an empty 3X3 board)\n\nPlayers(s): a function that, given a state s, returns which player’s turn it is (X or O).\n\nActions(s): a function that, given a state s, return all the legal moves in this state (what spots are free on the board).\n\nResult(s, a): a function that, given a state s and action a, returns a new state. This is the board that resulted from \nperforming the action a on state s (making a move in the game).\n\nTerminal(s): a function that, given a state s, checks whether this is the last step in the game, i.e. if someone won or there is a tie. Returns True if the game has ended, False otherwise.\n\nUtility(s): a function that, given a terminal state s, returns the utility value of the state: -1, 0, or 1.\n\n\nAlpha-Beta Pruning\n\nAlpha-Beta Pruning skips some of the recursive computations that are decidedly unfavorable. After establishing the value of one action, if there is initial evidence that the following action can bring the opponent to get to a better score than the already established action, there is no need to further investigate this action because it will decidedly be less favorable than the previously established one.\n\nDepth-Limited Minimax\n\nconsiders only a pre-defined number of moves before it stops, without ever getting to a terminal state. However, this doesn’t allow for getting a precise value for each action, since the end of the hypothetical games has not been reached.\n\nTo deal with this problem, Depth-limited Minimax relies on an evaluation function that estimates the expected utility of the game from a given state, or, in other words, assigns values to states.\n\n",
        "content": "00 Search\n\nFinding a solution to a problem, like a navigator app that finds the best route from your origin to the destination, or like playing a game and figuring out the next move.\n\nBasic terminology\n\n\n  \n    initial state\n\n    the state in which the agent begins\n\n    \n      agent\n    \n\n    entity that perceives its environment and acts upon that environment\n\n    \n      \n        state\n\n        a configuration of the agent and its environment\n      \n    \n  \n  \n    actions\n\n    choices that can be made in a state\n\n    \n      \n        actions\n\n        ACTIONS(s) returns the set of actions that can be executed in state s\n      \n    \n  \n  \n    transition model\n\n    a description of what state results from performing any applicable action in any state\n\n    RESULT(s, a) returns the state resulting from performing action a in state s\n\n    \n      \n        state space\n\n        the set of all states reachable from the initial state by any sequence of actions\n      \n    \n  \n  \n    goal test\n\n    way to determine whether a given state is a goal state\n  \n  \n    path cost\n\n    numerical cost associated with a given path\n  \n  \n    solution\n\n    a sequence of actions that leads from the initial state to a goal state\n  \n  \n    optimal solution\n\n    a solution that has the lowest path cost among all solutions\n  \n  \n    evaluation function\n\n    function that estimates the expected utility of the game from a given state\n  \n\n\nData structure\n\n\n  \n    node (Actually it is not a typical Data structure)\n\n    a data structure that keeps track of\n         - a state\n         - a parent (node that generated this node)\n         - an action (action applied to parent to get node)\n         - a path cost (from initial state to node)\n  \n  \n    stack\n\n    last-in first-out data type\n  \n  \n    queue\n\n    first-in first-out data type\n  \n\n\nuninformed search\n\nSearch strategy that uses no problem- specific knowledge.\n\nThey both are always work, and not necessarily a optimal solution.\n\nDFS depth-first search\n\nsearch algorithm that always expands the deepest node in the frontier, using stack.\n\n\n  \n    Pros:\nAt best, this algorithm is the fastest. If it “lucks out” and always chooses the right path to the solution (by chance), then depth-first search takes the least possible time to get to a solution.\n  \n  \n    Cons:\nIt is possible that the found solution is not optimal.\nAt worst, this algorithm will explore every possible path before finding the solution, thus taking the longest possible time before reaching the solution.\n  \n\n\n    # Define the function that removes a node from the frontier and returns it.\n    def remove(self):\n    \t  # Terminate the search if the frontier is empty, because this means that there is no solution.\n        if self.empty():\n            raise Exception(\"empty frontier\")\n        else:\n        \t  # Save the last item in the list (which is the newest node added)\n            node = self.frontier[-1]\n            # Save all the items on the list besides the last node (i.e. removing the last node)\n            self.frontier = self.frontier[:-1]\n            return node\n\n\nBFS breadth-first search\n\nsearch algorithm that always expands the shallowest node in the frontier, using queue.\n\n\n  \n    Pros:\nThis algorithm is guaranteed to find the optimal solution.\n  \n  \n    Cons:\nThis algorithm is almost guaranteed to take longer than the minimal time to run.\nAt worst, this algorithm takes the longest possible time to run.\n  \n\n\n# Define the function that removes a node from the frontier and returns it.\n    def remove(self):\n    \t  # Terminate the search if the frontier is empty, because this means that there is no solution.\n        if self.empty():\n            raise Exception(\"empty frontier\")\n        else:\n            # Save the oldest item on the list (which was the first one to be added)\n            node = self.frontier[0]\n            # Save all the items on the list besides the first one (i.e. removing the first node)\n            self.frontier = self.frontier[1:]\n            return node\n\n\ninformed search\n\nsearch strategy that uses problem-specific knowledge to find solutions more efficiently\n\n\n  greedy best-first search\n\n\nsearch algorithm that expands the node that is closest to the goal, as estimated by a heuristic function h(n)\n\nIt is important to emphasize that, as with any heuristic, it can go wrong and lead the algorithm down a slower path than it would have gone otherwise. It is possible that an uninformed search algorithm will provide a better solution faster, but it is less likely to do so than an informed algorithm.\n\n\n  A* search\n\n\nsearch algorithm that expands node with lowest value of g(n) + h(n)\n\ng(n) = cost to reach node h(n) = estimated cost to goal\n\noptimal if\n\nh(n) is admissible (never overestimates the true cost), and\nh(n) is consistent (for every node n and successor n' with step cost c, h(n) ≤ h(n') + c)\n\n\nAdversarial Search\n\nMinimax\n\nMinimax represents winning conditions as (-1) for one side and (+1) for the other side. Further actions will be driven by these conditions, with the minimizing side trying to get the lowest score, and the maximizer trying to get the highest score.\n\nRepresenting a Tic-Tac-Toe AI:\n\nS₀: Initial state (in our case, an empty 3X3 board)\n\nPlayers(s): a function that, given a state s, returns which player’s turn it is (X or O).\n\nActions(s): a function that, given a state s, return all the legal moves in this state (what spots are free on the board).\n\nResult(s, a): a function that, given a state s and action a, returns a new state. This is the board that resulted from \nperforming the action a on state s (making a move in the game).\n\nTerminal(s): a function that, given a state s, checks whether this is the last step in the game, i.e. if someone won or there is a tie. Returns True if the game has ended, False otherwise.\n\nUtility(s): a function that, given a terminal state s, returns the utility value of the state: -1, 0, or 1.\n\n\nAlpha-Beta Pruning\n\nAlpha-Beta Pruning skips some of the recursive computations that are decidedly unfavorable. After establishing the value of one action, if there is initial evidence that the following action can bring the opponent to get to a better score than the already established action, there is no need to further investigate this action because it will decidedly be less favorable than the previously established one.\n\nDepth-Limited Minimax\n\nconsiders only a pre-defined number of moves before it stops, without ever getting to a terminal state. However, this doesn’t allow for getting a precise value for each action, since the end of the hypothetical games has not been reached.\n\nTo deal with this problem, Depth-limited Minimax relies on an evaluation function that estimates the expected utility of the game from a given state, or, in other words, assigns values to states.\n\n",
        "url": "/notes/2021/06/23/CS50_00_AI_NOTES/"
      },
    
      {
        "title": "CS50 Notes - Knowledge",
        "excerpt": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "content": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "url": "/notes/2021/06/24/CS50_01_AI_NOTES/"
      },
    
      {
        "title": "CS50 Notes",
        "excerpt": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "content": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "url": "/notes/2021/06/25/CS50_02_AI_NOTES/"
      },
    
      {
        "title": "CS50 Notes",
        "excerpt": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "content": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "url": "/notes/2021/06/26/CS50_03_AI_NOTES/"
      },
    
      {
        "title": "CS50 Notes",
        "excerpt": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "content": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "url": "/notes/2021/06/27/CS50_04_AI_NOTES/"
      },
    
      {
        "title": "CS50 Notes",
        "excerpt": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "content": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "url": "/notes/2021/06/28/CS50_05_AI_NOTES/"
      },
    
      {
        "title": "CS50 Notes",
        "excerpt": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "content": "01 Knowledge\n\nRepresenting information and drawing inferences from it.\n\nBasic terminology\n\n\n  \n    knowledge-based agents\n\n    agents that reason by operating on internal representations of knowledge\n  \n  \n    sentence\n\n    an assertion about the world in a knowledge representation language\n  \n  \n    model\n\n    assignment of a truth value to every propositional symbol (a “possible world”)\n  \n  \n    knowledge base\n\n    a set of sentences known by a knowledge-based agent\n  \n  \n    inference\n\n    the process of deriving new sentences from old ones\n  \n\n\n",
        "url": "/notes/2021/06/29/CS50_06_AI_NOTES/"
      },
    
      {
        "title": "Study of R",
        "excerpt": "01 Basic\n\n下载数据集\n\nR 内置了很多的数据。 再练习的时候，往往可以使用R 自己提供的数据，这些数据是一些真实的数据，可以当作学习/练习的样本。\n\n代码的格式如下：\n(这里的代码是要打进console 之中)\n# installing the dslabs package\ninstall.packages(\"dslabs\")\n\n\n\n\n使用这个数据\n（这里的代码要打进xxx.r 文件之中）\n# loading the dslabs package into the R session\nlibrary(dslabs)\n\n\n或者使用 GUI （用鼠标点点点）\n\n[Tools] -&gt; [install packages]\n\n\ninstall.packages(\"dslabs\")  # to install a single package\ninstall.packages(c(\"tidyverse\", \"dslabs\")） # to install two packages at the same time\n# 注意这里的c\ninstalled.packages() # to see the list of all installed packages\n\n\n画图-ggplot2\n\n以下例子使用 tidyverse 的数据\n\n创建一个图表\n\nmpg: US Environment Protection Agency on 38 models of cars\nmpg 是 tidyverse 中的一个数据子集合。\n单独在console 里打出 mpg 可以查看他的数据格式\n\n\n\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy))\n# 选择其中的列 displ 和 列 hwy 作为 x 轴 和 y 轴数据\n\n\nggplot(data = mpg) 创建了一个空的图标画布。 geom_point() 让R 知道以什么样的方式绘制图像。\n\naes() specify which variable to map the x and y-axes.\n\n以下需要特别记忆：\n\nggplot(data = &lt;DATA&gt;) + &lt;Geom_FUNCTION&gt;(mapping = aes(MAPPINGS))\n\n\naes 中有很多参数，不单单是 x， y  还有size 和 color 等具体控制画图的参数。\n比如，\n\n\n  可以根据数据的大小，使用size 参数， 数据不同，点的面积也不同\n  可以根据数据的大小，使用alpha 参数， 数据不同，使用不同的深浅颜色\n  可以根据数据的大小，使用color 参数， 数据不同，使用不同的颜色\n  可以根据数据的大小，使用shape 参数， 数据不同，使用不同的形状表示\n\n\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = class))\n# 这里是使用class 来进行区分\n\n一定记住 aes 里修改的是 mappings 的设置。如果想修改点的颜色。则不能错误的把color 放进aes 函数中。\n\n正确的写法是： (修改为蓝色)\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = \"blue\")\n\n\n错误的写法\n\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))\n\n聪明的小伙伴肯定知道了 错误写法中里的color 是设置了错误的凡例名称。如图所示：\n\n",
        "content": "01 Basic\n\n下载数据集\n\nR 内置了很多的数据。 再练习的时候，往往可以使用R 自己提供的数据，这些数据是一些真实的数据，可以当作学习/练习的样本。\n\n代码的格式如下：\n(这里的代码是要打进console 之中)\n# installing the dslabs package\ninstall.packages(\"dslabs\")\n\n\n\n\n使用这个数据\n（这里的代码要打进xxx.r 文件之中）\n# loading the dslabs package into the R session\nlibrary(dslabs)\n\n\n或者使用 GUI （用鼠标点点点）\n\n[Tools] -&gt; [install packages]\n\n\ninstall.packages(\"dslabs\")  # to install a single package\ninstall.packages(c(\"tidyverse\", \"dslabs\")） # to install two packages at the same time\n# 注意这里的c\ninstalled.packages() # to see the list of all installed packages\n\n\n画图-ggplot2\n\n以下例子使用 tidyverse 的数据\n\n创建一个图表\n\nmpg: US Environment Protection Agency on 38 models of cars\nmpg 是 tidyverse 中的一个数据子集合。\n单独在console 里打出 mpg 可以查看他的数据格式\n\n\n\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy))\n# 选择其中的列 displ 和 列 hwy 作为 x 轴 和 y 轴数据\n\n\nggplot(data = mpg) 创建了一个空的图标画布。 geom_point() 让R 知道以什么样的方式绘制图像。\n\naes() specify which variable to map the x and y-axes.\n\n以下需要特别记忆：\n\nggplot(data = &lt;DATA&gt;) + &lt;Geom_FUNCTION&gt;(mapping = aes(MAPPINGS))\n\n\naes 中有很多参数，不单单是 x， y  还有size 和 color 等具体控制画图的参数。\n比如，\n\n\n  可以根据数据的大小，使用size 参数， 数据不同，点的面积也不同\n  可以根据数据的大小，使用alpha 参数， 数据不同，使用不同的深浅颜色\n  可以根据数据的大小，使用color 参数， 数据不同，使用不同的颜色\n  可以根据数据的大小，使用shape 参数， 数据不同，使用不同的形状表示\n\n\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = class))\n# 这里是使用class 来进行区分\n\n一定记住 aes 里修改的是 mappings 的设置。如果想修改点的颜色。则不能错误的把color 放进aes 函数中。\n\n正确的写法是： (修改为蓝色)\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = \"blue\")\n\n\n错误的写法\n\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))\n\n聪明的小伙伴肯定知道了 错误写法中里的color 是设置了错误的凡例名称。如图所示：\n\n",
        "url": "/notes/2021/07/14/R_NOTES/"
      },
    
      {
        "title": "Study of GO",
        "excerpt": "学习 Go 的笔记\n\n变量\n\n强类型和弱类型都可以支持\n\n赋值 - 强类型\n\n//var 变量名 变量类型 = 值\nvar i int = 1\n\n\n赋值 - 弱类型\n\n//变量名 := 值\ni := 1\n\n\n根据值来判断类型，所以必须初始化\n\n变量类型\n\n\n  bool\n  string\n  int, int8, int16, int32, int64\n  uint, uint8, uint16, uint32, uint64\n  byte = unit8\n  rune = int32(uncode code point)\n  float32, float64\n  complex32, complex64 (虚数)\n\n\n格式控制\n\n\n  %T （要大写）\n\n\nconst\n\n// const 变量名 = 值\nconst i = 1\n\n//这里没有:\n\n指明变量类型是可选的\n\nconst 变量名 变量类型 = 值\n\n\nconst 可以 使用（） 形式，同时声明多个变量。\n\nfor 和 while\n\n\n  for\n\n\n普通 for\nfor i := 0; i &lt; 10; i++ {\n  // 这里不需要园括号\n}\n\n\n\n  while\n\n\nGo 里的 while 是直接使用同一个关键词 for\ni := 1\nfor i &lt; 100 {\n  //这里不需要使用分号\n}\n\n\n\n  forever loop\n\n\nfor {\n\n}\n\n\nif\n\nif x &lt; 0 {\n\n}\n\nif v:=math.pow(x, n); v &lt; lim {\n  //可以提前赋值\n}\n\nif 条件表达式 {\n\n} else {\n\n}\n\n\nswitch\n\nswitch 赋值; 变量 {\n    case label:\n    default:\n}\n// label 可以做运算， 比如： \n// case label + 0:\n\n\nswitch {\n  case 条件表达式：\n  case 条件表达式：\n}\n\n// 可以等价的看做一堆if else 的集合\n\n\ndefer\n\nstruct\n\ntype Vertex struct {\n\tX int\n\tY int\n\tZ float32\n}\n\n\n和C差不多。 取消了 -&gt; 访问都是.\n\n以后都是用Vertex 作为变量的名称\n如果都没有初始化，那么会提供默认初始化为0。 但是有了一个初始化后，使用 变量初始化 没事。\n\ntype Vertex struct {\n\tX, Y int\n}\nv2 = Vertex{X: 189}  // Y:0 is implicit, 结果是 189， 0\n\n\n如果不使用变量如：\n\nVertex{1}\n// 会报错\n\n\nArrays\n\nvar 变量名[数组大小] 变量类型\n\nvar a [10]int\n// 显示声明\n\n变量名:= [数组大小] 变量类型 {值} // 值为空或者少于大小都可\nprimes := [6]int{2, 3, 5, 7, 11, 13}\n\n\nSlices\n\n切片 同python\n",
        "content": "学习 Go 的笔记\n\n变量\n\n强类型和弱类型都可以支持\n\n赋值 - 强类型\n\n//var 变量名 变量类型 = 值\nvar i int = 1\n\n\n赋值 - 弱类型\n\n//变量名 := 值\ni := 1\n\n\n根据值来判断类型，所以必须初始化\n\n变量类型\n\n\n  bool\n  string\n  int, int8, int16, int32, int64\n  uint, uint8, uint16, uint32, uint64\n  byte = unit8\n  rune = int32(uncode code point)\n  float32, float64\n  complex32, complex64 (虚数)\n\n\n格式控制\n\n\n  %T （要大写）\n\n\nconst\n\n// const 变量名 = 值\nconst i = 1\n\n//这里没有:\n\n指明变量类型是可选的\n\nconst 变量名 变量类型 = 值\n\n\nconst 可以 使用（） 形式，同时声明多个变量。\n\nfor 和 while\n\n\n  for\n\n\n普通 for\nfor i := 0; i &lt; 10; i++ {\n  // 这里不需要园括号\n}\n\n\n\n  while\n\n\nGo 里的 while 是直接使用同一个关键词 for\ni := 1\nfor i &lt; 100 {\n  //这里不需要使用分号\n}\n\n\n\n  forever loop\n\n\nfor {\n\n}\n\n\nif\n\nif x &lt; 0 {\n\n}\n\nif v:=math.pow(x, n); v &lt; lim {\n  //可以提前赋值\n}\n\nif 条件表达式 {\n\n} else {\n\n}\n\n\nswitch\n\nswitch 赋值; 变量 {\n    case label:\n    default:\n}\n// label 可以做运算， 比如： \n// case label + 0:\n\n\nswitch {\n  case 条件表达式：\n  case 条件表达式：\n}\n\n// 可以等价的看做一堆if else 的集合\n\n\ndefer\n\nstruct\n\ntype Vertex struct {\n\tX int\n\tY int\n\tZ float32\n}\n\n\n和C差不多。 取消了 -&gt; 访问都是.\n\n以后都是用Vertex 作为变量的名称\n如果都没有初始化，那么会提供默认初始化为0。 但是有了一个初始化后，使用 变量初始化 没事。\n\ntype Vertex struct {\n\tX, Y int\n}\nv2 = Vertex{X: 189}  // Y:0 is implicit, 结果是 189， 0\n\n\n如果不使用变量如：\n\nVertex{1}\n// 会报错\n\n\nArrays\n\nvar 变量名[数组大小] 变量类型\n\nvar a [10]int\n// 显示声明\n\n变量名:= [数组大小] 变量类型 {值} // 值为空或者少于大小都可\nprimes := [6]int{2, 3, 5, 7, 11, 13}\n\n\nSlices\n\n切片 同python\n",
        "url": "/notes/2021/12/17/GO_NOTES/"
      },
    
      {
        "title": "Study of Python",
        "excerpt": "01 Basic\n\n# 等待补全\n\n",
        "content": "01 Basic\n\n# 等待补全\n\n",
        "url": "/notes/2021/12/17/Python_NOTES/"
      },
    
      {
        "title": "Binary Tree Preorder Traversal",
        "excerpt": "&lt;-E 144&gt; Binary Tree Preorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    void preorder(vector&lt;int&gt;&amp;res,TreeNode* root)\n    {\n        if(root == NULL)\n            return;\n        res.push_back(root-&gt;val);\n        preorder(res,root-&gt;left);\n        preorder(res,root-&gt;right);\n        \n    }\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt;res;\n        preorder(res, root);\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 144&gt; Binary Tree Preorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    void preorder(vector&lt;int&gt;&amp;res,TreeNode* root)\n    {\n        if(root == NULL)\n            return;\n        res.push_back(root-&gt;val);\n        preorder(res,root-&gt;left);\n        preorder(res,root-&gt;right);\n        \n    }\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt;res;\n        preorder(res, root);\n        return res;\n    }\n};\n\n\n",
        "url": "/2022/03/26/144-Binary-Tree-Preorder-Traversal/"
      },
    
      {
        "title": "Binary Tree Postorder Traversal",
        "excerpt": "&lt;-E 145&gt; Binary Tree Postorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void postorder(vector&lt;int&gt;&amp;res,TreeNode* root)\n    {\n        if(root == NULL)\n            return;\n        postorder(res,root-&gt;left);\n        postorder(res,root-&gt;right);\n        res.push_back(root-&gt;val);\n    }\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        vector&lt;int&gt;res;\n        postorder(res,root);\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 145&gt; Binary Tree Postorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void postorder(vector&lt;int&gt;&amp;res,TreeNode* root)\n    {\n        if(root == NULL)\n            return;\n        postorder(res,root-&gt;left);\n        postorder(res,root-&gt;right);\n        res.push_back(root-&gt;val);\n    }\n    vector&lt;int&gt; postorderTraversal(TreeNode* root) {\n        vector&lt;int&gt;res;\n        postorder(res,root);\n        return res;\n    }\n};\n\n\n",
        "url": "/2022/03/26/145-Binary-Tree-Postorder-Traversal/"
      },
    
      {
        "title": "Binary Tree Inorder Traversal",
        "excerpt": "&lt;-E 94&gt; Binary Tree Inorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void inorder(TreeNode* root, vector&lt;int&gt; &amp;node)\n    {\n        if(root ==NULL)\n            return;\n        inorder(root-&gt;left,node);\n        node.push_back(root-&gt;val);\n        inorder(root-&gt;right,node);\n    }\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; node;\n        \n        inorder(root,node);\n        \n        return node;\n    }\n};\n\n\n\n(a) Inorder (Left, Root, Right) \n(b) Preorder (Root, Left, Right) \n(c) Postorder (Left, Right, Root)\n\n",
        "content": "&lt;-E 94&gt; Binary Tree Inorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void inorder(TreeNode* root, vector&lt;int&gt; &amp;node)\n    {\n        if(root ==NULL)\n            return;\n        inorder(root-&gt;left,node);\n        node.push_back(root-&gt;val);\n        inorder(root-&gt;right,node);\n    }\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; node;\n        \n        inorder(root,node);\n        \n        return node;\n    }\n};\n\n\n\n(a) Inorder (Left, Root, Right) \n(b) Preorder (Root, Left, Right) \n(c) Postorder (Left, Right, Root)\n\n",
        "url": "/2022/03/26/94-Binary-Tree-Inorder-Traversal/"
      },
    
      {
        "title": "Check If All 1's Are at Least Length K Places Away",
        "excerpt": "&lt;-E 1437&gt; Check If All 1’s Are at Least Length K Places Away\n\nclass Solution {\npublic:\n    bool kLengthApart(vector&lt;int&gt;&amp; nums, int k) {\n        int pre = -100000;\n        \n        for(int i = 0; i &lt; nums.size(); i++) { \n            if(nums[i] == 1 ) {                \n                if(i - pre - 1 &lt; k) return false;\n                pre = i;                \n            }            \n        }\n        \n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 1437&gt; Check If All 1’s Are at Least Length K Places Away\n\nclass Solution {\npublic:\n    bool kLengthApart(vector&lt;int&gt;&amp; nums, int k) {\n        int pre = -100000;\n        \n        for(int i = 0; i &lt; nums.size(); i++) { \n            if(nums[i] == 1 ) {                \n                if(i - pre - 1 &lt; k) return false;\n                pre = i;                \n            }            \n        }\n        \n        return true;\n    }\n};\n\n\n",
        "url": "/2022/04/07/1437-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/"
      },
    
      {
        "title": "Counting Bits",
        "excerpt": "&lt;-E 338&gt; Counting Bits\n\nclass Solution {\npublic:\n    vector&lt;int&gt; countBits(int n) {\n        vector&lt;int&gt; t(n+1, 0);\n        \n        for(int i = 1; i &lt;= n; ++i)\n            t[i] = t[i/2] + i%2;\n        \n        return t;\n    }\n};\n\n\n",
        "content": "&lt;-E 338&gt; Counting Bits\n\nclass Solution {\npublic:\n    vector&lt;int&gt; countBits(int n) {\n        vector&lt;int&gt; t(n+1, 0);\n        \n        for(int i = 1; i &lt;= n; ++i)\n            t[i] = t[i/2] + i%2;\n        \n        return t;\n    }\n};\n\n\n",
        "url": "/2022/04/07/338-Counting-Bits/"
      },
    
      {
        "title": "Teemo Attacking",
        "excerpt": "&lt;-E 495&gt; Teemo Attacking\n\nclass Solution {\npublic:\n    int findPoisonedDuration(vector&lt;int&gt;&amp; timeSeries, int duration) {\n        int cnt = 0;\n        int n = timeSeries.size();\n        for(int i = 0; i &lt; n-1;++i){\n             if(timeSeries[i] + duration &lt;= timeSeries[i+1]){\n                cnt += duration;\n            }\n            else{\n                cnt+= (timeSeries[i+1] - timeSeries[i]);\n            }\n        }\n        cnt += duration;\n        return cnt;\n    }\n};\n\n\n",
        "content": "&lt;-E 495&gt; Teemo Attacking\n\nclass Solution {\npublic:\n    int findPoisonedDuration(vector&lt;int&gt;&amp; timeSeries, int duration) {\n        int cnt = 0;\n        int n = timeSeries.size();\n        for(int i = 0; i &lt; n-1;++i){\n             if(timeSeries[i] + duration &lt;= timeSeries[i+1]){\n                cnt += duration;\n            }\n            else{\n                cnt+= (timeSeries[i+1] - timeSeries[i]);\n            }\n        }\n        cnt += duration;\n        return cnt;\n    }\n};\n\n\n",
        "url": "/2022/04/07/495-Teemo-Attacking/"
      },
    
      {
        "title": "Maximum Units on a Truck",
        "excerpt": "&lt;-E 1710&gt; Maximum Units on a Truck\n\nclass Solution {\npublic:\n    int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) {\n        int n = boxTypes.size();\n        int ans = 0;\n        int sum = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; v;\n        \n        for (int i = 0; i &lt; n; i++)\n            v.push_back({boxTypes[i][1], boxTypes[i][0]});\n        \n        sort(v.begin(), v.end(), greater&lt;&gt;());\n        \n        for (int i = 0; i &lt; n; i++) {\n            auto [units, cnt] = v[i];\n            if (sum + cnt &gt; truckSize) {\n                ans += (truckSize - sum) * units;\n                break;\n            }\n            sum += cnt;\n            ans += units * cnt;\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1710&gt; Maximum Units on a Truck\n\nclass Solution {\npublic:\n    int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) {\n        int n = boxTypes.size();\n        int ans = 0;\n        int sum = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; v;\n        \n        for (int i = 0; i &lt; n; i++)\n            v.push_back({boxTypes[i][1], boxTypes[i][0]});\n        \n        sort(v.begin(), v.end(), greater&lt;&gt;());\n        \n        for (int i = 0; i &lt; n; i++) {\n            auto [units, cnt] = v[i];\n            if (sum + cnt &gt; truckSize) {\n                ans += (truckSize - sum) * units;\n                break;\n            }\n            sum += cnt;\n            ans += units * cnt;\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "url": "/2022/04/08/1710-Maximum-Units-on-a-Truck/"
      },
    
      {
        "title": "Calculate Money in Leetcode Bank",
        "excerpt": "&lt;-E 1716&gt; Calculate Money in Leetcode Bank\n\nclass Solution {\npublic:\n    int totalMoney(int n) {\n        int total{0};\n        int week{1}, accrue{1};\n        \n        for(int i{1}; i &lt;= n; i++){\n            if(i - 1 == 7 * week){\n                ++week;\n                accrue = week;\n            }\n            \n            total += accrue;\n            accrue++;\n        } \n        return total;       \n    }\n};\n\n\n",
        "content": "&lt;-E 1716&gt; Calculate Money in Leetcode Bank\n\nclass Solution {\npublic:\n    int totalMoney(int n) {\n        int total{0};\n        int week{1}, accrue{1};\n        \n        for(int i{1}; i &lt;= n; i++){\n            if(i - 1 == 7 * week){\n                ++week;\n                accrue = week;\n            }\n            \n            total += accrue;\n            accrue++;\n        } \n        return total;       \n    }\n};\n\n\n",
        "url": "/2022/04/08/1716-Calculate-Money-in-Leetcode-Bank/"
      },
    
      {
        "title": "Decode XORed Array",
        "excerpt": "&lt;-E 1720&gt; Decode XORed Array\n\nclass Solution {\npublic:\n    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded, int first) {\n        vector&lt;int&gt; v;\n        v.push_back(first);  \n        for(auto i : encoded){\n            int s = v.back() ^ i;  \n            v.push_back(s);  \n        }\n        return v;\n    }\n};\n\n\n",
        "content": "&lt;-E 1720&gt; Decode XORed Array\n\nclass Solution {\npublic:\n    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded, int first) {\n        vector&lt;int&gt; v;\n        v.push_back(first);  \n        for(auto i : encoded){\n            int s = v.back() ^ i;  \n            v.push_back(s);  \n        }\n        return v;\n    }\n};\n\n\n",
        "url": "/2022/04/08/1720-Decode-XORed-Array/"
      },
    
      {
        "title": "Number Of Rectangles That Can Form The Largest Square",
        "excerpt": "&lt;-E 1725&gt; Number Of Rectangles That Can Form The Largest Square\n\n//method 1\nclass Solution {\npublic:\n    int countGoodRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) {\n        vector &lt;int&gt; v;\n        int s = rectangles.size();\n        for (int i = 0; i&lt;s; i++){\n            int t = min(rectangles[i][0],rectangles[i][1]);\n                v.push_back(t);\n        }\n        sort(v.begin(), v.end());\n        int res = 0;\n        for (int i = 0; i &lt; v.size(); i++) {\n            if (v[i] == v[v.size() - 1]) \n                res++;\n        }\n        return res;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    int countGoodRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) {\n        int mx = 0;\n        int c = 0;\n        for(auto i : rectangles){\n            int l = min(i[0], i[1]);\n            if(l == mx)\n                c++;\n            else if(l &gt; mx) {\n                mx = l;\n                c = 1;\n            }\n        }\n        return c;\n    }\n};\n\n\n",
        "content": "&lt;-E 1725&gt; Number Of Rectangles That Can Form The Largest Square\n\n//method 1\nclass Solution {\npublic:\n    int countGoodRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) {\n        vector &lt;int&gt; v;\n        int s = rectangles.size();\n        for (int i = 0; i&lt;s; i++){\n            int t = min(rectangles[i][0],rectangles[i][1]);\n                v.push_back(t);\n        }\n        sort(v.begin(), v.end());\n        int res = 0;\n        for (int i = 0; i &lt; v.size(); i++) {\n            if (v[i] == v[v.size() - 1]) \n                res++;\n        }\n        return res;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    int countGoodRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) {\n        int mx = 0;\n        int c = 0;\n        for(auto i : rectangles){\n            int l = min(i[0], i[1]);\n            if(l == mx)\n                c++;\n            else if(l &gt; mx) {\n                mx = l;\n                c = 1;\n            }\n        }\n        return c;\n    }\n};\n\n\n",
        "url": "/2022/04/08/1725-Number-Of-Rectangles-That-Can-Form-The-Largest-Square/"
      },
    
      {
        "title": "Find the Highest Altitude",
        "excerpt": "&lt;-E 1732&gt; Find the Highest Altitude\n\n//method 1\nclass Solution {\npublic:\n    int largestAltitude(vector&lt;int&gt;&amp; gain) {\n        int result = 0;        \n        int sum = 0;\n        for(int i = 0; i &lt; gain.size(); ++i) {\n            sum += gain[i];\n            result = max(result, sum);\n        }\n        \n        return result;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    int largestAltitude(vector&lt;int&gt;&amp; gain) {\n        int sum  = 0;\n        int maxi = 0; \n        for(auto g : gain) {\n            sum += g;\n            if(sum &gt; maxi) {\n                maxi = sum;\n            }\n        }\n        \n        return maxi;\n    }\n};\n\n\n",
        "content": "&lt;-E 1732&gt; Find the Highest Altitude\n\n//method 1\nclass Solution {\npublic:\n    int largestAltitude(vector&lt;int&gt;&amp; gain) {\n        int result = 0;        \n        int sum = 0;\n        for(int i = 0; i &lt; gain.size(); ++i) {\n            sum += gain[i];\n            result = max(result, sum);\n        }\n        \n        return result;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    int largestAltitude(vector&lt;int&gt;&amp; gain) {\n        int sum  = 0;\n        int maxi = 0; \n        for(auto g : gain) {\n            sum += g;\n            if(sum &gt; maxi) {\n                maxi = sum;\n            }\n        }\n        \n        return maxi;\n    }\n};\n\n\n",
        "url": "/2022/04/09/1732-Find-the-Highest-Altitude/"
      },
    
      {
        "title": "Latest Time by Replacing Hidden Digits",
        "excerpt": "&lt;-E 1736&gt; Latest Time by Replacing Hidden Digits\n\nclass Solution {\npublic:\n    string maximumTime(string time) {\n        if(time[0] == '?' and time[1]&gt;='0' and time[1]&lt;='3') \n            time[0] = '2';\n        \n        if(time[0] == '?' and time[1]&gt;='4' and time[1]!='?') \n            time[0] = '1';\n        \n        if(time[0] == '?' and time[1] == '?') {\n            time[0] = '2';\n            time[1] = '3';\n        }\n        \n        \n        if(time[1] == '?' and time[0] == '2') {\n            time[1] = '3';\n        }\n        \n        if(time[1] == '?' and time[0]!='2') \n            time[1] = '9';\n        \n        if(time[3] == '?') \n            time[3] = '5';\n\n        if(time[4] == '?') \n            time[4] = '9';\n        \n        return time;\n    }\n};\n\n\n",
        "content": "&lt;-E 1736&gt; Latest Time by Replacing Hidden Digits\n\nclass Solution {\npublic:\n    string maximumTime(string time) {\n        if(time[0] == '?' and time[1]&gt;='0' and time[1]&lt;='3') \n            time[0] = '2';\n        \n        if(time[0] == '?' and time[1]&gt;='4' and time[1]!='?') \n            time[0] = '1';\n        \n        if(time[0] == '?' and time[1] == '?') {\n            time[0] = '2';\n            time[1] = '3';\n        }\n        \n        \n        if(time[1] == '?' and time[0] == '2') {\n            time[1] = '3';\n        }\n        \n        if(time[1] == '?' and time[0]!='2') \n            time[1] = '9';\n        \n        if(time[3] == '?') \n            time[3] = '5';\n\n        if(time[4] == '?') \n            time[4] = '9';\n        \n        return time;\n    }\n};\n\n\n",
        "url": "/2022/04/09/1736-Latest-Time-by-Replacing-Hidden-Digits/"
      },
    
      {
        "title": "Maximum Number of Balls in a Box",
        "excerpt": "&lt;-E 1742&gt; Maximum Number of Balls in a Box\n\nclass Solution {\npublic:\n    int countBalls(int lowLimit, int highLimit) {\n        int ans = 0;\n        vector&lt;int&gt; v(46,0);\n        for(int i = lowLimit; i &lt;= highLimit; i++){\n            int s = 0, n = i;\n            while(n) {\n                s += n % 10;\n                n /= 10;\n            }    \n            v[s]++;\n        }\n\n        for(int i =1;i&lt;v.size();i++){\n            ans = max(ans,v[i]);\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1742&gt; Maximum Number of Balls in a Box\n\nclass Solution {\npublic:\n    int countBalls(int lowLimit, int highLimit) {\n        int ans = 0;\n        vector&lt;int&gt; v(46,0);\n        for(int i = lowLimit; i &lt;= highLimit; i++){\n            int s = 0, n = i;\n            while(n) {\n                s += n % 10;\n                n /= 10;\n            }    \n            v[s]++;\n        }\n\n        for(int i =1;i&lt;v.size();i++){\n            ans = max(ans,v[i]);\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2022/04/09/1742-Maximum-Number-of-Balls-in-a-Box/"
      },
    
      {
        "title": "Sum of Unique Elements",
        "excerpt": "&lt;-E 1748&gt; Sum of Unique Elements\n\n//method 1\nclass Solution {\npublic:\n    int sumOfUnique(vector&lt;int&gt;&amp; nums) {\n        int sum = 0;\n        for(auto i : nums){\n            if(count(nums.begin(),nums.end(),i)==1) {\n                sum += i;\n            }\n        }\n    return sum;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    int sumOfUnique(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int,int&gt; mp;\n        for(auto i : nums){\n            mp[i]++;\n        }\n        int count = 0;\n        for(auto i : mp){\n            if(i.second &lt; 2)\n                count += i.first;\n        }\n        return count;\n    }\n};\n\n\n",
        "content": "&lt;-E 1748&gt; Sum of Unique Elements\n\n//method 1\nclass Solution {\npublic:\n    int sumOfUnique(vector&lt;int&gt;&amp; nums) {\n        int sum = 0;\n        for(auto i : nums){\n            if(count(nums.begin(),nums.end(),i)==1) {\n                sum += i;\n            }\n        }\n    return sum;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    int sumOfUnique(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int,int&gt; mp;\n        for(auto i : nums){\n            mp[i]++;\n        }\n        int count = 0;\n        for(auto i : mp){\n            if(i.second &lt; 2)\n                count += i.first;\n        }\n        return count;\n    }\n};\n\n\n",
        "url": "/2022/04/09/1748-Sum-of-Unique-Elements/"
      },
    
      {
        "title": "Check if Array Is Sorted and Rotated",
        "excerpt": "&lt;-E 1752&gt; Check if Array Is Sorted and Rotated\n\nclass Solution {\npublic:\n    bool check(vector&lt;int&gt;&amp; nums) {\n        int count = 0;\n        int n = nums.size();\n        \n        if(nums[n-1] &gt; nums[0])\n            count++;\n    \n        for(int i = 0; i &lt; n-1; i++){\n            if(nums[i] &gt; nums[i+1])\n                count++;\n        }\n        return count&lt;=1;\n    }\n};\n\n\n",
        "content": "&lt;-E 1752&gt; Check if Array Is Sorted and Rotated\n\nclass Solution {\npublic:\n    bool check(vector&lt;int&gt;&amp; nums) {\n        int count = 0;\n        int n = nums.size();\n        \n        if(nums[n-1] &gt; nums[0])\n            count++;\n    \n        for(int i = 0; i &lt; n-1; i++){\n            if(nums[i] &gt; nums[i+1])\n                count++;\n        }\n        return count&lt;=1;\n    }\n};\n\n\n",
        "url": "/2022/04/10/1752-Check-if-Array-Is-Sorted-and-Rotated/"
      },
    
      {
        "title": "Minimum Changes To Make Alternating Binary String",
        "excerpt": "&lt;-E 1758&gt; Minimum Changes To Make Alternating Binary String\n\n//method 1\nclass Solution {\npublic:\n    int minOperations(string s) {\n        int count = 0, ans = 0;\n        for (int i = 0; i &lt; s.size(); i++) {\n            if(i % 2 == 0) {\n                if(s[i] == '1')\n                    ans++;\n                 else \n                    count++;\n            }\n            else {\n                if(s[i] == '0')\n                    ans++;\n                 else \n                    count++;\n            }\n        }\n        return count &lt; ans ? count : ans;\n    }\n};\n//method 2\nclass Solution {\npublic:\n    int minOperations(string s) {\n        int ch1 = 0,ch2 = 0;\n        for(int i = 0; i &lt; s.size(); i++)\n            if((i % 2 &amp;&amp; s[i] == '0') || i % 2 == 0 &amp;&amp; s[i] == '1')\n                ch1++;        \n        for(int i = 0; i &lt; s.size(); i++)\n            if((i % 2 &amp;&amp; s[i] == '1') || i % 2 == 0 &amp;&amp; s[i] == '0')\n                ch2++;\n        return min(ch1,ch2);\n    }\n};\n\n\n",
        "content": "&lt;-E 1758&gt; Minimum Changes To Make Alternating Binary String\n\n//method 1\nclass Solution {\npublic:\n    int minOperations(string s) {\n        int count = 0, ans = 0;\n        for (int i = 0; i &lt; s.size(); i++) {\n            if(i % 2 == 0) {\n                if(s[i] == '1')\n                    ans++;\n                 else \n                    count++;\n            }\n            else {\n                if(s[i] == '0')\n                    ans++;\n                 else \n                    count++;\n            }\n        }\n        return count &lt; ans ? count : ans;\n    }\n};\n//method 2\nclass Solution {\npublic:\n    int minOperations(string s) {\n        int ch1 = 0,ch2 = 0;\n        for(int i = 0; i &lt; s.size(); i++)\n            if((i % 2 &amp;&amp; s[i] == '0') || i % 2 == 0 &amp;&amp; s[i] == '1')\n                ch1++;        \n        for(int i = 0; i &lt; s.size(); i++)\n            if((i % 2 &amp;&amp; s[i] == '1') || i % 2 == 0 &amp;&amp; s[i] == '0')\n                ch2++;\n        return min(ch1,ch2);\n    }\n};\n\n\n",
        "url": "/2022/04/10/1758-Minimum-Changes-To-Make-Alternating-Binary-String/"
      },
    
      {
        "title": "Longest Nice Substring",
        "excerpt": "&lt;-E 1763&gt; Longest Nice Substring\n\n//method 1\nclass Solution {\npublic:\n    string longestNiceSubstring(string s) {\n        if(s.size() &lt; 2)\n            return \"\";\n        unordered_set&lt;char&gt;st(s.begin(),s.end());\n        for(int i = 0; i &lt; s.size(); i++){\n            if(!st.count(toupper(s[i])) || !st.count(tolower(s[i]))) {\n                string s1 = longestNiceSubstring(s.substr(0, i));\n                string s2 = longestNiceSubstring(s.substr(i + 1));\n                return s1.size() &gt;= s2.size() ? s1 : s2;\n            }\n        }\n        return s;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    string longestNiceSubstring(string s) {\n        int n = s.size();\n        if(n&lt;2) return \"\";\n        bool seen[128];\n        \n        int maxLength = 0, startIndex = 0;\n        \n        for(int i = 0; i &lt; n; i++){\n            memset(seen, false, 128);\n            int oddAlpha = 0;\n            for(int j = i; j &lt; n; j++){\n                char cur = s[j];\n                \n                if(!seen[cur]) {\n                    seen[cur] = true;\n                    if(seen[ cur ^ 32 ]){ // ^ 32: upper &lt;-&gt; lower\n                        oddAlpha--;\n                    } else {\n                        oddAlpha++;\n                    }\n                }\n                if(oddAlpha==0 &amp;&amp; j-i+1 &gt; maxLength){\n                    maxLength = j-i+1;\n                    startIndex = i;\n                }\n            } \n        }\n        return s.substr(startIndex, maxLength);\n    }\n};\n\n\n",
        "content": "&lt;-E 1763&gt; Longest Nice Substring\n\n//method 1\nclass Solution {\npublic:\n    string longestNiceSubstring(string s) {\n        if(s.size() &lt; 2)\n            return \"\";\n        unordered_set&lt;char&gt;st(s.begin(),s.end());\n        for(int i = 0; i &lt; s.size(); i++){\n            if(!st.count(toupper(s[i])) || !st.count(tolower(s[i]))) {\n                string s1 = longestNiceSubstring(s.substr(0, i));\n                string s2 = longestNiceSubstring(s.substr(i + 1));\n                return s1.size() &gt;= s2.size() ? s1 : s2;\n            }\n        }\n        return s;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    string longestNiceSubstring(string s) {\n        int n = s.size();\n        if(n&lt;2) return \"\";\n        bool seen[128];\n        \n        int maxLength = 0, startIndex = 0;\n        \n        for(int i = 0; i &lt; n; i++){\n            memset(seen, false, 128);\n            int oddAlpha = 0;\n            for(int j = i; j &lt; n; j++){\n                char cur = s[j];\n                \n                if(!seen[cur]) {\n                    seen[cur] = true;\n                    if(seen[ cur ^ 32 ]){ // ^ 32: upper &lt;-&gt; lower\n                        oddAlpha--;\n                    } else {\n                        oddAlpha++;\n                    }\n                }\n                if(oddAlpha==0 &amp;&amp; j-i+1 &gt; maxLength){\n                    maxLength = j-i+1;\n                    startIndex = i;\n                }\n            } \n        }\n        return s.substr(startIndex, maxLength);\n    }\n};\n\n\n",
        "url": "/2022/04/10/1763-Longest-Nice-Substring/"
      },
    
      {
        "title": "Merge Strings Alternately",
        "excerpt": "&lt;-E 1768&gt; Merge Strings Alternately\n\nclass Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        int n = max(word1.size(), word2.size());\n        string ans = \"\";\n        \n        for(int i = 0; i &lt; n; i++)\n        {\n            if(word1.size() &gt; i)\n                ans += word1[i];\n            if(word2.size() &gt; i)\n                ans += word2[i];\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1768&gt; Merge Strings Alternately\n\nclass Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        int n = max(word1.size(), word2.size());\n        string ans = \"\";\n        \n        for(int i = 0; i &lt; n; i++)\n        {\n            if(word1.size() &gt; i)\n                ans += word1[i];\n            if(word2.size() &gt; i)\n                ans += word2[i];\n        }\n        \n        return ans;\n    }\n};\n\n\n",
        "url": "/2022/04/10/1768-Merge-Strings-Alternately/"
      },
    
      {
        "title": "Find Nearest Point That Has the Same X or Y Coordinate",
        "excerpt": "&lt;-E 1779&gt; Find Nearest Point That Has the Same X or Y Coordinate\n\nclass Solution {\npublic:\n    int nearestValidPoint(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n        int pos = -1;\n        int ans = INT_MAX;\n        \n        for(int i = 0; i &lt; points.size(); i++){\n            if(points[i][0] == x or points[i][1] == y){\n                int dist = abs(x-points[i][0]) + abs(y-points[i][1]);\n                if(dist &lt; ans){\n                    pos = i;\n                    ans = dist;\n                }\n            }   \n        }\n       return pos;\n    }\n};\n\n\n\n",
        "content": "&lt;-E 1779&gt; Find Nearest Point That Has the Same X or Y Coordinate\n\nclass Solution {\npublic:\n    int nearestValidPoint(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; points) {\n        int pos = -1;\n        int ans = INT_MAX;\n        \n        for(int i = 0; i &lt; points.size(); i++){\n            if(points[i][0] == x or points[i][1] == y){\n                int dist = abs(x-points[i][0]) + abs(y-points[i][1]);\n                if(dist &lt; ans){\n                    pos = i;\n                    ans = dist;\n                }\n            }   \n        }\n       return pos;\n    }\n};\n\n\n\n",
        "url": "/2022/04/11/1779-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/"
      },
    
      {
        "title": "Check if Binary String Has at Most One Segment of Ones",
        "excerpt": "&lt;-E 1784&gt; Check if Binary String Has at Most One Segment of Ones\n\n//method 1\nclass Solution {\npublic:\n    bool checkOnesSegment(string s) {\n        bool consecutive{false};\n        int count{0};\n        \n        for(char &amp;c : s){\n            if(c == '1' &amp;&amp; consecutive)\n                return false;\n            \n            if(c == '1')\n               count++;\n            else{\n                if(!consecutive &amp;&amp; count &gt; 0)\n                    consecutive = true;\n                \n                count = 0;\n            }\n        }\n        \n        return consecutive || count;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    bool checkOnesSegment(string s) {\n        int i = 0;\n\t\t// scan for sequential 1's\n        while(i &lt; s.size() &amp;&amp; s[i]=='1'){\n            i++;\n        }\n\t\t// scan for non sequential 1's\n        while(i &lt; s.size() &amp;&amp; s[i]!='1'){\n            i++;\n        }\n\t\t// no non-sequential 1's detected\n        return i == s.size();\n    }\n};\n\n\n",
        "content": "&lt;-E 1784&gt; Check if Binary String Has at Most One Segment of Ones\n\n//method 1\nclass Solution {\npublic:\n    bool checkOnesSegment(string s) {\n        bool consecutive{false};\n        int count{0};\n        \n        for(char &amp;c : s){\n            if(c == '1' &amp;&amp; consecutive)\n                return false;\n            \n            if(c == '1')\n               count++;\n            else{\n                if(!consecutive &amp;&amp; count &gt; 0)\n                    consecutive = true;\n                \n                count = 0;\n            }\n        }\n        \n        return consecutive || count;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    bool checkOnesSegment(string s) {\n        int i = 0;\n\t\t// scan for sequential 1's\n        while(i &lt; s.size() &amp;&amp; s[i]=='1'){\n            i++;\n        }\n\t\t// scan for non sequential 1's\n        while(i &lt; s.size() &amp;&amp; s[i]!='1'){\n            i++;\n        }\n\t\t// no non-sequential 1's detected\n        return i == s.size();\n    }\n};\n\n\n",
        "url": "/2022/04/11/1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/"
      },
    
      {
        "title": "Check if One String Swap Can Make Strings Equal",
        "excerpt": "&lt;-E 1790&gt; Check if One String Swap Can Make Strings Equal\n\n//method 1\nclass Solution {\npublic:\n    bool areAlmostEqual(string s1, string s2) {\n        vector&lt;char&gt; v2,v1;\n        int n = s1.size();\n        for(int i = 0;i &lt; n;i++){\n            if(s1[i] != s2[i]){\n                v1.emplace_back(s1[i]);\n                v2.emplace_back(s2[i]);\n            }\n        }\n        if(v1.size() == 0) return true;\n        else if(v1.size() != 2) return false;\n        else if(v1[0] == v2[1] &amp;&amp; v1[1] == v2[0]) return true;\n        else return false;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool areAlmostEqual(string s1, string s2) {\n        int n = s1.size();\n        int cnt = 0;\n        char prev_s1, prev_s2;  \n        for(int i = 0; i &lt; n; i++){\n            if(s1[i] == s2[i]) continue;\n            \n            if(++cnt &gt; 2) \n                return false; \n            if(cnt == 1){ \n                prev_s1 = s1[i];\n                prev_s2 = s2[i]; \n            }\n            else if(cnt == 2 &amp;&amp; (s1[i] != prev_s2 || s2[i] != prev_s1)) \n                return false; \n        return cnt != 1; \n    }\n};\n\n\n",
        "content": "&lt;-E 1790&gt; Check if One String Swap Can Make Strings Equal\n\n//method 1\nclass Solution {\npublic:\n    bool areAlmostEqual(string s1, string s2) {\n        vector&lt;char&gt; v2,v1;\n        int n = s1.size();\n        for(int i = 0;i &lt; n;i++){\n            if(s1[i] != s2[i]){\n                v1.emplace_back(s1[i]);\n                v2.emplace_back(s2[i]);\n            }\n        }\n        if(v1.size() == 0) return true;\n        else if(v1.size() != 2) return false;\n        else if(v1[0] == v2[1] &amp;&amp; v1[1] == v2[0]) return true;\n        else return false;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool areAlmostEqual(string s1, string s2) {\n        int n = s1.size();\n        int cnt = 0;\n        char prev_s1, prev_s2;  \n        for(int i = 0; i &lt; n; i++){\n            if(s1[i] == s2[i]) continue;\n            \n            if(++cnt &gt; 2) \n                return false; \n            if(cnt == 1){ \n                prev_s1 = s1[i];\n                prev_s2 = s2[i]; \n            }\n            else if(cnt == 2 &amp;&amp; (s1[i] != prev_s2 || s2[i] != prev_s1)) \n                return false; \n        return cnt != 1; \n    }\n};\n\n\n",
        "url": "/2022/04/11/1790-Check-if-One-String-Swap-Can-Make-Strings-Equal/"
      },
    
      {
        "title": "Find Center of Star Graph",
        "excerpt": "&lt;-E 1791&gt; Find Center of Star Graph\n\n//method 1\nclass Solution {\npublic:\n    int findCenter(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n        int a = edges[0][0];\n        int b = edges[0][1];\n        int c = edges[1][0];\n        int d = edges[1][1];\n        \n        if (a == c || a == d) return a;\n        else return b;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    int findCenter(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n        unordered_map &lt;int,int&gt; m;\n        for(auto i:edges){\n            for(auto j:i){\n                if(++m[j] &gt; 1)\n                    return j;\n            }\n        }\n        return 0;\n    }\n};\n\n\n",
        "content": "&lt;-E 1791&gt; Find Center of Star Graph\n\n//method 1\nclass Solution {\npublic:\n    int findCenter(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n        int a = edges[0][0];\n        int b = edges[0][1];\n        int c = edges[1][0];\n        int d = edges[1][1];\n        \n        if (a == c || a == d) return a;\n        else return b;\n    }\n};\n\n//method 2\nclass Solution {\npublic:\n    int findCenter(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {\n        unordered_map &lt;int,int&gt; m;\n        for(auto i:edges){\n            for(auto j:i){\n                if(++m[j] &gt; 1)\n                    return j;\n            }\n        }\n        return 0;\n    }\n};\n\n\n",
        "url": "/2022/04/12/1791-Find-Center-of-Star-Graph/"
      },
    
      {
        "title": "Second Largest Digit in a String",
        "excerpt": "&lt;-E 1796&gt; Second Largest Digit in a String\n\nclass Solution {\npublic:\n    int secondHighest(string s) {\n        int maxm = -1;\n        int preMax = -1;\n        for(auto ch: s){  \n            if(isdigit(ch)){\n                ch = ch - '0';\n                if(ch &gt; maxm){\n                    preMax = maxm;\n                    maxm  = ch;  \n                }\n                else if(ch != maxm &amp;&amp; ch &gt; preMax) \n                    preMax=ch;\n                \n            }\n        }\n        return preMax;\n    }\n};\n\n\n",
        "content": "&lt;-E 1796&gt; Second Largest Digit in a String\n\nclass Solution {\npublic:\n    int secondHighest(string s) {\n        int maxm = -1;\n        int preMax = -1;\n        for(auto ch: s){  \n            if(isdigit(ch)){\n                ch = ch - '0';\n                if(ch &gt; maxm){\n                    preMax = maxm;\n                    maxm  = ch;  \n                }\n                else if(ch != maxm &amp;&amp; ch &gt; preMax) \n                    preMax=ch;\n                \n            }\n        }\n        return preMax;\n    }\n};\n\n\n",
        "url": "/2022/04/12/1796-Second-Largest-Digit-in-a-String/"
      },
    
      {
        "title": "Maximum Ascending Subarray Sum",
        "excerpt": "&lt;-E 1800&gt; Maximum Ascending Subarray Sum\n\nclass Solution {\npublic:\n    int maxAscendingSum(vector&lt;int&gt;&amp; nums) {\n        int csum = nums[0];\n        int ans = nums[0];\n        \n        for(int i = 1 ; i &lt; nums.size() ; ++i ){\n            if(nums[i] &gt; nums[i-1] ){\n                csum += nums[i] ;\n            } else csum = nums[i] ;\n            ans = max(ans,csum) ;\n        }\n        return ans ;\n    }\n};\n\n\n",
        "content": "&lt;-E 1800&gt; Maximum Ascending Subarray Sum\n\nclass Solution {\npublic:\n    int maxAscendingSum(vector&lt;int&gt;&amp; nums) {\n        int csum = nums[0];\n        int ans = nums[0];\n        \n        for(int i = 1 ; i &lt; nums.size() ; ++i ){\n            if(nums[i] &gt; nums[i-1] ){\n                csum += nums[i] ;\n            } else csum = nums[i] ;\n            ans = max(ans,csum) ;\n        }\n        return ans ;\n    }\n};\n\n\n",
        "url": "/2022/04/12/1800-Maximum-Ascending-Subarray-Sum/"
      },
    
      {
        "title": "Number of Different Integers in a String",
        "excerpt": "&lt;-E 1805&gt; Number of Different Integers in a String\n\n//method 1\nclass Solution {\npublic:\n    int numDifferentIntegers(string word) {\n        unordered_set&lt;string&gt; set;\n        string num = \"\";\n        int n = word.size();\n        for (int i = 0; i &lt;= n; ++i) {\n            if (i == n || isalpha(word[i])) {\n                if (i &amp;&amp; isdigit(word[i-1])) {\n                    int j;\n                    for (j = 0; j &lt; num.size(); ++j) {\n                        if (num[j] != '0') {\n                            set.insert(num.substr(j));\n                            break;\n                        }\n                    }\n                    if (j == num.size()) {\n                        set.insert(\"0\");\n                    }\n                    num = \"\";\n                }\n            } else {\n                num += word[i];\n            }\n        }\n        return set.size();\n    }\n};\n\n//Method 2\nclass Solution {\npublic:\n    int numDifferentIntegers(string word) {\n        set&lt;string&gt; s;\n        string numstr;\n        for(int i = 0; i &lt; word.size(); i++) {\n            if(word[i] &gt;=97 &amp;&amp; word[i] &lt;=122) {\n                if(numstr.size() &gt; 0) {\n                    int j = 0;\n                    while(j &lt; numstr.size()) {\n                        if(numstr[j]!='0')\n                          break;\n                        numstr.erase(0,1);\n                    }\n                  s.insert((numstr));\n                  numstr=\"\";\n              }\n            }\n            else\n            numstr += word[i];\n        }\n        \n        if(numstr.size() &gt;= 1) {\n            int j = 0;\n            while(j &lt; numstr.size()) {\n                if(numstr[j] != '0')\n                  break;\n                numstr.erase(0,1);\n             }\n            s.insert((numstr));\n        }\n        \n        return s.size();   \n    }\n};\n\n\n",
        "content": "&lt;-E 1805&gt; Number of Different Integers in a String\n\n//method 1\nclass Solution {\npublic:\n    int numDifferentIntegers(string word) {\n        unordered_set&lt;string&gt; set;\n        string num = \"\";\n        int n = word.size();\n        for (int i = 0; i &lt;= n; ++i) {\n            if (i == n || isalpha(word[i])) {\n                if (i &amp;&amp; isdigit(word[i-1])) {\n                    int j;\n                    for (j = 0; j &lt; num.size(); ++j) {\n                        if (num[j] != '0') {\n                            set.insert(num.substr(j));\n                            break;\n                        }\n                    }\n                    if (j == num.size()) {\n                        set.insert(\"0\");\n                    }\n                    num = \"\";\n                }\n            } else {\n                num += word[i];\n            }\n        }\n        return set.size();\n    }\n};\n\n//Method 2\nclass Solution {\npublic:\n    int numDifferentIntegers(string word) {\n        set&lt;string&gt; s;\n        string numstr;\n        for(int i = 0; i &lt; word.size(); i++) {\n            if(word[i] &gt;=97 &amp;&amp; word[i] &lt;=122) {\n                if(numstr.size() &gt; 0) {\n                    int j = 0;\n                    while(j &lt; numstr.size()) {\n                        if(numstr[j]!='0')\n                          break;\n                        numstr.erase(0,1);\n                    }\n                  s.insert((numstr));\n                  numstr=\"\";\n              }\n            }\n            else\n            numstr += word[i];\n        }\n        \n        if(numstr.size() &gt;= 1) {\n            int j = 0;\n            while(j &lt; numstr.size()) {\n                if(numstr[j] != '0')\n                  break;\n                numstr.erase(0,1);\n             }\n            s.insert((numstr));\n        }\n        \n        return s.size();   \n    }\n};\n\n\n",
        "url": "/2022/04/12/1805-Number-of-Different-Integers-in-a-String/"
      },
    
      {
        "title": "Determine Color of a Chessboard Square",
        "excerpt": "&lt;-E 1812&gt; Determine Color of a Chessboard Square\n\nclass Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        return (coordinates[0] - 'a' + coordinates[1] - '1') % 2 == 1;\n    }\n};\n\n\n",
        "content": "&lt;-E 1812&gt; Determine Color of a Chessboard Square\n\nclass Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        return (coordinates[0] - 'a' + coordinates[1] - '1') % 2 == 1;\n    }\n};\n\n\n",
        "url": "/2022/04/13/1812-Determine-Color-of-a-Chessboard-Square/"
      },
    
      {
        "title": "Truncate Sentence",
        "excerpt": "&lt;-E 1816&gt; Truncate Sentence\n\n//method 1\nclass Solution {\npublic:\n    string truncateSentence(string s, int k) {\n        string ans = \"\";\n        int flag = 0;\n        for(char c : s){\n            if(c == ' ') \n                flag++;\n            if(flag == k)\n                break;\n            ans += c;\n        }\n        return ans;\n    }\n};\n\n//Method 2\nclass Solution {\npublic:\n    string truncateSentence(string s, int k) {\n        for (int i = 0; i &lt; s.size(); ++i)\n            if (s[i] == ' ' &amp;&amp; --k == 0)\n                return s.substr(0, i);\n        return s;\n    }\n};\n\n\n",
        "content": "&lt;-E 1816&gt; Truncate Sentence\n\n//method 1\nclass Solution {\npublic:\n    string truncateSentence(string s, int k) {\n        string ans = \"\";\n        int flag = 0;\n        for(char c : s){\n            if(c == ' ') \n                flag++;\n            if(flag == k)\n                break;\n            ans += c;\n        }\n        return ans;\n    }\n};\n\n//Method 2\nclass Solution {\npublic:\n    string truncateSentence(string s, int k) {\n        for (int i = 0; i &lt; s.size(); ++i)\n            if (s[i] == ' ' &amp;&amp; --k == 0)\n                return s.substr(0, i);\n        return s;\n    }\n};\n\n\n",
        "url": "/2022/04/13/1816-Truncate-Sentence/"
      },
    
      {
        "title": "Replace All Digits with Characters",
        "excerpt": "&lt;-E 1844&gt; Replace All Digits with Characters\n\nclass Solution {\npublic:\n    string replaceDigits(string s) {\n        for(int i = 1; i &lt; s.length(); i += 2) {\n            s[i] = char(s[i - 1] + (s[i] - '0'));\n        }   \n        return s;\n    }\n};\n\n\n",
        "content": "&lt;-E 1844&gt; Replace All Digits with Characters\n\nclass Solution {\npublic:\n    string replaceDigits(string s) {\n        for(int i = 1; i &lt; s.length(); i += 2) {\n            s[i] = char(s[i - 1] + (s[i] - '0'));\n        }   \n        return s;\n    }\n};\n\n\n",
        "url": "/2022/04/14/1844-Replace-All-Digits-with-Characters/"
      },
    
      {
        "title": "Minimum Distance to the Target Element",
        "excerpt": "&lt;-E 1848&gt; Minimum Distance to the Target Element\n\nclass Solution {\npublic:\n    int getMinDistance(vector&lt;int&gt;&amp; nums, int target, int start) {\n        int ans = INT_MAX;\n        for(int i = 0; i &lt; nums.size(); i++)\n            if(nums[i] == target)     \n                ans = min(ans, abs(start - i));\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1848&gt; Minimum Distance to the Target Element\n\nclass Solution {\npublic:\n    int getMinDistance(vector&lt;int&gt;&amp; nums, int target, int start) {\n        int ans = INT_MAX;\n        for(int i = 0; i &lt; nums.size(); i++)\n            if(nums[i] == target)     \n                ans = min(ans, abs(start - i));\n        return ans;\n    }\n};\n\n\n",
        "url": "/2022/04/14/1848-Minimum-Distance-to-the-Target-Element/"
      },
    
      {
        "title": "Maximum Population Year",
        "excerpt": "&lt;-E 1854&gt; Maximum Population Year\n\nclass Solution {\npublic:\n    int maximumPopulation(vector&lt;vector&lt;int&gt;&gt;&amp; logs) {\n        vector&lt;int&gt; cnt(101, 0);\n        for (auto &amp;log: logs) {\n            ++cnt[log[0]-1950];\n            --cnt[log[1]-1950];\n        }\n        int resy = -1, maxc = 0, curc = 0;\n        for (int i = 0; i &lt;= 100; ++i) {\n            curc += cnt[i];\n            if (curc &gt; maxc) {\n                maxc = curc;\n                resy = i;\n            }\n        }\n        return resy+1950;\n    }\n};\n\n\n\n",
        "content": "&lt;-E 1854&gt; Maximum Population Year\n\nclass Solution {\npublic:\n    int maximumPopulation(vector&lt;vector&lt;int&gt;&gt;&amp; logs) {\n        vector&lt;int&gt; cnt(101, 0);\n        for (auto &amp;log: logs) {\n            ++cnt[log[0]-1950];\n            --cnt[log[1]-1950];\n        }\n        int resy = -1, maxc = 0, curc = 0;\n        for (int i = 0; i &lt;= 100; ++i) {\n            curc += cnt[i];\n            if (curc &gt; maxc) {\n                maxc = curc;\n                resy = i;\n            }\n        }\n        return resy+1950;\n    }\n};\n\n\n\n",
        "url": "/2022/04/14/1854-Maximum-Population-Year/"
      },
    
      {
        "title": "Sorting the Sentence",
        "excerpt": "&lt;-E 1859&gt; Sorting the Sentence\n\nclass Solution {\npublic:\n    string sortSentence(string s) {\n        vector&lt;string&gt; words(10);\n        stringstream ss(s);\n        string str;\n        while(ss &gt;&gt; str) {\n            int index = str[str.length() - 1] - '0'; \n            str.pop_back(); \n            words[index] = str;\n        }\n\n        str = \"\";\n        for(int i = 1; i &lt;= 10; i++)\n            if(words[i] != \"\")\n                str += words[i] + \" \"; \n        str.pop_back();\n        return str;\n    }\n};\n\n\n",
        "content": "&lt;-E 1859&gt; Sorting the Sentence\n\nclass Solution {\npublic:\n    string sortSentence(string s) {\n        vector&lt;string&gt; words(10);\n        stringstream ss(s);\n        string str;\n        while(ss &gt;&gt; str) {\n            int index = str[str.length() - 1] - '0'; \n            str.pop_back(); \n            words[index] = str;\n        }\n\n        str = \"\";\n        for(int i = 1; i &lt;= 10; i++)\n            if(words[i] != \"\")\n                str += words[i] + \" \"; \n        str.pop_back();\n        return str;\n    }\n};\n\n\n",
        "url": "/2022/04/15/1859-Sorting-the-Sentence/"
      },
    
      {
        "title": "Sum of All Subset XOR Totals",
        "excerpt": "&lt;-E 1863&gt; Sum of All Subset XOR Totals\n\n// Method 1\nclass Solution {\npublic:\n    int subsetXORSum(vector&lt;int&gt;&amp; nums) {\n        int sum = 0;\n\t\tint mx = (1 &lt;&lt; nums.size());\n\t\tfor(int i = 0; i &lt; mx; i++){\n\t\t\tint numxor = 0;\n\t\t\tfor(int j = 0; j &lt; nums.size(); j++){\n\t\t\t\tif(i &amp; (1 &lt;&lt; j))\n\t\t\t\t\tnumxor ^= nums[j];\n\t\t\t}\n        sum += numxor;\n\t\t}\n\t\treturn sum;\n    }\n};\n\n// method 2\nclass Solution {\nprivate:\n    void bt(vector&lt;int&gt;&amp; nums, int&amp; ans, int cur, int sz, int i) {\n        if (i == sz) {\n            ans += cur;\n        } else {\n            bt(nums, ans, cur, sz, i+1);\n            bt(nums, ans, cur ^ nums[i], sz, i+1);\n        }\n    }\npublic:\n    int subsetXORSum(vector&lt;int&gt;&amp; nums) {\n        int ans = 0;\n        bt(nums, ans, 0, nums.size(), 0);\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1863&gt; Sum of All Subset XOR Totals\n\n// Method 1\nclass Solution {\npublic:\n    int subsetXORSum(vector&lt;int&gt;&amp; nums) {\n        int sum = 0;\n\t\tint mx = (1 &lt;&lt; nums.size());\n\t\tfor(int i = 0; i &lt; mx; i++){\n\t\t\tint numxor = 0;\n\t\t\tfor(int j = 0; j &lt; nums.size(); j++){\n\t\t\t\tif(i &amp; (1 &lt;&lt; j))\n\t\t\t\t\tnumxor ^= nums[j];\n\t\t\t}\n        sum += numxor;\n\t\t}\n\t\treturn sum;\n    }\n};\n\n// method 2\nclass Solution {\nprivate:\n    void bt(vector&lt;int&gt;&amp; nums, int&amp; ans, int cur, int sz, int i) {\n        if (i == sz) {\n            ans += cur;\n        } else {\n            bt(nums, ans, cur, sz, i+1);\n            bt(nums, ans, cur ^ nums[i], sz, i+1);\n        }\n    }\npublic:\n    int subsetXORSum(vector&lt;int&gt;&amp; nums) {\n        int ans = 0;\n        bt(nums, ans, 0, nums.size(), 0);\n        return ans;\n    }\n};\n\n\n",
        "url": "/2022/04/15/1863-Sum-of-All-Subset-XOR-Totals/"
      },
    
      {
        "title": "Longer Contiguous Segments of Ones than Zeros",
        "excerpt": "&lt;-E 1869&gt; Longer Contiguous Segments of Ones than Zeros\n\nclass Solution {\npublic:\n    bool checkZeroOnes(string s) {\n        int zmax = 0,omax = 0; \n        int zcnt = 0,ocnt = 0; \n        for(char i : s){  \n            if(i == '1'){  \n               omax = max(omax, ++ocnt);\n               zcnt = 0;\n            } \n            else{  \n              zmax = max(zmax, ++zcnt); \n               ocnt = 0;\n            }\n        }   \n        return omax &gt; zmax;\n    }\n};\n\n\n",
        "content": "&lt;-E 1869&gt; Longer Contiguous Segments of Ones than Zeros\n\nclass Solution {\npublic:\n    bool checkZeroOnes(string s) {\n        int zmax = 0,omax = 0; \n        int zcnt = 0,ocnt = 0; \n        for(char i : s){  \n            if(i == '1'){  \n               omax = max(omax, ++ocnt);\n               zcnt = 0;\n            } \n            else{  \n              zmax = max(zmax, ++zcnt); \n               ocnt = 0;\n            }\n        }   \n        return omax &gt; zmax;\n    }\n};\n\n\n",
        "url": "/2022/04/15/1869-Longer-Contiguous-Segments-of-Ones-than-Zeros/"
      },
    
      {
        "title": "Substrings of Size Three with Distinct Characters",
        "excerpt": "&lt;-E 1876&gt; Substrings of Size Three with Distinct Characters\n\nclass Solution {\npublic:\n    int countGoodSubstrings(string s) {\n        \n        if(s.size() &lt; 3)\n            return 0;\n        \n        int ans = 0;\n        \n        for(int i = 0; i &lt; s.size() - 2; i++)\n        {\n            if(s[i] != s[i+1] &amp;&amp; s[i+1] != s[i+2] &amp;&amp; s[i] != s[i+2])\n                ans++;\n        }\n        \n        return ans;\n    }\n};\n\n\n\n",
        "content": "&lt;-E 1876&gt; Substrings of Size Three with Distinct Characters\n\nclass Solution {\npublic:\n    int countGoodSubstrings(string s) {\n        \n        if(s.size() &lt; 3)\n            return 0;\n        \n        int ans = 0;\n        \n        for(int i = 0; i &lt; s.size() - 2; i++)\n        {\n            if(s[i] != s[i+1] &amp;&amp; s[i+1] != s[i+2] &amp;&amp; s[i] != s[i+2])\n                ans++;\n        }\n        \n        return ans;\n    }\n};\n\n\n\n",
        "url": "/2022/04/15/1876-Substrings-of-Size-Three-with-Distinct-Characters/"
      },
    
      {
        "title": "Minimum Depth of Binary Tree",
        "excerpt": "&lt;-E 111&gt; Minimum Depth of Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (!root)\n            return 0;\n        int left = minDepth(root-&gt;left);\n        int right = minDepth(root-&gt;right);\n        if(!root-&gt;left || !root-&gt;right)\n            return !root-&gt;left ? right + 1 : left + 1;\n        root-&gt;left = NULL;\n        root-&gt;right = NULL;\n        return min(left, right)+1;\n    }\n};\n\n",
        "content": "&lt;-E 111&gt; Minimum Depth of Binary Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (!root)\n            return 0;\n        int left = minDepth(root-&gt;left);\n        int right = minDepth(root-&gt;right);\n        if(!root-&gt;left || !root-&gt;right)\n            return !root-&gt;left ? right + 1 : left + 1;\n        root-&gt;left = NULL;\n        root-&gt;right = NULL;\n        return min(left, right)+1;\n    }\n};\n\n",
        "url": "/2022/04/16/111-Minimum-Depth-of-Binary-Tree/"
      },
    
      {
        "title": "Check if Word Equals Summation of Two Words",
        "excerpt": "&lt;-E 1880&gt; Check if Word Equals Summation of Two Words\n\n//method 1\nclass Solution {\npublic:\n    bool isSumEqual(string firstWord, string secondWord, string targetWord) {\n        string s1=\"\",s2=\"\",s3=\"\";\n        for(int i=0;i&lt;firstWord.size();i++)\n        {\n            int x= firstWord[i] - 97;\n            string s=to_string(x);\n            s1=s1+s;\n        }\n        for(int i=0;i&lt;secondWord.size();i++)\n        {\n            int x= secondWord[i] - 97;\n            string s=to_string(x);\n            s2=s2+s;\n        }\n        for(int i=0;i&lt;targetWord.size();i++)\n        {\n            int x= targetWord[i] - 97;\n            string s=to_string(x);\n            s3=s3+s;\n        }\n        \n        return ((stoi(s1) + stoi(s2)) == stoi(s3));\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isSumEqual(string firstWord, string secondWord, string targetWord) {\n        int f=0,s=0,t=0;\n        for(int j=0;j&lt;firstWord.length();j++)\n        {\n            f=f*10+(firstWord[j]-'a');\n        }\n        for(int j=0;j&lt;secondWord.length();j++)\n        {\n            s=s*10+(secondWord[j]-'a');\n        }\n        for(int j=0;j&lt;targetWord.length();j++)\n        {\n            t=t*10+(targetWord[j]-'a');\n        }\n        if(f+s == t)\n            return true;\n        else\n            return false;\n    }\n};\n\n\n",
        "content": "&lt;-E 1880&gt; Check if Word Equals Summation of Two Words\n\n//method 1\nclass Solution {\npublic:\n    bool isSumEqual(string firstWord, string secondWord, string targetWord) {\n        string s1=\"\",s2=\"\",s3=\"\";\n        for(int i=0;i&lt;firstWord.size();i++)\n        {\n            int x= firstWord[i] - 97;\n            string s=to_string(x);\n            s1=s1+s;\n        }\n        for(int i=0;i&lt;secondWord.size();i++)\n        {\n            int x= secondWord[i] - 97;\n            string s=to_string(x);\n            s2=s2+s;\n        }\n        for(int i=0;i&lt;targetWord.size();i++)\n        {\n            int x= targetWord[i] - 97;\n            string s=to_string(x);\n            s3=s3+s;\n        }\n        \n        return ((stoi(s1) + stoi(s2)) == stoi(s3));\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isSumEqual(string firstWord, string secondWord, string targetWord) {\n        int f=0,s=0,t=0;\n        for(int j=0;j&lt;firstWord.length();j++)\n        {\n            f=f*10+(firstWord[j]-'a');\n        }\n        for(int j=0;j&lt;secondWord.length();j++)\n        {\n            s=s*10+(secondWord[j]-'a');\n        }\n        for(int j=0;j&lt;targetWord.length();j++)\n        {\n            t=t*10+(targetWord[j]-'a');\n        }\n        if(f+s == t)\n            return true;\n        else\n            return false;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1880-Check-if-Word-Equals-Summation-of-Two-Words/"
      },
    
      {
        "title": "Determine Whether Matrix Can Be Obtained By Rotation",
        "excerpt": "&lt;-E 1886&gt; Determine Whether Matrix Can Be Obtained By Rotation\n\nclass Solution {\npublic:\n    bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; tar) {\n        if(mat == tar)\n            return true;\n        int d = 3;\n        while(d--){\n            \n            for(int i = 0; i &lt; mat.size(); i++)\n                for(int j = i + 1; j &lt; mat.size(); j++)\n                    swap(mat[i][j], mat[j][i]);\n                    \n            for (int i = 0; i &lt; mat.size(); i++) \n                reverse(mat[i].begin(), mat[i].end());\n        if(mat == tar)\n            return true;\n        }\n        return false;\n    }\n};\n\n\n",
        "content": "&lt;-E 1886&gt; Determine Whether Matrix Can Be Obtained By Rotation\n\nclass Solution {\npublic:\n    bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; tar) {\n        if(mat == tar)\n            return true;\n        int d = 3;\n        while(d--){\n            \n            for(int i = 0; i &lt; mat.size(); i++)\n                for(int j = i + 1; j &lt; mat.size(); j++)\n                    swap(mat[i][j], mat[j][i]);\n                    \n            for (int i = 0; i &lt; mat.size(); i++) \n                reverse(mat[i].begin(), mat[i].end());\n        if(mat == tar)\n            return true;\n        }\n        return false;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1886-Determine-Whether-Matrix-Can-Be-Obtained-By-Rotation/"
      },
    
      {
        "title": "Check if All the Integers in a Range Are Covered",
        "excerpt": "&lt;-E 1893&gt; Check if All the Integers in a Range Are Covered\n\nclass Solution {\npublic:\n    bool isCovered(vector&lt;vector&lt;int&gt;&gt;&amp; ranges, int left, int right) {\n        for(int i = left; i &lt;= right; i++) {\n            bool flag = false;\n            for(int j = 0; j &lt; ranges.size(); j++) {\n                if(ranges[j][0]&lt;=i&amp;&amp;ranges[j][1]&gt;=i) {\n                    flag = true;\n                    break;\n                }\n            }\n            \n            if(flag)\n                continue;\n            else\n                return false;\n        }\n        \n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 1893&gt; Check if All the Integers in a Range Are Covered\n\nclass Solution {\npublic:\n    bool isCovered(vector&lt;vector&lt;int&gt;&gt;&amp; ranges, int left, int right) {\n        for(int i = left; i &lt;= right; i++) {\n            bool flag = false;\n            for(int j = 0; j &lt; ranges.size(); j++) {\n                if(ranges[j][0]&lt;=i&amp;&amp;ranges[j][1]&gt;=i) {\n                    flag = true;\n                    break;\n                }\n            }\n            \n            if(flag)\n                continue;\n            else\n                return false;\n        }\n        \n        return true;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1893-Check-if-All-the-Integers-in-a-Range-Are-Covered/"
      },
    
      {
        "title": "Redistribute Characters to Make All Strings Equal",
        "excerpt": "&lt;-E 1897&gt; Redistribute Characters to Make All Strings Equal\n\nclass Solution {\npublic:\n    bool makeEqual(vector&lt;string&gt;&amp; words) {\n        int freq[26] = {0};\n\n        for (auto word : words)\n            for (auto c : word)\n                freq[c - 'a']++;\n\n        for (int i = 0; i &lt; 26; i++)\n            if (freq[i] &amp;&amp; freq[i] % words.size() != 0)\n                return false;\n\n        return true;\n    }\n};\n\n",
        "content": "&lt;-E 1897&gt; Redistribute Characters to Make All Strings Equal\n\nclass Solution {\npublic:\n    bool makeEqual(vector&lt;string&gt;&amp; words) {\n        int freq[26] = {0};\n\n        for (auto word : words)\n            for (auto c : word)\n                freq[c - 'a']++;\n\n        for (int i = 0; i &lt; 26; i++)\n            if (freq[i] &amp;&amp; freq[i] % words.size() != 0)\n                return false;\n\n        return true;\n    }\n};\n\n",
        "url": "/2022/04/16/1897-Redistribute-Characters-to-Make-All-Strings-Equal/"
      },
    
      {
        "title": "Remove One Element to Make the Array Strictly Increasing",
        "excerpt": "&lt;-E 1909&gt; Remove One Element to Make the Array Strictly Increasing\n\nclass Solution {\npublic:\n    bool canBeIncreasing(vector&lt;int&gt;&amp; nums) {\n\n\n        int count = 0;\n        for(int i=0;i &lt; nums.size()-1 &amp;&amp; count &lt; 2; i++) {\n            if(nums[i]&gt;=nums[i+1]) {\n                count++;\n                if(i &gt; 0 &amp;&amp; nums[i+1] &lt;= nums[i-1])\n                    nums[i+1] = nums[i];\n            }\n        }\n        return count &lt; 2;\n    }\n};\n\n\n",
        "content": "&lt;-E 1909&gt; Remove One Element to Make the Array Strictly Increasing\n\nclass Solution {\npublic:\n    bool canBeIncreasing(vector&lt;int&gt;&amp; nums) {\n\n\n        int count = 0;\n        for(int i=0;i &lt; nums.size()-1 &amp;&amp; count &lt; 2; i++) {\n            if(nums[i]&gt;=nums[i+1]) {\n                count++;\n                if(i &gt; 0 &amp;&amp; nums[i+1] &lt;= nums[i-1])\n                    nums[i+1] = nums[i];\n            }\n        }\n        return count &lt; 2;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1909-Remove-One-Element-to-Make-the-Array-Strictly-Increasing/"
      },
    
      {
        "title": "Maximum Product Difference Between Two Pairs",
        "excerpt": "&lt;-E 1913&gt; Maximum Product Difference Between Two Pairs\n\nclass Solution {\npublic:\n    int maxProductDifference(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        return  (nums[nums.size() - 1] * nums[nums.size() - 2]) - (nums[0] * nums[1]);\n    }\n};\n\n",
        "content": "&lt;-E 1913&gt; Maximum Product Difference Between Two Pairs\n\nclass Solution {\npublic:\n    int maxProductDifference(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        return  (nums[nums.size() - 1] * nums[nums.size() - 2]) - (nums[0] * nums[1]);\n    }\n};\n\n",
        "url": "/2022/04/16/1913-Maximum-Product-Difference-Between-Two-Pairs/"
      },
    
      {
        "title": "Build Array from Permutation",
        "excerpt": "&lt;-E 1920&gt; Build Array from Permutation\n\nclass Solution {\npublic:\n    vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; ans(nums.size(),0);\n        for(int i = 0; i != nums.size(); i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 1920&gt; Build Array from Permutation\n\nclass Solution {\npublic:\n    vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; ans(nums.size(),0);\n        for(int i = 0; i != nums.size(); i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/1920-Build-Array-from-Permutation/"
      },
    
      {
        "title": "Count Square Sum Triples",
        "excerpt": "&lt;-E 1925&gt; Count Square Sum Triples\n\n// Method 1\nclass Solution {\npublic:\n    int countTriples(int n) {\n       int count = 0;\n       for(int i = 1; i &lt;= n; i++) {\n            for(int j = 1;j &lt;= n; j++) {\n                int sum = i*i + j*j;\n                int t = sqrt(sum);\n\n                if(t * t == sum &amp;&amp; t &lt;= n)\n                    count++;\n            }\n        }\n        return count;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countTriples(int n) {\n\n        vector&lt;int&gt; squares(n * n + 1, 0);\n        for (int i = 1; i &lt;= n; ++i)\n            squares[i * i] = 1;\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = i; i * i + j * j &lt;= n * n; ++j)\n                res += squares[i * i + j * j] * 2;\n        return res;\n\n    }\n};\n\nclass Solution {\npublic:\n    int countTriples(int n) {\n\n        vector&lt;int&gt; squares(n * n + 1, 0);\n        for (int i = 1; i &lt;= n; ++i)\n            squares[i * i] = 1;\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = i; i * i + j * j &lt;= n * n; ++j)\n                res += squares[i * i + j * j] * 2;\n        return res;\n\n    }\n};\n\n",
        "content": "&lt;-E 1925&gt; Count Square Sum Triples\n\n// Method 1\nclass Solution {\npublic:\n    int countTriples(int n) {\n       int count = 0;\n       for(int i = 1; i &lt;= n; i++) {\n            for(int j = 1;j &lt;= n; j++) {\n                int sum = i*i + j*j;\n                int t = sqrt(sum);\n\n                if(t * t == sum &amp;&amp; t &lt;= n)\n                    count++;\n            }\n        }\n        return count;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countTriples(int n) {\n\n        vector&lt;int&gt; squares(n * n + 1, 0);\n        for (int i = 1; i &lt;= n; ++i)\n            squares[i * i] = 1;\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = i; i * i + j * j &lt;= n * n; ++j)\n                res += squares[i * i + j * j] * 2;\n        return res;\n\n    }\n};\n\nclass Solution {\npublic:\n    int countTriples(int n) {\n\n        vector&lt;int&gt; squares(n * n + 1, 0);\n        for (int i = 1; i &lt;= n; ++i)\n            squares[i * i] = 1;\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; ++i)\n            for (int j = i; i * i + j * j &lt;= n * n; ++j)\n                res += squares[i * i + j * j] * 2;\n        return res;\n\n    }\n};\n\n",
        "url": "/2022/04/16/1925-Count-Square-Sum-Triples/"
      },
    
      {
        "title": "Concatenation of Array",
        "excerpt": "&lt;-E 1929&gt; Concatenation of Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        vector&lt;int&gt; ans(n * 2, 0);\n        for(int i = 0; i != n; i++) {\n            ans[i] = nums[i];\n            ans[i + n] = nums[i];\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; ans = nums;\n        for(int i = 0; i &lt; nums.size(); i++){\n            ans.push_back(nums[i]);\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 1929&gt; Concatenation of Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        vector&lt;int&gt; ans(n * 2, 0);\n        for(int i = 0; i != n; i++) {\n            ans[i] = nums[i];\n            ans[i + n] = nums[i];\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; ans = nums;\n        for(int i = 0; i &lt; nums.size(); i++){\n            ans.push_back(nums[i]);\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/1929-Concatenation-of-Array/"
      },
    
      {
        "title": "Maximum Number of Words You Can Type",
        "excerpt": "&lt;-E 1935&gt; Maximum Number of Words You Can Type\n\n// Method 1\nclass Solution {\npublic:\n    int canBeTypedWords(string text, string brokenLetters) {\n        int check[26] = {0};\n        for(auto c : brokenLetters)\n            check[c -'a'] = 1;\n\n        bool cannot = false;\n        int ans = 0;\n\n        for(auto c : text) {\n            if(c == ' ') {\n                if (cannot != true)\n                    ans++;\n                cannot = false;\n            }\n            else if(check[c - 'a'] == 1)\n               cannot = true;\n        }\n\n        if(cannot == false)\n            ans++;\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int canBeTypedWords(string text, string brokenLetters) {\n        unordered_set&lt;char&gt; lookup(cbegin(brokenLetters), cend(brokenLetters));\n        int result = 0;\n        bool broken = false;\n        for (const auto&amp; c : text) {\n            if (c == ' ') {\n              result += int(broken == false);\n              broken = false;\n            } else if (lookup.count(c)) {\n                broken = true;\n            }\n        }\n        return result + int(broken == false);\n    }\n};\n\n",
        "content": "&lt;-E 1935&gt; Maximum Number of Words You Can Type\n\n// Method 1\nclass Solution {\npublic:\n    int canBeTypedWords(string text, string brokenLetters) {\n        int check[26] = {0};\n        for(auto c : brokenLetters)\n            check[c -'a'] = 1;\n\n        bool cannot = false;\n        int ans = 0;\n\n        for(auto c : text) {\n            if(c == ' ') {\n                if (cannot != true)\n                    ans++;\n                cannot = false;\n            }\n            else if(check[c - 'a'] == 1)\n               cannot = true;\n        }\n\n        if(cannot == false)\n            ans++;\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int canBeTypedWords(string text, string brokenLetters) {\n        unordered_set&lt;char&gt; lookup(cbegin(brokenLetters), cend(brokenLetters));\n        int result = 0;\n        bool broken = false;\n        for (const auto&amp; c : text) {\n            if (c == ' ') {\n              result += int(broken == false);\n              broken = false;\n            } else if (lookup.count(c)) {\n                broken = true;\n            }\n        }\n        return result + int(broken == false);\n    }\n};\n\n",
        "url": "/2022/04/16/1935-Maximum-Number-of-Words-You-Can-Type/"
      },
    
      {
        "title": "Check if All Characters Have Equal Number of Occurrences",
        "excerpt": "&lt;-E 1941&gt; Check if All Characters Have Equal Number of Occurrences\n\n// Method 1\nclass Solution {\npublic:\n    bool areOccurrencesEqual(string s) {\n        int check[26] = {0};\n        for(auto c : s) {\n            check[c - 'a']++;\n        }\n\n        int temp = 0;\n        for(auto i : check) {\n            if(temp == 0 &amp;&amp; i != 0)\n                temp = i;\n            if(i != 0){\n                if(temp != 0 &amp;&amp; temp != i)\n                return false;\n            }\n\n        }\n        return true;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool areOccurrencesEqual(string s) {\n        int check[26] = {0};\n        for(auto c : s) {\n            check[c - 'a']++;\n        }\n\n        set&lt;int&gt; ans;\n        for(auto i : check) {\n            if(i != 0)\n                ans.insert(i);\n        }\n        return ans.size() == 1;\n    }\n};\n\n",
        "content": "&lt;-E 1941&gt; Check if All Characters Have Equal Number of Occurrences\n\n// Method 1\nclass Solution {\npublic:\n    bool areOccurrencesEqual(string s) {\n        int check[26] = {0};\n        for(auto c : s) {\n            check[c - 'a']++;\n        }\n\n        int temp = 0;\n        for(auto i : check) {\n            if(temp == 0 &amp;&amp; i != 0)\n                temp = i;\n            if(i != 0){\n                if(temp != 0 &amp;&amp; temp != i)\n                return false;\n            }\n\n        }\n        return true;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool areOccurrencesEqual(string s) {\n        int check[26] = {0};\n        for(auto c : s) {\n            check[c - 'a']++;\n        }\n\n        set&lt;int&gt; ans;\n        for(auto i : check) {\n            if(i != 0)\n                ans.insert(i);\n        }\n        return ans.size() == 1;\n    }\n};\n\n",
        "url": "/2022/04/16/1941-Check-if-All-Characters-Have-Equal-Number-of-Occurrences/"
      },
    
      {
        "title": "Sum of Digits of String After Convert",
        "excerpt": "&lt;-E 1945&gt; Sum of Digits of String After Convert\n\n// Method 1\nclass Solution {\npublic:\n    int getLucky(string s, int k) {\n        int n = s.length();\n        int sum = 0;\n        string str = \"\";\n        for(int i = 0; i &lt; n; i++) {\n            str+=to_string(s[i] - 'a');\n        }\n        while(k--){\n            sum = 0;\n            for(int i = 0; i &lt; str.length(); i++)\n                sum += (str[i] - '0');\n            str = to_string(sum);\n        }\n        return sum;\n    }\n};\n\nclass Solution {\npublic:\n    int getLucky(string s, int k) {\n         int num = 0, n = 0; int sum;\n        for(int i=0; i &lt; s.length(); i++) {\n            num = num*10+ s[i]-'a'+1;\n            while(num) {\n               n += (num % 10);\n               num /= 10;\n            }\n        }\n        k--;\n        while(k--) {\n            sum = 0;\n            while(n &gt; 0) {\n                sum += n % 10;\n                n /= 10;\n            }\n            n = sum;\n        }\n        return sum;\n    }\n};\n\n",
        "content": "&lt;-E 1945&gt; Sum of Digits of String After Convert\n\n// Method 1\nclass Solution {\npublic:\n    int getLucky(string s, int k) {\n        int n = s.length();\n        int sum = 0;\n        string str = \"\";\n        for(int i = 0; i &lt; n; i++) {\n            str+=to_string(s[i] - 'a');\n        }\n        while(k--){\n            sum = 0;\n            for(int i = 0; i &lt; str.length(); i++)\n                sum += (str[i] - '0');\n            str = to_string(sum);\n        }\n        return sum;\n    }\n};\n\nclass Solution {\npublic:\n    int getLucky(string s, int k) {\n         int num = 0, n = 0; int sum;\n        for(int i=0; i &lt; s.length(); i++) {\n            num = num*10+ s[i]-'a'+1;\n            while(num) {\n               n += (num % 10);\n               num /= 10;\n            }\n        }\n        k--;\n        while(k--) {\n            sum = 0;\n            while(n &gt; 0) {\n                sum += n % 10;\n                n /= 10;\n            }\n            n = sum;\n        }\n        return sum;\n    }\n};\n\n",
        "url": "/2022/04/16/1945-Sum-of-Digits-of-String-After-Convert/"
      },
    
      {
        "title": "Three Divisors",
        "excerpt": "&lt;-E 1952&gt; Three Divisors\n\nclass Solution {\n    bool isPrime(int n) {\n        if (n &lt;= 1) return false;\n        for (int i = 2; i * i &lt;= n; i++)\n            if (n % i == 0) return false;\n        return true;\n    }\npublic:\n    bool isThree(int n) {\n        int s = sqrt(n);\n        return s * s == n &amp;&amp; isPrime(s);\n    }\n};\n\n",
        "content": "&lt;-E 1952&gt; Three Divisors\n\nclass Solution {\n    bool isPrime(int n) {\n        if (n &lt;= 1) return false;\n        for (int i = 2; i * i &lt;= n; i++)\n            if (n % i == 0) return false;\n        return true;\n    }\npublic:\n    bool isThree(int n) {\n        int s = sqrt(n);\n        return s * s == n &amp;&amp; isPrime(s);\n    }\n};\n\n",
        "url": "/2022/04/16/1952-Three-Divisors/"
      },
    
      {
        "title": "Delete Characters to Make Fancy String",
        "excerpt": "&lt;-E 1957&gt; Delete Characters to Make Fancy String\n\n// Method 1\nclass Solution {\npublic:\n    string makeFancyString(string s) {\n        string res = \"\";\n        for (int i = 0; i &lt; s.size(); ++i) {\n            if (i &lt; 2 || s[i] != s[i-1] || s[i] != s[i-2]) {\n                res += s[i];\n            }\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string makeFancyString(string s) {\n        string res;\n        char tmp = s[0];\n        int k = 0;\n        for (auto c : s) {\n            if (c == tmp)\n                k++;\n            else {\n                k = 1;\n                tmp = c;\n            }\n            if (k &lt; 3)\n                res += tmp;\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 1957&gt; Delete Characters to Make Fancy String\n\n// Method 1\nclass Solution {\npublic:\n    string makeFancyString(string s) {\n        string res = \"\";\n        for (int i = 0; i &lt; s.size(); ++i) {\n            if (i &lt; 2 || s[i] != s[i-1] || s[i] != s[i-2]) {\n                res += s[i];\n            }\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string makeFancyString(string s) {\n        string res;\n        char tmp = s[0];\n        int k = 0;\n        for (auto c : s) {\n            if (c == tmp)\n                k++;\n            else {\n                k = 1;\n                tmp = c;\n            }\n            if (k &lt; 3)\n                res += tmp;\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1957-Delete-Characters-to-Make-Fancy-String/"
      },
    
      {
        "title": "Check If String Is a Prefix of Array",
        "excerpt": "&lt;-E 1961&gt; Check If String Is a Prefix of Array\n\nclass Solution {\npublic:\n    bool isPrefixString(string s, vector&lt;string&gt;&amp; words) {\n        int i = 0;\n\n        for(auto word : words) {\n            bool check = true;\n            for (auto c : word) {\n               if(check == true) {\n                   if(c != s[i])\n                       check = false;\n                }\n                i++;\n            }\n            if(check == false)\n                return false;\n            if(i == s.size())\n                return true;\n        }\n        return false;\n    }\n};\n\n",
        "content": "&lt;-E 1961&gt; Check If String Is a Prefix of Array\n\nclass Solution {\npublic:\n    bool isPrefixString(string s, vector&lt;string&gt;&amp; words) {\n        int i = 0;\n\n        for(auto word : words) {\n            bool check = true;\n            for (auto c : word) {\n               if(check == true) {\n                   if(c != s[i])\n                       check = false;\n                }\n                i++;\n            }\n            if(check == false)\n                return false;\n            if(i == s.size())\n                return true;\n        }\n        return false;\n    }\n};\n\n",
        "url": "/2022/04/16/1961-Check-If-String-Is-a-Prefix-of-Array/"
      },
    
      {
        "title": "Number of Strings That Appear as Substrings in Word",
        "excerpt": "&lt;-E 1967&gt; Number of Strings That Appear as Substrings in Word\n\nclass Solution {\npublic:\n    int numOfStrings(vector&lt;string&gt;&amp; patterns, string word) {\n        int count = 0;\n        for(int i=0; i &lt; patterns.size(); i++) {\n            if(word.find(patterns[i]) != string::npos)\n                count++;\n        }\n        return count;\n    }\n};\n\n\n",
        "content": "&lt;-E 1967&gt; Number of Strings That Appear as Substrings in Word\n\nclass Solution {\npublic:\n    int numOfStrings(vector&lt;string&gt;&amp; patterns, string word) {\n        int count = 0;\n        for(int i=0; i &lt; patterns.size(); i++) {\n            if(word.find(patterns[i]) != string::npos)\n                count++;\n        }\n        return count;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1967-Number-of-Strings-That-Appear-as-Substrings-in-Word/"
      },
    
      {
        "title": "Find if Path Exists in Graph",
        "excerpt": "&lt;-E 1971&gt; Find if Path Exists in Graph\n\n// Method 1\nclass Solution {\npublic:\n    bool validPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int source, int destination) {\n        vector&lt;bool&gt;b(n+1,false);\n        unordered_map&lt;int,vector&lt;int&gt;&gt;m;\n        for(auto i : edges) {\n            m[i[0]].emplace_back(i[1]);\n            m[i[1]].emplace_back(i[0]);\n        }\n        queue&lt;int&gt;q;\n        q.push(source);\n        b[source] = true;\n        while(!q.empty()) {\n            int t = q.front();\n            q.pop();\n            for(int i = 0; i &lt; m[t].size(); i++) {\n                int k = m[t][i];\n                if(b[k] == false) {\n                    q.push(k);\n                    b[k] = true;\n                }\n            }\n            if(b[destination] == true)\n                return true;\n        }\n        return false;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool validPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int start, int end) {\n        vector&lt;int&gt; f(n);\n        iota(f.begin(), f.end(), 0);\n        for(auto&amp; e : edges) {\n            int a = find(f, e[0]), b = find(f, e[1]);\n            if (a &lt; b) f[b] = a;\n            else f[a] = b;\n        }\n        return find(f, start) == find(f, end);\n    }\n    \n    int find(vector&lt;int&gt;&amp; f, int x) {\n        if (f[x] != x) {\n            f[x] = find(f, f[x]);\n        }\n        return f[x];\n    }\n};\n\n\n",
        "content": "&lt;-E 1971&gt; Find if Path Exists in Graph\n\n// Method 1\nclass Solution {\npublic:\n    bool validPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int source, int destination) {\n        vector&lt;bool&gt;b(n+1,false);\n        unordered_map&lt;int,vector&lt;int&gt;&gt;m;\n        for(auto i : edges) {\n            m[i[0]].emplace_back(i[1]);\n            m[i[1]].emplace_back(i[0]);\n        }\n        queue&lt;int&gt;q;\n        q.push(source);\n        b[source] = true;\n        while(!q.empty()) {\n            int t = q.front();\n            q.pop();\n            for(int i = 0; i &lt; m[t].size(); i++) {\n                int k = m[t][i];\n                if(b[k] == false) {\n                    q.push(k);\n                    b[k] = true;\n                }\n            }\n            if(b[destination] == true)\n                return true;\n        }\n        return false;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool validPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int start, int end) {\n        vector&lt;int&gt; f(n);\n        iota(f.begin(), f.end(), 0);\n        for(auto&amp; e : edges) {\n            int a = find(f, e[0]), b = find(f, e[1]);\n            if (a &lt; b) f[b] = a;\n            else f[a] = b;\n        }\n        return find(f, start) == find(f, end);\n    }\n    \n    int find(vector&lt;int&gt;&amp; f, int x) {\n        if (f[x] != x) {\n            f[x] = find(f, f[x]);\n        }\n        return f[x];\n    }\n};\n\n\n",
        "url": "/2022/04/16/1971-Find-if-Path-Exists-in-Graph/"
      },
    
      {
        "title": "Minimum Time to Type Word Using Special Typewriter",
        "excerpt": "&lt;-E 1974&gt; Minimum Time to Type Word Using Special Typewriter\n\n//method 1\nclass Solution {\npublic:\n    int minTimeToType(const string&amp; s) {\n        int steps = 0;\n        \n        char cur = 'a';\n        for (const char&amp; c : s) {\n            int step = minStep(cur, c);\n            cur = c;\n            \n            steps += (step + 1);\n        }\n        \n        return steps;\n    }\nprivate:\n    int minStep(char a, char b) {\n        if (a &gt; b)\n            std::swap(a, b);\n        \n        return std::min(b - a, a - 'a' + 'z' - b + 1);\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int minTimeToType(string word) {\n        int count = word.size();\n        int point = 'a';\n        for(char c: word)\n        {\n            count += min(abs(c - point), 26 - abs(c - point));\n            point = c;\n        }\n        return count;\n    }\n};\n\n\n",
        "content": "&lt;-E 1974&gt; Minimum Time to Type Word Using Special Typewriter\n\n//method 1\nclass Solution {\npublic:\n    int minTimeToType(const string&amp; s) {\n        int steps = 0;\n        \n        char cur = 'a';\n        for (const char&amp; c : s) {\n            int step = minStep(cur, c);\n            cur = c;\n            \n            steps += (step + 1);\n        }\n        \n        return steps;\n    }\nprivate:\n    int minStep(char a, char b) {\n        if (a &gt; b)\n            std::swap(a, b);\n        \n        return std::min(b - a, a - 'a' + 'z' - b + 1);\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int minTimeToType(string word) {\n        int count = word.size();\n        int point = 'a';\n        for(char c: word)\n        {\n            count += min(abs(c - point), 26 - abs(c - point));\n            point = c;\n        }\n        return count;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1974-Minimum-Time-to-Type-Word-Using-Special-Typewriter/"
      },
    
      {
        "title": "Find Greatest Common Divisor of Array",
        "excerpt": "&lt;-E 1979&gt; Find Greatest Common Divisor of Array\n\n//method 1\nclass Solution {\npublic:\n    int findGCD(vector&lt;int&gt;&amp; nums) {\n        int max = *max_element(nums.begin(), nums.end());\n        int min = *min_element(nums.begin(), nums.end());\n        return gcd(max,min);\n    }\n};í\n\n// Method 2\nclass Solution {\npublic:\n    int gcd(int a, int b){\n        if(b == 0){\n            return a;\n        }else{\n            return gcd(b, a%b);\n        }\n    }\n    int findGCD(vector&lt;int&gt;&amp; nums) {\n        int mn=INT_MAX, mx=INT_MIN;\n        for(int i=0; i&lt;nums.size(); i++){\n            mn = mn &lt; nums[i]? mn : nums[i];\n            mx = mx &gt; nums[i]? mx : nums[i];\n        }\n        return gcd(mx, mn);\n    }\n};\n\n\n",
        "content": "&lt;-E 1979&gt; Find Greatest Common Divisor of Array\n\n//method 1\nclass Solution {\npublic:\n    int findGCD(vector&lt;int&gt;&amp; nums) {\n        int max = *max_element(nums.begin(), nums.end());\n        int min = *min_element(nums.begin(), nums.end());\n        return gcd(max,min);\n    }\n};í\n\n// Method 2\nclass Solution {\npublic:\n    int gcd(int a, int b){\n        if(b == 0){\n            return a;\n        }else{\n            return gcd(b, a%b);\n        }\n    }\n    int findGCD(vector&lt;int&gt;&amp; nums) {\n        int mn=INT_MAX, mx=INT_MIN;\n        for(int i=0; i&lt;nums.size(); i++){\n            mn = mn &lt; nums[i]? mn : nums[i];\n            mx = mx &gt; nums[i]? mx : nums[i];\n        }\n        return gcd(mx, mn);\n    }\n};\n\n\n",
        "url": "/2022/04/16/1979-Find-Greatest-Common-Divisor-of-Array/"
      },
    
      {
        "title": "Minimum Difference Between Highest and Lowest of K Scores",
        "excerpt": "&lt;-E 1984&gt; Minimum Difference Between Highest and Lowest of K Scores\n\nclass Solution {\npublic:\n    int minimumDifference(vector&lt;int&gt;&amp; nums, int k) {\n        if(nums.size() &lt; 2 || k==1) \n            return 0;\n        sort(nums.begin(), nums.end());\n        int res = INT_MAX;\n        for(int i = k - 1;i &lt; nums.size(); i++)\n            res = min(res, nums[i]-nums[i-k+1]);\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 1984&gt; Minimum Difference Between Highest and Lowest of K Scores\n\nclass Solution {\npublic:\n    int minimumDifference(vector&lt;int&gt;&amp; nums, int k) {\n        if(nums.size() &lt; 2 || k==1) \n            return 0;\n        sort(nums.begin(), nums.end());\n        int res = INT_MAX;\n        for(int i = k - 1;i &lt; nums.size(); i++)\n            res = min(res, nums[i]-nums[i-k+1]);\n        return res;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1984-Minimum-Difference-Between-Highest-and-Lowest-of-K-Scores/"
      },
    
      {
        "title": "Find the Middle Index in Array",
        "excerpt": "&lt;-E 1991&gt; Find the Middle Index in Array\n\nclass Solution {\npublic:\n    int findMiddleIndex(vector&lt;int&gt;&amp; nums) {\n        auto sum = accumulate(nums.begin(), nums.end(), 0), leftSum = 0;\n        for(int i=0;i&lt;nums.size();i++){\n            if(leftSum == sum - leftSum - nums[i]) return i;\n            leftSum += nums[i];\n        }\n        return -1;  \n    }\n};\n\n\n",
        "content": "&lt;-E 1991&gt; Find the Middle Index in Array\n\nclass Solution {\npublic:\n    int findMiddleIndex(vector&lt;int&gt;&amp; nums) {\n        auto sum = accumulate(nums.begin(), nums.end(), 0), leftSum = 0;\n        for(int i=0;i&lt;nums.size();i++){\n            if(leftSum == sum - leftSum - nums[i]) return i;\n            leftSum += nums[i];\n        }\n        return -1;  \n    }\n};\n\n\n",
        "url": "/2022/04/16/1991-Find-the-Middle-Index-in-Array/"
      },
    
      {
        "title": "Count Special Quadruplets",
        "excerpt": "&lt;-E 1995&gt; Count Special Quadruplets\n\n//method 1\n// class Solution {\n// public:\n//     int countQuadruplets(vector&lt;int&gt;&amp; nums) {\n//         int ans=0;\n//         int n=nums.size();\n//         for(int i=0;i&lt;n;i++) {\n//             for(int j=i+1;j&lt;n;j++) {\n//                 for(int k=j+1;k&lt;n;k++) {\n//                     for(int l=k+1;l&lt;n;l++) {\n//                         if(nums[i]+nums[j]+nums[k]==nums[l])\n//                             ans++;\n//                     }\n//                 }\n//             }\n//         }\n//         return ans;\n//     }\n// };\n\n// Method 2\nclass Solution {\npublic:\n    int countQuadruplets(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; mp(201,0);\n        int ans=0;\n        int n=nums.size();\n        for(int i=1; i&lt;n; i++) {\n            for(int j=0; j&lt;i; j++)\n                mp[nums[i]+nums[j]]++;\n            for(int k=i+2; k&lt;n; k++) {\n                int d=nums[k]-nums[i+1];\n                if(d&gt;=0)\n                    ans+=mp[d];\n            }\n        }\n     return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 1995&gt; Count Special Quadruplets\n\n//method 1\n// class Solution {\n// public:\n//     int countQuadruplets(vector&lt;int&gt;&amp; nums) {\n//         int ans=0;\n//         int n=nums.size();\n//         for(int i=0;i&lt;n;i++) {\n//             for(int j=i+1;j&lt;n;j++) {\n//                 for(int k=j+1;k&lt;n;k++) {\n//                     for(int l=k+1;l&lt;n;l++) {\n//                         if(nums[i]+nums[j]+nums[k]==nums[l])\n//                             ans++;\n//                     }\n//                 }\n//             }\n//         }\n//         return ans;\n//     }\n// };\n\n// Method 2\nclass Solution {\npublic:\n    int countQuadruplets(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; mp(201,0);\n        int ans=0;\n        int n=nums.size();\n        for(int i=1; i&lt;n; i++) {\n            for(int j=0; j&lt;i; j++)\n                mp[nums[i]+nums[j]]++;\n            for(int k=i+2; k&lt;n; k++) {\n                int d=nums[k]-nums[i+1];\n                if(d&gt;=0)\n                    ans+=mp[d];\n            }\n        }\n     return ans;\n    }\n};\n\n\n",
        "url": "/2022/04/16/1995-Count-Special-Quadruplets/"
      },
    
      {
        "title": "Reverse Prefix of Word",
        "excerpt": "&lt;-E 2000&gt; Reverse Prefix of Word\n\n//Method 1\nclass Solution {\npublic:\n    string reversePrefix(string word, char ch) {\n        for(int i = 0; i &lt; word.length(); i++) {\n            if(word[i] == ch) {\n                reverse(word.begin(), word.begin()+i+1);\n                break;\n            }\n        }\n        return word;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string reversePrefix(string word, char ch) {\n        size_t found = word.find(ch);\n        if (found != string::npos) {\n            reverse(word.begin(), word.begin()+found+1);\n            return word;\n        }\n        return word;\n    }\n};\n\n\n",
        "content": "&lt;-E 2000&gt; Reverse Prefix of Word\n\n//Method 1\nclass Solution {\npublic:\n    string reversePrefix(string word, char ch) {\n        for(int i = 0; i &lt; word.length(); i++) {\n            if(word[i] == ch) {\n                reverse(word.begin(), word.begin()+i+1);\n                break;\n            }\n        }\n        return word;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string reversePrefix(string word, char ch) {\n        size_t found = word.find(ch);\n        if (found != string::npos) {\n            reverse(word.begin(), word.begin()+found+1);\n            return word;\n        }\n        return word;\n    }\n};\n\n\n",
        "url": "/2022/04/16/2000-Reverse-Prefix-of-Word/"
      },
    
      {
        "title": "Count Number of Pairs With Absolute Difference K",
        "excerpt": "&lt;-E 2006&gt; Count Number of Pairs With Absolute Difference K\n\nclass Solution {\npublic:\n    int countKDifference(vector&lt;int&gt;&amp; nums, int k) {\n        int ans = 0;\n        int count[101] = {0};\n        for(int i = 0; i &lt; nums.size(); i++){\n            count[nums[i]]++;\n        }\n        for(int i = 1; i &lt; 101-k; i++){\n            ans += count[i]*count[i+k];\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 2006&gt; Count Number of Pairs With Absolute Difference K\n\nclass Solution {\npublic:\n    int countKDifference(vector&lt;int&gt;&amp; nums, int k) {\n        int ans = 0;\n        int count[101] = {0};\n        for(int i = 0; i &lt; nums.size(); i++){\n            count[nums[i]]++;\n        }\n        for(int i = 1; i &lt; 101-k; i++){\n            ans += count[i]*count[i+k];\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2022/04/16/2006-Count-Number-of-Pairs-With-Absolute-Difference-K/"
      },
    
      {
        "title": "Final Value of Variable After Performing Operations",
        "excerpt": "&lt;-E 2011&gt; Final Value of Variable After Performing Operations\n\n// Method 1\nclass Solution {\npublic:\n    int finalValueAfterOperations(vector&lt;string&gt;&amp; operations) {\n        int x = 0;\n        \n        for(auto op : operations){\n            (op == \"X++\" || op == \"++X\") ? x+=1 : x-=1;\n        }\n        \n        return x;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int finalValueAfterOperations(vector&lt;string&gt;&amp; str) {\n        int x=0;\n        for(int i=0;i&lt;str.size();i++)\n        {\n            if(str[i][1]=='+')\n                x++;\n            else\n                x--;\n        }\n        \n        return x;\n    }\n};\n\n\n",
        "content": "&lt;-E 2011&gt; Final Value of Variable After Performing Operations\n\n// Method 1\nclass Solution {\npublic:\n    int finalValueAfterOperations(vector&lt;string&gt;&amp; operations) {\n        int x = 0;\n        \n        for(auto op : operations){\n            (op == \"X++\" || op == \"++X\") ? x+=1 : x-=1;\n        }\n        \n        return x;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int finalValueAfterOperations(vector&lt;string&gt;&amp; str) {\n        int x=0;\n        for(int i=0;i&lt;str.size();i++)\n        {\n            if(str[i][1]=='+')\n                x++;\n            else\n                x--;\n        }\n        \n        return x;\n    }\n};\n\n\n",
        "url": "/2022/04/16/2011-Final-Value-of-Variable-After-Performing-Operations/"
      },
    
      {
        "title": "Maximum Difference Between Increasing Elements",
        "excerpt": "&lt;-E 2016&gt; Maximum Difference Between Increasing Elements\n\nclass Solution {\npublic:\n    int maximumDifference(vector&lt;int&gt;&amp; nums) {\n        int result = 0, prefix = INT_MAX;\n        for (auto x : nums) {\n            result = max(result, x - prefix);\n            prefix = min(prefix, x);\n        }\n        return result ? result : -1;\n    }\n};\n\n\n",
        "content": "&lt;-E 2016&gt; Maximum Difference Between Increasing Elements\n\nclass Solution {\npublic:\n    int maximumDifference(vector&lt;int&gt;&amp; nums) {\n        int result = 0, prefix = INT_MAX;\n        for (auto x : nums) {\n            result = max(result, x - prefix);\n            prefix = min(prefix, x);\n        }\n        return result ? result : -1;\n    }\n};\n\n\n",
        "url": "/2022/04/16/2016-Maximum-Difference-Between-Increasing-Elements/"
      },
    
      {
        "title": "Convert 1D Array Into 2D Array",
        "excerpt": "&lt;-E 2022&gt; Convert 1D Array Into 2D Array\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; construct2DArray(vector&lt;int&gt;&amp; original, int m, int n) {\n        if(original.size() != m * n) return {};\n\t\tvector&lt;vector&lt;int&gt;&gt; ans(m, vector&lt;int&gt;(n));\n\t\tfor(int i = 0, j = 0, k = 0; i&lt;original.size(); i++, j++){\n\t\t\tif(j == n){\n\t\t\t\tk++;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t\tans[k][j] = original[i];\n\t\t}\n\t\treturn ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 2022&gt; Convert 1D Array Into 2D Array\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; construct2DArray(vector&lt;int&gt;&amp; original, int m, int n) {\n        if(original.size() != m * n) return {};\n\t\tvector&lt;vector&lt;int&gt;&gt; ans(m, vector&lt;int&gt;(n));\n\t\tfor(int i = 0, j = 0, k = 0; i&lt;original.size(); i++, j++){\n\t\t\tif(j == n){\n\t\t\t\tk++;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t\tans[k][j] = original[i];\n\t\t}\n\t\treturn ans;\n    }\n};\n\n\n",
        "url": "/2022/04/16/2022-Convert-1D-Array-Into-2D-Array/"
      },
    
      {
        "title": "Minimum Moves to Convert String",
        "excerpt": "&lt;-E 2027&gt; Minimum Moves to Convert String\n\nclass Solution {\npublic:\n    int minimumMoves(string s) {\n        int res = 0;\n        for(int i = 0; i &lt; s.size(); i++){\n            if(s[i] == 'X'){\n                res++;\n                i += 2;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "content": "&lt;-E 2027&gt; Minimum Moves to Convert String\n\nclass Solution {\npublic:\n    int minimumMoves(string s) {\n        int res = 0;\n        for(int i = 0; i &lt; s.size(); i++){\n            if(s[i] == 'X'){\n                res++;\n                i += 2;\n            }\n        }\n        return res;\n    }\n};\n\n\n",
        "url": "/2022/04/16/2027-Minimum-Moves-to-Convert-String/"
      },
    
      {
        "title": "Two Out of Three",
        "excerpt": "&lt;-E 2032&gt; Two Out of Three\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) {\n        int check[101] = {0};\n        for(auto i : nums1) {\n            if(check[i] == 0)\n                check[i] = 1;\n        }\n        for(auto i : nums2) {\n            if(check[i] == 1)\n                check[i] = -1;\n            if(check[i] == 0)\n                check[i] = 2;\n        }\n        for(auto i : nums3) {\n            if(check[i] == 2)\n                check[i] = -1;\n            if(check[i] == 1)\n                check[i] = -1;\n        }\n        vector&lt;int&gt; ans;\n        for(int i = 0;i != 101; i++) {\n            if(check[i] == -1)\n                ans.push_back(i);\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) {\n        vector&lt;int&gt; count1(101);\n        vector&lt;int&gt; count2(101);\n        vector&lt;int&gt; count3(101);        \n        for (int x: nums1) count1[x] = 1;\n        for (int x: nums2) count2[x] = 1;\n        for (int x: nums3) count3[x] = 1;\n        vector&lt;int&gt; ans;\n        for (int i = 1; i &lt;= 100; ++i) {\n            if (count1[i] + count2[i] + count3[i] &gt;= 2) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "content": "&lt;-E 2032&gt; Two Out of Three\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) {\n        int check[101] = {0};\n        for(auto i : nums1) {\n            if(check[i] == 0)\n                check[i] = 1;\n        }\n        for(auto i : nums2) {\n            if(check[i] == 1)\n                check[i] = -1;\n            if(check[i] == 0)\n                check[i] = 2;\n        }\n        for(auto i : nums3) {\n            if(check[i] == 2)\n                check[i] = -1;\n            if(check[i] == 1)\n                check[i] = -1;\n        }\n        vector&lt;int&gt; ans;\n        for(int i = 0;i != 101; i++) {\n            if(check[i] == -1)\n                ans.push_back(i);\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) {\n        vector&lt;int&gt; count1(101);\n        vector&lt;int&gt; count2(101);\n        vector&lt;int&gt; count3(101);        \n        for (int x: nums1) count1[x] = 1;\n        for (int x: nums2) count2[x] = 1;\n        for (int x: nums3) count3[x] = 1;\n        vector&lt;int&gt; ans;\n        for (int i = 1; i &lt;= 100; ++i) {\n            if (count1[i] + count2[i] + count3[i] &gt;= 2) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};\n\n\n",
        "url": "/2022/04/16/2032-Two-Out-of-Three/"
      },
    
      {
        "title": "Minimum Number of Moves to Seat Everyone",
        "excerpt": "&lt;-E 2037&gt; Minimum Number of Moves to Seat Everyone\n\nclass Solution {\npublic:\n    int minMovesToSeat(vector&lt;int&gt;&amp; seats, vector&lt;int&gt;&amp; students) {\n        sort(seats.begin(),seats.end());\n        sort(students.begin(),students.end());\n        int ans = 0;\n        for(int i = 0; i &lt; seats.size(); i++) {\n            ans = ans + abs(seats[i] - students[i]);\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2037&gt; Minimum Number of Moves to Seat Everyone\n\nclass Solution {\npublic:\n    int minMovesToSeat(vector&lt;int&gt;&amp; seats, vector&lt;int&gt;&amp; students) {\n        sort(seats.begin(),seats.end());\n        sort(students.begin(),students.end());\n        int ans = 0;\n        for(int i = 0; i &lt; seats.size(); i++) {\n            ans = ans + abs(seats[i] - students[i]);\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2037-Minimum-Number-of-Moves-to-Seat-Everyone/"
      },
    
      {
        "title": "Check if Numbers Are Ascending in a Sentence",
        "excerpt": "&lt;-E 2042&gt; Check if Numbers Are Ascending in a Sentence\n\nclass Solution {\npublic:\n    bool areNumbersAscending(string s) {\n        int prev = INT_MIN;\n        int temp = 0;\n        for(int i = 0; i &lt; s.size(); i++) {\n            if(s[i] &lt;= '9' &amp;&amp; s[i] &gt;= '0') {\n\n                if(i + 1 &lt; s.size() &amp;&amp; (s[i+1] &lt;= '9' &amp;&amp; s[i+1] &gt;= '0')) {\n                    if(i + 2 &lt; s.size() &amp;&amp; (s[i+2] &lt;= '9' &amp;&amp; s[i+2] &gt;= '0')) {\n                        temp = (s[i] - '0') * 100 + (s[i+1] - '0') * 10 + (s[i+2] - '0');\n                        i = i + 2;\n                    } else {\n                        temp = (s[i] - '0') * 10 + (s[i+1] - '0');\n                        i = i + 1;\n                    }\n                }\n                else{\n                    temp =  s[i] - '0';\n                }\n                if(temp &lt;= prev)\n                    return false;\n                prev = temp;\n            }\n\n        }\n        return true;\n    }\n};\n\n",
        "content": "&lt;-E 2042&gt; Check if Numbers Are Ascending in a Sentence\n\nclass Solution {\npublic:\n    bool areNumbersAscending(string s) {\n        int prev = INT_MIN;\n        int temp = 0;\n        for(int i = 0; i &lt; s.size(); i++) {\n            if(s[i] &lt;= '9' &amp;&amp; s[i] &gt;= '0') {\n\n                if(i + 1 &lt; s.size() &amp;&amp; (s[i+1] &lt;= '9' &amp;&amp; s[i+1] &gt;= '0')) {\n                    if(i + 2 &lt; s.size() &amp;&amp; (s[i+2] &lt;= '9' &amp;&amp; s[i+2] &gt;= '0')) {\n                        temp = (s[i] - '0') * 100 + (s[i+1] - '0') * 10 + (s[i+2] - '0');\n                        i = i + 2;\n                    } else {\n                        temp = (s[i] - '0') * 10 + (s[i+1] - '0');\n                        i = i + 1;\n                    }\n                }\n                else{\n                    temp =  s[i] - '0';\n                }\n                if(temp &lt;= prev)\n                    return false;\n                prev = temp;\n            }\n\n        }\n        return true;\n    }\n};\n\n",
        "url": "/2022/04/16/2042-Check-if-Numbers-Are-Ascending-in-a-Sentence/"
      },
    
      {
        "title": "Number of Valid Words in a Sentence",
        "excerpt": "&lt;-E 2047&gt; Number of Valid Words in a Sentence\n\nclass Solution {\npublic:\n    bool solve(string s) {\n        int n = s.size();\n\n        int hy = 0;\n        for(int i = 0; i &lt; n; i++) {\n\n            if(isalpha(s[i]))\n                continue;\n\n            else if(isdigit(s[i]))\n                return false;\n\n            else if((s[i] == '.' || s[i] == ',' || s[i] == '!') &amp;&amp; i != n - 1)\n                return false;\n\n            else if(s[i] == '-') {\n                if(hy !=0 || i == 0 || i == n-1 ||\n                   !isalpha(s[i - 1]) || !isalpha(s[i + 1]))\n                    return false;\n                hy++;\n            }\n        }\n        return true;\n    }\n    int countValidWords(string s) {\n        stringstream ss(s);\n        string cur;\n        int cnt = 0;\n        while(ss &gt;&gt; cur)\n            if(solve(cur))\n                cnt++;\n\n        return cnt;\n    }\n};\n\n",
        "content": "&lt;-E 2047&gt; Number of Valid Words in a Sentence\n\nclass Solution {\npublic:\n    bool solve(string s) {\n        int n = s.size();\n\n        int hy = 0;\n        for(int i = 0; i &lt; n; i++) {\n\n            if(isalpha(s[i]))\n                continue;\n\n            else if(isdigit(s[i]))\n                return false;\n\n            else if((s[i] == '.' || s[i] == ',' || s[i] == '!') &amp;&amp; i != n - 1)\n                return false;\n\n            else if(s[i] == '-') {\n                if(hy !=0 || i == 0 || i == n-1 ||\n                   !isalpha(s[i - 1]) || !isalpha(s[i + 1]))\n                    return false;\n                hy++;\n            }\n        }\n        return true;\n    }\n    int countValidWords(string s) {\n        stringstream ss(s);\n        string cur;\n        int cnt = 0;\n        while(ss &gt;&gt; cur)\n            if(solve(cur))\n                cnt++;\n\n        return cnt;\n    }\n};\n\n",
        "url": "/2022/04/16/2047-Number-of-Valid-Words-in-a-Sentence/"
      },
    
      {
        "title": "Kth Distinct String in an Array",
        "excerpt": "&lt;-E 2053&gt; Kth Distinct String in an Array\n\nclass Solution {\npublic:\n    string kthDistinct(vector&lt;string&gt;&amp; arr, int k) {\n        unordered_map &lt;string,int&gt; table;\n        for(auto s : arr)\n            table[s]++;\n        for(auto s : arr)\n            if(table[s] == 1 &amp;&amp; --k == 0)\n                return s;\n        return \"\";\n\n    }\n};\n\n",
        "content": "&lt;-E 2053&gt; Kth Distinct String in an Array\n\nclass Solution {\npublic:\n    string kthDistinct(vector&lt;string&gt;&amp; arr, int k) {\n        unordered_map &lt;string,int&gt; table;\n        for(auto s : arr)\n            table[s]++;\n        for(auto s : arr)\n            if(table[s] == 1 &amp;&amp; --k == 0)\n                return s;\n        return \"\";\n\n    }\n};\n\n",
        "url": "/2022/04/16/2053-Kth-Distinct-String-in-an-Array/"
      },
    
      {
        "title": "Smallest Index With Equal Value",
        "excerpt": "&lt;-E 2057&gt; Smallest Index With Equal Value\n\nclass Solution {\npublic:\n    int smallestEqual(vector&lt;int&gt;&amp; nums) {\n        for(int i = 0; i&lt; nums.size(); i++){\n            if(i % 10 == nums[i])\n                return i;\n        }\n        return -1;\n    }\n};\n\n",
        "content": "&lt;-E 2057&gt; Smallest Index With Equal Value\n\nclass Solution {\npublic:\n    int smallestEqual(vector&lt;int&gt;&amp; nums) {\n        for(int i = 0; i&lt; nums.size(); i++){\n            if(i % 10 == nums[i])\n                return i;\n        }\n        return -1;\n    }\n};\n\n",
        "url": "/2022/04/16/2057-Smallest-Index-With-Equal-Value/"
      },
    
      {
        "title": "Count Vowel Substrings of a String",
        "excerpt": "&lt;-E 2062&gt; Count Vowel Substrings of a String\n\nclass Solution {\npublic:\n    int countVowelSubstrings(string word) {\n        unordered_map&lt;char,int&gt; m;\n        int n = word.size();\n        int ans = 0;\n\n        for(int i = 0,cnt = 0,j = 0,pref = 0; i &lt; n; i++) {\n            if((word[i] == 'a'|| word[i] == 'e'||\n                word[i] == 'i'|| word[i] == 'o'||\n                word[i] == 'u')) {\n                if(m[word[i]]++ == 0)\n                     cnt++;\n\n                while(m[word[j]] &gt; 1) {\n\t\t\t\t    m[word[j++]]--;\n                    pref++;\n                }\n\n                if(cnt == 5)\n                    ans += (1 + pref);\n            }\n            else {\n                   cnt = 0;\n                   pref = 0;\n                   m.clear();\n                   j = i + 1;\n               }\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2062&gt; Count Vowel Substrings of a String\n\nclass Solution {\npublic:\n    int countVowelSubstrings(string word) {\n        unordered_map&lt;char,int&gt; m;\n        int n = word.size();\n        int ans = 0;\n\n        for(int i = 0,cnt = 0,j = 0,pref = 0; i &lt; n; i++) {\n            if((word[i] == 'a'|| word[i] == 'e'||\n                word[i] == 'i'|| word[i] == 'o'||\n                word[i] == 'u')) {\n                if(m[word[i]]++ == 0)\n                     cnt++;\n\n                while(m[word[j]] &gt; 1) {\n\t\t\t\t    m[word[j++]]--;\n                    pref++;\n                }\n\n                if(cnt == 5)\n                    ans += (1 + pref);\n            }\n            else {\n                   cnt = 0;\n                   pref = 0;\n                   m.clear();\n                   j = i + 1;\n               }\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2062-Count-Vowel-Substrings-of-a-String/"
      },
    
      {
        "title": "Check Whether Two Strings are Almost Equivalent",
        "excerpt": "&lt;-E 2068&gt; Check Whether Two Strings are Almost Equivalent\n\nclass Solution {\npublic:\n    bool checkAlmostEquivalent(string word1, string word2) {\n        int check_1[26] = {0};\n        int check_2[26] = {0};\n        for(auto c : word1) {\n            check_1[c - 'a']++;\n        }\n        for(auto c : word2) {\n            check_2[c - 'a']++;\n        }\n        for(int i = 0; i != 26; i++) {\n            if(abs(check_1[i] - check_2[i]) &gt; 3)\n                return false;\n        }\n        return true;\n    }\n};\n\n",
        "content": "&lt;-E 2068&gt; Check Whether Two Strings are Almost Equivalent\n\nclass Solution {\npublic:\n    bool checkAlmostEquivalent(string word1, string word2) {\n        int check_1[26] = {0};\n        int check_2[26] = {0};\n        for(auto c : word1) {\n            check_1[c - 'a']++;\n        }\n        for(auto c : word2) {\n            check_2[c - 'a']++;\n        }\n        for(int i = 0; i != 26; i++) {\n            if(abs(check_1[i] - check_2[i]) &gt; 3)\n                return false;\n        }\n        return true;\n    }\n};\n\n",
        "url": "/2022/04/16/2068-Check-Whether-Two-Strings-are-Almost-Equivalent/"
      },
    
      {
        "title": "Time Needed to Buy Tickets",
        "excerpt": "&lt;-E 2073&gt; Time Needed to Buy Tickets\n\nclass Solution {\npublic:\n    int timeRequiredToBuy(vector&lt;int&gt;&amp; tickets, int k) {\n        int res = 0;\n        for(int i = 0; i &lt;= k; i++) {\n            res += min(tickets[k], tickets[i]);\n        }\n        for(int i = k + 1; i &lt; tickets.size(); i++) {\n            res += min(tickets[k] - 1 , tickets[i]);\n        }\n        return res;\n    }\n};\n\n",
        "content": "&lt;-E 2073&gt; Time Needed to Buy Tickets\n\nclass Solution {\npublic:\n    int timeRequiredToBuy(vector&lt;int&gt;&amp; tickets, int k) {\n        int res = 0;\n        for(int i = 0; i &lt;= k; i++) {\n            res += min(tickets[k], tickets[i]);\n        }\n        for(int i = k + 1; i &lt; tickets.size(); i++) {\n            res += min(tickets[k] - 1 , tickets[i]);\n        }\n        return res;\n    }\n};\n\n",
        "url": "/2022/04/16/2073-Time-Needed-to-Buy-Tickets/"
      },
    
      {
        "title": "Two Furthest Houses With Different Colors",
        "excerpt": "&lt;-E 2078&gt; Two Furthest Houses With Different Colors\n\nclass Solution {\npublic:\n    int maxDistance(vector&lt;int&gt;&amp; colors) {\n        int result = 0;\n        int size = colors.size();\n        for(int x = 0; x &lt; size; x++){\n            for(int y = x + 1; y &lt; size; y++){\n                if(colors[x] != colors[y])\n                    result = max(result, abs(x - y));\n            }\n        }\n\n        return result;\n    }\n};\n\n",
        "content": "&lt;-E 2078&gt; Two Furthest Houses With Different Colors\n\nclass Solution {\npublic:\n    int maxDistance(vector&lt;int&gt;&amp; colors) {\n        int result = 0;\n        int size = colors.size();\n        for(int x = 0; x &lt; size; x++){\n            for(int y = x + 1; y &lt; size; y++){\n                if(colors[x] != colors[y])\n                    result = max(result, abs(x - y));\n            }\n        }\n\n        return result;\n    }\n};\n\n",
        "url": "/2022/04/16/2078-Two-Furthest-Houses-With-Different-Colors/"
      },
    
      {
        "title": "Count Common Words With One Occurrence",
        "excerpt": "&lt;-E 2085&gt; Count Common Words With One Occurrence\n\nclass Solution {\npublic:\n    int countWords(vector&lt;string&gt;&amp; words1, vector&lt;string&gt;&amp; words2) {\n        unordered_map&lt;string, int&gt; mp1;\n        unordered_map&lt;string, int&gt; mp2;\n        for (auto x : words1)\n            mp1[x]++;\n\n        for (auto x : words2)\n            mp2[x]++;\n\n        int k = 0;\n        for (auto x : mp1) {\n            string s = x.first;\n            if (mp2.find(s) != mp2.end() &amp;&amp; mp1[s] == 1 &amp;&amp; mp2[s] == 1)\n                k++;\n        }\n        return k;\n    }\n};\n\n",
        "content": "&lt;-E 2085&gt; Count Common Words With One Occurrence\n\nclass Solution {\npublic:\n    int countWords(vector&lt;string&gt;&amp; words1, vector&lt;string&gt;&amp; words2) {\n        unordered_map&lt;string, int&gt; mp1;\n        unordered_map&lt;string, int&gt; mp2;\n        for (auto x : words1)\n            mp1[x]++;\n\n        for (auto x : words2)\n            mp2[x]++;\n\n        int k = 0;\n        for (auto x : mp1) {\n            string s = x.first;\n            if (mp2.find(s) != mp2.end() &amp;&amp; mp1[s] == 1 &amp;&amp; mp2[s] == 1)\n                k++;\n        }\n        return k;\n    }\n};\n\n",
        "url": "/2022/04/16/2085-Count-Common-Words-With-One-Occurrence/"
      },
    
      {
        "title": "Find Target Indices After Sorting Array",
        "excerpt": "&lt;-E 2089&gt; Find Target Indices After Sorting Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; targetIndices(vector&lt;int&gt;&amp; nums, int target) {\n        sort(nums.begin(), nums.end());\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != nums.size(); i++) {\n            if(nums[i] == target) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; targetIndices(vector&lt;int&gt;&amp; nums, int target) {\n        int smaller = 0;\n        int target_number = 0;\n        for(int i : nums) {\n            if(i &lt; target) {\n                smaller++;\n            } else if(i == target) {\n                target_number++;\n            }\n        }\n        vector&lt;int&gt; ans;\n        while(t) {\n            ans.push_back(smaller);\n            smaller++;\n            target_number--;\n        }\n\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2089&gt; Find Target Indices After Sorting Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; targetIndices(vector&lt;int&gt;&amp; nums, int target) {\n        sort(nums.begin(), nums.end());\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != nums.size(); i++) {\n            if(nums[i] == target) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; targetIndices(vector&lt;int&gt;&amp; nums, int target) {\n        int smaller = 0;\n        int target_number = 0;\n        for(int i : nums) {\n            if(i &lt; target) {\n                smaller++;\n            } else if(i == target) {\n                target_number++;\n            }\n        }\n        vector&lt;int&gt; ans;\n        while(t) {\n            ans.push_back(smaller);\n            smaller++;\n            target_number--;\n        }\n\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2089-Find-Target-Indices-After-Sorting-Array/"
      },
    
      {
        "title": "Finding 3-Digit Even Numbers",
        "excerpt": "&lt;-E 2094&gt; Finding 3-Digit Even Numbers\n\nclass Solution {\npublic:\n    vector&lt;int&gt; findEvenNumbers(vector&lt;int&gt;&amp; digits) {\n        int count[10] = {0};\n        vector&lt;int&gt; res;\n\n        for(int d : digits)\n            count[d]++;\n        for(int i = 1; i &lt; 10; i++) {\n            if(count[i] == 0)\n                continue;\n            count[i]--;\n            for(int j = 0; j &lt; 10; j++) {\n                if(count[j] == 0)\n                    continue;\n                count[j]--;\n                for(int k = 0; k &lt; 10; k += 2) {\n                    if(count[k] == 0)\n                        continue;\n                    res.push_back(i * 100 + j * 10 + k);\n                }\n                count[j]++;\n            }\n            count[i]++;\n        }\n        return res;\n    }\n};\n\n",
        "content": "&lt;-E 2094&gt; Finding 3-Digit Even Numbers\n\nclass Solution {\npublic:\n    vector&lt;int&gt; findEvenNumbers(vector&lt;int&gt;&amp; digits) {\n        int count[10] = {0};\n        vector&lt;int&gt; res;\n\n        for(int d : digits)\n            count[d]++;\n        for(int i = 1; i &lt; 10; i++) {\n            if(count[i] == 0)\n                continue;\n            count[i]--;\n            for(int j = 0; j &lt; 10; j++) {\n                if(count[j] == 0)\n                    continue;\n                count[j]--;\n                for(int k = 0; k &lt; 10; k += 2) {\n                    if(count[k] == 0)\n                        continue;\n                    res.push_back(i * 100 + j * 10 + k);\n                }\n                count[j]++;\n            }\n            count[i]++;\n        }\n        return res;\n    }\n};\n\n",
        "url": "/2022/04/16/2094-Finding-3-Digit-Even-Numbers/"
      },
    
      {
        "title": "Find Subsequence of Length K With the Largest Sum",
        "excerpt": "&lt;-E 2099&gt; Find Subsequence of Length K With the Largest Sum\n\nclass Solution {\npublic:\n    vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) {\n        vector&lt;int&gt; ans,temp(nums.begin(),nums.end());\n\n        sort(temp.begin(),temp.end(),greater&lt;int&gt;());\n\n        temp.resize(k);\n\n        unordered_map&lt;int,int&gt; m;\n\n        for(int i : temp)\n            m[i]++;\n\n        for(int i : nums)\n            if(m[i] != 0) {\n                ans.push_back(i);\n                m[i]--;\n            }\n\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2099&gt; Find Subsequence of Length K With the Largest Sum\n\nclass Solution {\npublic:\n    vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) {\n        vector&lt;int&gt; ans,temp(nums.begin(),nums.end());\n\n        sort(temp.begin(),temp.end(),greater&lt;int&gt;());\n\n        temp.resize(k);\n\n        unordered_map&lt;int,int&gt; m;\n\n        for(int i : temp)\n            m[i]++;\n\n        for(int i : nums)\n            if(m[i] != 0) {\n                ans.push_back(i);\n                m[i]--;\n            }\n\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2099-Find-Subsequence-of-Length-K-With-the-Largest-Sum/"
      },
    
      {
        "title": "Rings and Rods",
        "excerpt": "&lt;-E 2103&gt; Rings and Rods\n\n// Method 1\nclass Solution {\npublic:\n    int countPoints(string rings) {\n        unordered_map&lt;int,set&lt;char&gt;&gt; um;\n        for(int i = 0; i &lt; rings.size() - 1; i+=2) {\n            um[rings[i + 1]].insert(rings[i]);\n        }\n        int ans=0;\n        for(auto i:um)\n            if(i.second.size() == 3)\n                ans++;\n\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countPoints(string rings) {\n        vector&lt;vector&lt;bool&gt;&gt; stat(10, vector&lt;bool&gt;(3, false));\n\n        for(int i = 0; i &lt; rings.size(); i += 2)\n            if(rings[i] == 'R')\n                stat[rings[i + 1] - '0'][0] = true;\n             else if(rings[i] == 'G')\n                stat[rings[i + 1] - '0'][1] = true;\n             else\n                stat[rings[i + 1] - '0'][2] = true;\n\n\n        int count = 0;\n\n        for(vector&lt;bool&gt;&amp; r : stat)\n            if(r[0] &amp;&amp; r[1] &amp;&amp; r[2])\n                count++;\n\n        return count;\n    }\n};\n\n",
        "content": "&lt;-E 2103&gt; Rings and Rods\n\n// Method 1\nclass Solution {\npublic:\n    int countPoints(string rings) {\n        unordered_map&lt;int,set&lt;char&gt;&gt; um;\n        for(int i = 0; i &lt; rings.size() - 1; i+=2) {\n            um[rings[i + 1]].insert(rings[i]);\n        }\n        int ans=0;\n        for(auto i:um)\n            if(i.second.size() == 3)\n                ans++;\n\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countPoints(string rings) {\n        vector&lt;vector&lt;bool&gt;&gt; stat(10, vector&lt;bool&gt;(3, false));\n\n        for(int i = 0; i &lt; rings.size(); i += 2)\n            if(rings[i] == 'R')\n                stat[rings[i + 1] - '0'][0] = true;\n             else if(rings[i] == 'G')\n                stat[rings[i + 1] - '0'][1] = true;\n             else\n                stat[rings[i + 1] - '0'][2] = true;\n\n\n        int count = 0;\n\n        for(vector&lt;bool&gt;&amp; r : stat)\n            if(r[0] &amp;&amp; r[1] &amp;&amp; r[2])\n                count++;\n\n        return count;\n    }\n};\n\n",
        "url": "/2022/04/16/2103-Rings-and-Rods/"
      },
    
      {
        "title": "Find First Palindromic String in the Array",
        "excerpt": "&lt;-E 2108&gt; Find First Palindromic String in the Array\n\nclass Solution {\npublic:\n    string firstPalindrome(vector&lt;string&gt;&amp; words) {\n        for(auto word : words){\n            int p1 = 0;\n            int p2 = word.size() - 1;\n            string a = word;\n            while(p1 &lt; p2){\n                if(a[p1] !=a [p2]) {\n                    break;\n                }\n                p1++;\n                p2--;\n            }\n            if((p1 == p2) || ((p1 - p2)==1))\n                return a;\n        }\n        return \"\";\n    }\n};\n\n",
        "content": "&lt;-E 2108&gt; Find First Palindromic String in the Array\n\nclass Solution {\npublic:\n    string firstPalindrome(vector&lt;string&gt;&amp; words) {\n        for(auto word : words){\n            int p1 = 0;\n            int p2 = word.size() - 1;\n            string a = word;\n            while(p1 &lt; p2){\n                if(a[p1] !=a [p2]) {\n                    break;\n                }\n                p1++;\n                p2--;\n            }\n            if((p1 == p2) || ((p1 - p2)==1))\n                return a;\n        }\n        return \"\";\n    }\n};\n\n",
        "url": "/2022/04/16/2108-Find-First-Palindromic-String-in-the-Array/"
      },
    
      {
        "title": "Maximum Number of Words Found in Sentences",
        "excerpt": "&lt;-E 2114&gt; Maximum Number of Words Found in Sentences\n\n// Method 1\nclass Solution {\npublic:\n    int mostWordsFound(vector&lt;string&gt;&amp; sentences) {\n        int ans = 0;\n        for(auto sentence : sentences) {\n            int cn_words = 1;\n            for(auto word : sentence) {\n                if(word == ' ')\n                    cn_words++;\n            }\n            if(cn_words &gt; ans)\n                ans = cn_words;\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int mostWordsFound(vector&lt;string&gt;&amp; sentences) {\n        int ans = 0;\n        for(auto s: sentences){\n            ans = std::max(ans, (int)(count(s.begin(), s.end(), ' ')));\n        }\n        return ans + 1;\n    }\n};\n\n",
        "content": "&lt;-E 2114&gt; Maximum Number of Words Found in Sentences\n\n// Method 1\nclass Solution {\npublic:\n    int mostWordsFound(vector&lt;string&gt;&amp; sentences) {\n        int ans = 0;\n        for(auto sentence : sentences) {\n            int cn_words = 1;\n            for(auto word : sentence) {\n                if(word == ' ')\n                    cn_words++;\n            }\n            if(cn_words &gt; ans)\n                ans = cn_words;\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int mostWordsFound(vector&lt;string&gt;&amp; sentences) {\n        int ans = 0;\n        for(auto s: sentences){\n            ans = std::max(ans, (int)(count(s.begin(), s.end(), ' ')));\n        }\n        return ans + 1;\n    }\n};\n\n",
        "url": "/2022/04/16/2114-Maximum-Number-of-Words-Found-in-Sentences/"
      },
    
      {
        "title": "A Number After a Double Reversal",
        "excerpt": "&lt;-E 2119&gt; A Number After a Double Reversal\n\nclass Solution {\npublic:\n    bool isSameAfterReversals(int num) {\n        if(num == 0)\n            return true;\n        if(num % 10)\n            return true;\n        else\n            return false;\n    }\n};\n\n",
        "content": "&lt;-E 2119&gt; A Number After a Double Reversal\n\nclass Solution {\npublic:\n    bool isSameAfterReversals(int num) {\n        if(num == 0)\n            return true;\n        if(num % 10)\n            return true;\n        else\n            return false;\n    }\n};\n\n",
        "url": "/2022/04/16/2119-A-Number-After-a-Double-Reversal/"
      },
    
      {
        "title": "Check if All A's Appears Before All B's",
        "excerpt": "&lt;-E 2124&gt; Check if All A’s Appears Before All B’s\n\nclass Solution {\npublic:\n    bool checkString(string s) {\n        int i = 0;\n        for(; i != s.size(); i++) {\n            if(s[i] == 'b')\n                break;\n        }\n        if(find(s.begin() + i, s.end(), 'a') != s.end())\n            return false;\n        return true;\n    }\n};\n\n",
        "content": "&lt;-E 2124&gt; Check if All A’s Appears Before All B’s\n\nclass Solution {\npublic:\n    bool checkString(string s) {\n        int i = 0;\n        for(; i != s.size(); i++) {\n            if(s[i] == 'b')\n                break;\n        }\n        if(find(s.begin() + i, s.end(), 'a') != s.end())\n            return false;\n        return true;\n    }\n};\n\n",
        "url": "/2022/04/16/2124-Check-if-All-A's-Appears-Before-All-B's/"
      },
    
      {
        "title": "Capitalize the Title",
        "excerpt": "&lt;-E 2129&gt; Capitalize the Title\n\n// Method 1\nclass Solution {\npublic:\n    string capitalizeTitle(string title) {\n         for(int i = 0; i &lt; title.size(); i++) {\n            if((i ==0 || title[i - 1]==' ') &amp;&amp;\n               (i + 1 &lt; title.size() &amp;&amp; title[i + 1] !=' ' &amp;&amp;\n                i + 2 &lt; title.size() &amp;&amp; title[i+2] != ' '))\n                title[i]= toupper(title[i]);\n            else\n                title[i]= tolower(title[i]);\n        }\n        return title;\n    }\n};\n\n",
        "content": "&lt;-E 2129&gt; Capitalize the Title\n\n// Method 1\nclass Solution {\npublic:\n    string capitalizeTitle(string title) {\n         for(int i = 0; i &lt; title.size(); i++) {\n            if((i ==0 || title[i - 1]==' ') &amp;&amp;\n               (i + 1 &lt; title.size() &amp;&amp; title[i + 1] !=' ' &amp;&amp;\n                i + 2 &lt; title.size() &amp;&amp; title[i+2] != ' '))\n                title[i]= toupper(title[i]);\n            else\n                title[i]= tolower(title[i]);\n        }\n        return title;\n    }\n};\n\n",
        "url": "/2022/04/16/2129-Capitalize-the-Title/"
      },
    
      {
        "title": "Check if Every Row and Column Contains All Numbers",
        "excerpt": "&lt;-E 2133&gt; Check if Every Row and Column Contains All Numbers\n\n// Method 1\nclass Solution {\npublic:\n    bool checkValid(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        if(matrix.size() != matrix[0].size())\n            return false;\n\n        set&lt;int&gt; check_each;\n        for(int i = 0; i != matrix.size(); i++) {\n           for(int j = 0; j != matrix[0].size(); j++) {\n                check_each.insert(matrix[i][j]);\n           }\n            if(matrix.size() != check_each.size())\n                    return false;\n            else\n                check_each.clear();\n        }\n\n        check_each.clear();\n        for(int i = 0; i != matrix.size(); i++) {\n           for(int j = 0; j != matrix[0].size(); j++) {\n                check_each.insert(matrix[j][i]);\n           }\n            if(matrix.size() != check_each.size())\n                    return false;\n            else\n                check_each.clear();\n        }\n        return true;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool checkValid(vector&lt;vector&lt;int&gt;&gt;&amp; m) {\n        int n = m.size();\n        for(int i = 0; i &lt; n; i++) {\n            vector&lt;bool&gt; r(n);\n            for(int j = 0; j &lt; n; j++) {\n                if(r[m[i][j] - 1] == true)  return false;\n                r[m[i][j] - 1] = true;\n            }\n        }\n\n        for(int i = 0; i &lt; n; i++) {\n            vector&lt;bool&gt; c(n);\n            for(int j = 0; j &lt; n; j++) {\n                if(c[m[j][i] - 1] == true)  return false;\n                c[m[j][i] - 1] = true;\n            }\n        }\n\n        return true;\n    }\n};\n\n",
        "content": "&lt;-E 2133&gt; Check if Every Row and Column Contains All Numbers\n\n// Method 1\nclass Solution {\npublic:\n    bool checkValid(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        if(matrix.size() != matrix[0].size())\n            return false;\n\n        set&lt;int&gt; check_each;\n        for(int i = 0; i != matrix.size(); i++) {\n           for(int j = 0; j != matrix[0].size(); j++) {\n                check_each.insert(matrix[i][j]);\n           }\n            if(matrix.size() != check_each.size())\n                    return false;\n            else\n                check_each.clear();\n        }\n\n        check_each.clear();\n        for(int i = 0; i != matrix.size(); i++) {\n           for(int j = 0; j != matrix[0].size(); j++) {\n                check_each.insert(matrix[j][i]);\n           }\n            if(matrix.size() != check_each.size())\n                    return false;\n            else\n                check_each.clear();\n        }\n        return true;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool checkValid(vector&lt;vector&lt;int&gt;&gt;&amp; m) {\n        int n = m.size();\n        for(int i = 0; i &lt; n; i++) {\n            vector&lt;bool&gt; r(n);\n            for(int j = 0; j &lt; n; j++) {\n                if(r[m[i][j] - 1] == true)  return false;\n                r[m[i][j] - 1] = true;\n            }\n        }\n\n        for(int i = 0; i &lt; n; i++) {\n            vector&lt;bool&gt; c(n);\n            for(int j = 0; j &lt; n; j++) {\n                if(c[m[j][i] - 1] == true)  return false;\n                c[m[j][i] - 1] = true;\n            }\n        }\n\n        return true;\n    }\n};\n\n",
        "url": "/2022/04/16/2133-Check-if-Every-Row-and-Column-Contains-All-Numbers/"
      },
    
      {
        "title": "Divide a String Into Groups of Size k",
        "excerpt": "&lt;-E 2138&gt; Divide a String Into Groups of Size k\n\nclass Solution {\npublic:\n    vector&lt;string&gt; divideString(string s, int k, char fill) {\n\n        while(s.size() % k != 0)\n            s += fill;\n\n        vector&lt;string&gt; v;\n        string sub;\n\n        for(int i = 0; i &lt; s.size(); i = i + k) {\n            sub = \"\";\n            sub = s.substr(i,k);\n            v.push_back(sub);\n        }\n        return v;\n    }\n};\n\n",
        "content": "&lt;-E 2138&gt; Divide a String Into Groups of Size k\n\nclass Solution {\npublic:\n    vector&lt;string&gt; divideString(string s, int k, char fill) {\n\n        while(s.size() % k != 0)\n            s += fill;\n\n        vector&lt;string&gt; v;\n        string sub;\n\n        for(int i = 0; i &lt; s.size(); i = i + k) {\n            sub = \"\";\n            sub = s.substr(i,k);\n            v.push_back(sub);\n        }\n        return v;\n    }\n};\n\n",
        "url": "/2022/04/16/2138-Divide-a-String-Into-Groups-of-Size-k/"
      },
    
      {
        "title": "Minimum Cost of Buying Candies With Discount",
        "excerpt": "&lt;-E 2144&gt; Minimum Cost of Buying Candies With Discount\n\nclass Solution {\npublic:\n    int minimumCost(vector&lt;int&gt;&amp; cost) {\n        sort(cost.begin(), cost.end(), greater&lt;int&gt;());\n        int ans = 0;\n        int k = 0;\n        for(auto i : cost) {\n            k++;\n            if(k == 3)\n                k = 0;\n            else\n                ans += i;\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2144&gt; Minimum Cost of Buying Candies With Discount\n\nclass Solution {\npublic:\n    int minimumCost(vector&lt;int&gt;&amp; cost) {\n        sort(cost.begin(), cost.end(), greater&lt;int&gt;());\n        int ans = 0;\n        int k = 0;\n        for(auto i : cost) {\n            k++;\n            if(k == 3)\n                k = 0;\n            else\n                ans += i;\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2144-Minimum-Cost-of-Buying-Candies-With-Discount/"
      },
    
      {
        "title": "Count Elements With Strictly Smaller and Greater Elements",
        "excerpt": "&lt;-E 2148&gt; Count Elements With Strictly Smaller and Greater Elements\n\nclass Solution {\npublic:\n    int countElements(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        int check = 0;\n        for(auto i : nums) {\n            if(i == nums[0])\n                check++;\n            else if(i == nums[nums.size() - 1])\n                check++;\n        }\n        return nums.size() - check;\n    }\n};\n\n",
        "content": "&lt;-E 2148&gt; Count Elements With Strictly Smaller and Greater Elements\n\nclass Solution {\npublic:\n    int countElements(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        int check = 0;\n        for(auto i : nums) {\n            if(i == nums[0])\n                check++;\n            else if(i == nums[nums.size() - 1])\n                check++;\n        }\n        return nums.size() - check;\n    }\n};\n\n",
        "url": "/2022/04/16/2148-Count-Elements-With-Strictly-Smaller-and-Greater-Elements/"
      },
    
      {
        "title": "Minimum Sum of Four Digit Number After Splitting Digits",
        "excerpt": "&lt;-E 2160&gt; Minimum Sum of Four Digit Number After Splitting Digits\n\nclass Solution {\npublic:\n    int minimumSum(int num) {\n        string s = to_string(num);\n        sort(s.begin(), s.end());\n\n        return (s[0] - '0' + s[1] - '0') * 10\n        + (s[2] - '0') + (s[3] - '0');\n    }\n};\n\n",
        "content": "&lt;-E 2160&gt; Minimum Sum of Four Digit Number After Splitting Digits\n\nclass Solution {\npublic:\n    int minimumSum(int num) {\n        string s = to_string(num);\n        sort(s.begin(), s.end());\n\n        return (s[0] - '0' + s[1] - '0') * 10\n        + (s[2] - '0') + (s[3] - '0');\n    }\n};\n\n",
        "url": "/2022/04/16/2160-Minimum-Sum-of-Four-Digit-Number-After-Splitting-Digits/"
      },
    
      {
        "title": "Sort Even and Odd Indices Independently",
        "excerpt": "&lt;-E 2164&gt; Sort Even and Odd Indices Independently\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) {\n        size_t size = nums.size();\n        priority_queue&lt;int, vector&lt;int&gt;,    less&lt;int&gt;&gt; max_heap;\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;\n\n        for (size_t s = 0; s &lt; size; s++)\n            s % 2 == 0 ? min_heap.push(nums[s]) : max_heap.push(nums[s]);\n\n        for (size_t s = 0; s &lt; size; s++)\n            if (s % 2 == 0)\n                nums[s] = min_heap.top(), min_heap.pop();\n            else\n                nums[s] = max_heap.top(), max_heap.pop();\n\n\n        return nums;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt;e, o;\n        for(int i=0;i&lt;nums.size();i++) {\n            if(i%2) o.push_back(nums[i]);\n            else e.push_back(nums[i]);\n        }\n        sort(e.begin(), e.end());\n        sort(o.begin(), o.end(), greater&lt;int&gt;());\n        for(int i=0;i&lt;e.size();i++) nums[2*i] = e[i];\n        for(int i=0;i&lt;o.size();i++) nums[2*i+1] = o[i];\n        return nums;\n    }\n};\n\n",
        "content": "&lt;-E 2164&gt; Sort Even and Odd Indices Independently\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) {\n        size_t size = nums.size();\n        priority_queue&lt;int, vector&lt;int&gt;,    less&lt;int&gt;&gt; max_heap;\n        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;\n\n        for (size_t s = 0; s &lt; size; s++)\n            s % 2 == 0 ? min_heap.push(nums[s]) : max_heap.push(nums[s]);\n\n        for (size_t s = 0; s &lt; size; s++)\n            if (s % 2 == 0)\n                nums[s] = min_heap.top(), min_heap.pop();\n            else\n                nums[s] = max_heap.top(), max_heap.pop();\n\n\n        return nums;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt;e, o;\n        for(int i=0;i&lt;nums.size();i++) {\n            if(i%2) o.push_back(nums[i]);\n            else e.push_back(nums[i]);\n        }\n        sort(e.begin(), e.end());\n        sort(o.begin(), o.end(), greater&lt;int&gt;());\n        for(int i=0;i&lt;e.size();i++) nums[2*i] = e[i];\n        for(int i=0;i&lt;o.size();i++) nums[2*i+1] = o[i];\n        return nums;\n    }\n};\n\n",
        "url": "/2022/04/16/2164-Sort-Even-and-Odd-Indices-Independently/"
      },
    
      {
        "title": "Count Operations to Obtain Zero",
        "excerpt": "&lt;-E 2169&gt; Count Operations to Obtain Zero\n\nclass Solution {\npublic:\n    int countOperations(int num1, int num2) {\n\n        int ans = 0;\n        while(true) {\n            if(num1 == 0)\n                break;\n            if(num2 == 0)\n                break;\n            if(num2 &gt; num1)\n                swap(num2, num1);\n            num1 = num1 - num2;\n            ans++;\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2169&gt; Count Operations to Obtain Zero\n\nclass Solution {\npublic:\n    int countOperations(int num1, int num2) {\n\n        int ans = 0;\n        while(true) {\n            if(num1 == 0)\n                break;\n            if(num2 == 0)\n                break;\n            if(num2 &gt; num1)\n                swap(num2, num1);\n            num1 = num1 - num2;\n            ans++;\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2169-Count-Operations-to-Obtain-Zero/"
      },
    
      {
        "title": "Count Equal and Divisible Pairs in an Array",
        "excerpt": "&lt;-E 2176&gt; Count Equal and Divisible Pairs in an Array\n\nclass Solution {\npublic:\n    int countPairs(vector&lt;int&gt;&amp; nums, int k) {\n        int ans = 0;\n        for(int i = 0; i != nums.size(); i++) {\n            for(int j = i + 1; j &lt; nums.size(); j++) {\n                if(nums[i] == nums[j]) {\n                    if(!(i * j % k))\n                        ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2176&gt; Count Equal and Divisible Pairs in an Array\n\nclass Solution {\npublic:\n    int countPairs(vector&lt;int&gt;&amp; nums, int k) {\n        int ans = 0;\n        for(int i = 0; i != nums.size(); i++) {\n            for(int j = i + 1; j &lt; nums.size(); j++) {\n                if(nums[i] == nums[j]) {\n                    if(!(i * j % k))\n                        ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2176-Count-Equal-and-Divisible-Pairs-in-an-Array/"
      },
    
      {
        "title": "Count Integers With Even Digit Sum",
        "excerpt": "&lt;-E 2180&gt; Count Integers With Even Digit Sum\n\nclass Solution {\npublic:\n    int findsum(int n) {\n        int sum = 0;\n        while (n &gt; 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n\n    int countEven(int num) {\n        int r = num % 10;\n        int q = num / 10;\n        int sum = q * 5 - 1;\n        q = findsum(q);\n        if (q % 2 == 0 || !(r % 2 == 0))\n            sum += r / 2 + 1;\n        else\n            sum += r / 2;\n        return sum;\n    }\n};\n\n",
        "content": "&lt;-E 2180&gt; Count Integers With Even Digit Sum\n\nclass Solution {\npublic:\n    int findsum(int n) {\n        int sum = 0;\n        while (n &gt; 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n\n    int countEven(int num) {\n        int r = num % 10;\n        int q = num / 10;\n        int sum = q * 5 - 1;\n        q = findsum(q);\n        if (q % 2 == 0 || !(r % 2 == 0))\n            sum += r / 2 + 1;\n        else\n            sum += r / 2;\n        return sum;\n    }\n};\n\n",
        "url": "/2022/04/16/2180-Count-Integers-With-Even-Digit-Sum/"
      },
    
      {
        "title": "Counting Words With a Given Prefix",
        "excerpt": "&lt;-E 2185&gt; Counting Words With a Given Prefix\n\nclass Solution {\npublic:\n    int prefixCount(vector&lt;string&gt;&amp; words, string pref) {\n        int ans = 0;\n        for(auto word : words) {\n            bool check = true;\n            for(int i = 0; i != pref.size(); i++) {\n                if(word[i] !=  pref[i]) {\n                    check = false;\n                    break;\n                }\n                if(i == word.size()) {\n                    check = false;\n                    break;\n                }\n            }\n            if(check == true)\n                ans++;\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2185&gt; Counting Words With a Given Prefix\n\nclass Solution {\npublic:\n    int prefixCount(vector&lt;string&gt;&amp; words, string pref) {\n        int ans = 0;\n        for(auto word : words) {\n            bool check = true;\n            for(int i = 0; i != pref.size(); i++) {\n                if(word[i] !=  pref[i]) {\n                    check = false;\n                    break;\n                }\n                if(i == word.size()) {\n                    check = false;\n                    break;\n                }\n            }\n            if(check == true)\n                ans++;\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2185-Counting-Words-With-a-Given-Prefix/"
      },
    
      {
        "title": "Most Frequent Number Following Key In an Array",
        "excerpt": "&lt;-E 2190&gt; Most Frequent Number Following Key In an Array\n\nclass Solution {\npublic:\n    int mostFrequent(vector&lt;int&gt;&amp; nums, int key) {\n        unordered_map&lt;int, int&gt; h;\n        for (int i = 0; i &lt; nums.size() - 1; i++) {\n            if (nums[i] == key) {\n                h[nums[i + 1]]++;\n            }\n        }\n        int ret = 0, maxOccurence = 0;\n        for (const auto&amp; [k, v]: h) {\n            if (v &gt; maxOccurence) {\n                maxOccurence = v;\n                ret = k;\n            }\n        }\n        return ret;\n    }\n};\n\n",
        "content": "&lt;-E 2190&gt; Most Frequent Number Following Key In an Array\n\nclass Solution {\npublic:\n    int mostFrequent(vector&lt;int&gt;&amp; nums, int key) {\n        unordered_map&lt;int, int&gt; h;\n        for (int i = 0; i &lt; nums.size() - 1; i++) {\n            if (nums[i] == key) {\n                h[nums[i + 1]]++;\n            }\n        }\n        int ret = 0, maxOccurence = 0;\n        for (const auto&amp; [k, v]: h) {\n            if (v &gt; maxOccurence) {\n                maxOccurence = v;\n                ret = k;\n            }\n        }\n        return ret;\n    }\n};\n\n",
        "url": "/2022/04/16/2190-Most-Frequent-Number-Following-Key-In-an-Array/"
      },
    
      {
        "title": "Cells in a Range on an Excel Sheet",
        "excerpt": "&lt;-E 2194&gt; Cells in a Range on an Excel Sheet\n\nclass Solution {\npublic:\n    vector&lt;string&gt; cellsInRange(string s) {\n        vector&lt;string&gt; ans;\n        string a;\n\n        for(char i = s[0]; i &lt;= s[3]; i++) {\n            for(char j = s[1]; j &lt;= s[4]; j++) {\n               ans.push_back({i,j});\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2194&gt; Cells in a Range on an Excel Sheet\n\nclass Solution {\npublic:\n    vector&lt;string&gt; cellsInRange(string s) {\n        vector&lt;string&gt; ans;\n        string a;\n\n        for(char i = s[0]; i &lt;= s[3]; i++) {\n            for(char j = s[1]; j &lt;= s[4]; j++) {\n               ans.push_back({i,j});\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2194-Cells-in-a-Range-on-an-Excel-Sheet/"
      },
    
      {
        "title": "Find All K-Distant Indices in an Array",
        "excerpt": "&lt;-E 2200&gt; Find All K-Distant Indices in an Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; findKDistantIndices(vector&lt;int&gt;&amp; nums, int key, int k) {\n        int n=nums.size();\n        vector&lt;int&gt; v;\n\n        for(int i = 0; i &lt; n; i++) {\n            if(nums[i] == key) {\n                int start = max(0, i - k);\n                int end = min(n - 1, i + k);\n\n                if(v.size() != 0)\n                    start = max(v[v.size() - 1] + 1, start);\n\n                for(int j = start; j &lt;= end; j++) {\n                    v.push_back(j);\n                }\n            }\n        }\n        return v;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; findKDistantIndices(vector&lt;int&gt;&amp; nums, int key, int k) {\n        set&lt;int&gt; st;\n\n        for(int i = 0; i &lt; nums.size(); i++){\n            if(nums[i] == key){\n                for(int j = i - k; j &lt;= i + k; j++){\n                    if(j &gt;=0 &amp;&amp; j &lt; nums.size())\n                        st.insert(j);\n                }\n            }\n        }\n\n        return vector&lt;int&gt;(st.begin(), st.end());\n    }\n};\n\n",
        "content": "&lt;-E 2200&gt; Find All K-Distant Indices in an Array\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; findKDistantIndices(vector&lt;int&gt;&amp; nums, int key, int k) {\n        int n=nums.size();\n        vector&lt;int&gt; v;\n\n        for(int i = 0; i &lt; n; i++) {\n            if(nums[i] == key) {\n                int start = max(0, i - k);\n                int end = min(n - 1, i + k);\n\n                if(v.size() != 0)\n                    start = max(v[v.size() - 1] + 1, start);\n\n                for(int j = start; j &lt;= end; j++) {\n                    v.push_back(j);\n                }\n            }\n        }\n        return v;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; findKDistantIndices(vector&lt;int&gt;&amp; nums, int key, int k) {\n        set&lt;int&gt; st;\n\n        for(int i = 0; i &lt; nums.size(); i++){\n            if(nums[i] == key){\n                for(int j = i - k; j &lt;= i + k; j++){\n                    if(j &gt;=0 &amp;&amp; j &lt; nums.size())\n                        st.insert(j);\n                }\n            }\n        }\n\n        return vector&lt;int&gt;(st.begin(), st.end());\n    }\n};\n\n",
        "url": "/2022/04/16/2200-Find-All-K-Distant-Indices-in-an-Array/"
      },
    
      {
        "title": "Divide Array Into Equal Pairs",
        "excerpt": "&lt;-E 2206&gt; Divide Array Into Equal Pairs\n\nclass Solution {\npublic:\n    bool divideArray(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int, int&gt; check;\n        for(auto i : nums) {\n            check[i]++;\n        }\n        for(auto i : check) {\n            if(i.second % 2)\n                return false;\n        }\n        return true;\n    }\n};\n\n\n",
        "content": "&lt;-E 2206&gt; Divide Array Into Equal Pairs\n\nclass Solution {\npublic:\n    bool divideArray(vector&lt;int&gt;&amp; nums) {\n        unordered_map&lt;int, int&gt; check;\n        for(auto i : nums) {\n            check[i]++;\n        }\n        for(auto i : check) {\n            if(i.second % 2)\n                return false;\n        }\n        return true;\n    }\n};\n\n\n",
        "url": "/2022/04/16/2206-Divide-Array-Into-Equal-Pairs/"
      },
    
      {
        "title": "Count Hills and Valleys in an Array",
        "excerpt": "&lt;-E 2210&gt; Count Hills and Valleys in an Array\n\nclass Solution {\npublic:\n    int countHillValley(vector&lt;int&gt;&amp; nums) {\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n        int ret = 0;\n        for (int i = 1; i &lt; nums.size() - 1; i++) {\n            if ((nums[i] &gt; nums[i - 1]) == (nums[i] &gt; nums[i + 1])) {\n                ++ret;\n            }\n        }\n        return ret;\n    }\n};\n\n",
        "content": "&lt;-E 2210&gt; Count Hills and Valleys in an Array\n\nclass Solution {\npublic:\n    int countHillValley(vector&lt;int&gt;&amp; nums) {\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\n\n        int ret = 0;\n        for (int i = 1; i &lt; nums.size() - 1; i++) {\n            if ((nums[i] &gt; nums[i - 1]) == (nums[i] &gt; nums[i + 1])) {\n                ++ret;\n            }\n        }\n        return ret;\n    }\n};\n\n",
        "url": "/2022/04/16/2210-Count-Hills-and-Valleys-in-an-Array/"
      },
    
      {
        "title": "Find the Difference of Two Arrays",
        "excerpt": "&lt;-E 2215&gt; Find the Difference of Two Arrays\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findDifference(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        vector&lt;vector&lt;int&gt;&gt; ans(2);\n        set&lt;int&gt; s1(nums1.begin(), nums1.end());\n        set&lt;int&gt; s2(nums2.begin(), nums2.end());\n\n\t\tfor(auto i : s2)\n            if(!s1.count(i))\n                ans[1].push_back(i);\n\n        for(auto i : s1)\n            if(!s2.count(i))\n                ans[0].push_back(i);\n\n        return ans;\n\n    }\n};\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findDifference(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        set&lt;int&gt; ans1, ans2;\n\n        bool a[2001] = {false}, b[2001] = {false};\n        for(int i : nums1){\n            a[i+1000] = true;\n        }\n\n        for(int j : nums2){\n            b[j+1000] = true;\n            if(a[j+1000] == false)\n                ans2.insert(j);\n        }\n\n        for(int i : nums1){\n            if(b[i+1000] == false)\n                ans1.insert(i);\n        }\n\n        vector&lt;int&gt; r1, r2;\n        for(auto i : ans1)\n            r1.push_back(i);\n\n        for(auto i : ans2)\n            r2.push_back(i);\n\n        vector&lt;vector&lt;int&gt;&gt; vec;\n        vec.push_back(r1);\n        vec.push_back(r2);\n\n        return vec;\n    }\n};\n\n",
        "content": "&lt;-E 2215&gt; Find the Difference of Two Arrays\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findDifference(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        vector&lt;vector&lt;int&gt;&gt; ans(2);\n        set&lt;int&gt; s1(nums1.begin(), nums1.end());\n        set&lt;int&gt; s2(nums2.begin(), nums2.end());\n\n\t\tfor(auto i : s2)\n            if(!s1.count(i))\n                ans[1].push_back(i);\n\n        for(auto i : s1)\n            if(!s2.count(i))\n                ans[0].push_back(i);\n\n        return ans;\n\n    }\n};\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; findDifference(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        set&lt;int&gt; ans1, ans2;\n\n        bool a[2001] = {false}, b[2001] = {false};\n        for(int i : nums1){\n            a[i+1000] = true;\n        }\n\n        for(int j : nums2){\n            b[j+1000] = true;\n            if(a[j+1000] == false)\n                ans2.insert(j);\n        }\n\n        for(int i : nums1){\n            if(b[i+1000] == false)\n                ans1.insert(i);\n        }\n\n        vector&lt;int&gt; r1, r2;\n        for(auto i : ans1)\n            r1.push_back(i);\n\n        for(auto i : ans2)\n            r2.push_back(i);\n\n        vector&lt;vector&lt;int&gt;&gt; vec;\n        vec.push_back(r1);\n        vec.push_back(r2);\n\n        return vec;\n    }\n};\n\n",
        "url": "/2022/04/16/2215-Find-the-Difference-of-Two-Arrays/"
      },
    
      {
        "title": "Minimum Bit Flips to Convert Number",
        "excerpt": "&lt;-E 2220&gt; Minimum Bit Flips to Convert Number\n\nclass Solution {\npublic:\n    int minBitFlips(int start, int goal) {\n        int value = start ^ goal;\n        int count = 0;\n        while (value) {\n          value = value &amp; value - 1;\n          count++;\n        }\n        return count;\n    }\n};\n\n",
        "content": "&lt;-E 2220&gt; Minimum Bit Flips to Convert Number\n\nclass Solution {\npublic:\n    int minBitFlips(int start, int goal) {\n        int value = start ^ goal;\n        int count = 0;\n        while (value) {\n          value = value &amp; value - 1;\n          count++;\n        }\n        return count;\n    }\n};\n\n",
        "url": "/2022/04/16/2220.-Minimum-Bit-Flips-to-Convert-Number/"
      },
    
      {
        "title": "Minimum Number of Operations to Convert Time",
        "excerpt": "&lt;-E 2224&gt; Minimum Number of Operations to Convert Time\n\nclass Solution {\n    private:\n    constexpr static int MINUTES_IN_DAY = 24 * 60;\n\n    int getMinutes(const string&amp; t) {\n        int hour = stoi(t.substr(0, 2));\n        int minute = stoi(t.substr(3));\n        return hour * 60 + minute;\n    }\npublic:\n    int convertTime(string current, string correct) {\n        int from = getMinutes(current);\n        int to = getMinutes(correct);\n        int diff = (to - from + MINUTES_IN_DAY) % MINUTES_IN_DAY;\n        vector&lt;int&gt; moves {60, 15, 5, 1};\n        int ret = 0;\n        for (auto move: moves) {\n            ret += diff / move;\n            diff %= move;\n        }\n        return ret;\n    }\n};\n\n",
        "content": "&lt;-E 2224&gt; Minimum Number of Operations to Convert Time\n\nclass Solution {\n    private:\n    constexpr static int MINUTES_IN_DAY = 24 * 60;\n\n    int getMinutes(const string&amp; t) {\n        int hour = stoi(t.substr(0, 2));\n        int minute = stoi(t.substr(3));\n        return hour * 60 + minute;\n    }\npublic:\n    int convertTime(string current, string correct) {\n        int from = getMinutes(current);\n        int to = getMinutes(correct);\n        int diff = (to - from + MINUTES_IN_DAY) % MINUTES_IN_DAY;\n        vector&lt;int&gt; moves {60, 15, 5, 1};\n        int ret = 0;\n        for (auto move: moves) {\n            ret += diff / move;\n            diff %= move;\n        }\n        return ret;\n    }\n};\n\n",
        "url": "/2022/04/16/2224.-Minimum-Number-of-Operations-to-Convert-Time/"
      },
    
      {
        "title": "Largest Number After Digit Swaps by Parity",
        "excerpt": "&lt;-E 2231&gt; Largest Number After Digit Swaps by Parity\n\nclass Solution {\npublic:\n    int largestInteger(int num) {\n        priority_queue&lt;int&gt; p;\n        priority_queue&lt;int&gt; q;\n        string nums = to_string(num);\n        int n = nums.size();\n\n        for(int i = 0; i &lt; n; i++){\n            int digit=nums[i] - '0';\n            if(digit % 2)\n                p.push(digit);\n            else\n                q.push(digit);\n        }\n\n        int answer = 0;\n        for(int i = 0; i &lt; n; i++) {\n            answer = answer * 10;\n            if((nums[i] - '0') % 2) {\n                answer += p.top();\n                p.pop();\n            }\n            else {\n                answer += q.top();\n                q.pop();\n            }\n        }\n        return answer;\n    }\n};\n\n",
        "content": "&lt;-E 2231&gt; Largest Number After Digit Swaps by Parity\n\nclass Solution {\npublic:\n    int largestInteger(int num) {\n        priority_queue&lt;int&gt; p;\n        priority_queue&lt;int&gt; q;\n        string nums = to_string(num);\n        int n = nums.size();\n\n        for(int i = 0; i &lt; n; i++){\n            int digit=nums[i] - '0';\n            if(digit % 2)\n                p.push(digit);\n            else\n                q.push(digit);\n        }\n\n        int answer = 0;\n        for(int i = 0; i &lt; n; i++) {\n            answer = answer * 10;\n            if((nums[i] - '0') % 2) {\n                answer += p.top();\n                p.pop();\n            }\n            else {\n                answer += q.top();\n                q.pop();\n            }\n        }\n        return answer;\n    }\n};\n\n",
        "url": "/2022/04/16/2231-Largest-Number-After-Digit-Swaps-by-Parity/"
      },
    
      {
        "title": "Add Two Integers",
        "excerpt": "&lt;-E 2235&gt; Add Two Integers\n\nclass Solution {\npublic:\n    int sum(int num1, int num2) {\n        return num1 + num2;\n    }\n};\n\n",
        "content": "&lt;-E 2235&gt; Add Two Integers\n\nclass Solution {\npublic:\n    int sum(int num1, int num2) {\n        return num1 + num2;\n    }\n};\n\n",
        "url": "/2022/04/16/2235-Add-Two-Integers/"
      },
    
      {
        "title": "Root Equals Sum of Children",
        "excerpt": "&lt;-E 2236&gt; Root Equals Sum of Children\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool checkTree(TreeNode* root) {\n        return (root-&gt;val == (root-&gt;left-&gt;val) + root-&gt;right-&gt;val);\n    }\n};\n\n",
        "content": "&lt;-E 2236&gt; Root Equals Sum of Children\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool checkTree(TreeNode* root) {\n        return (root-&gt;val == (root-&gt;left-&gt;val) + root-&gt;right-&gt;val);\n    }\n};\n\n",
        "url": "/2022/04/16/2236-Root-Equals-Sum-of-Children/"
      },
    
      {
        "title": "Find Closest Number to Zero",
        "excerpt": "&lt;-E 2239&gt; Find Closest Number to Zero\n\n// Method 1\nclass Solution {\npublic:\n    int findClosestNumber(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        if(nums[0] &gt; 0)\n            return nums[0];\n        if (nums[nums.size() - 1] &lt; 0)\n            return nums[nums.size() - 1];\n        bool check = false;\n        for(int i  = 0; i != nums.size(); i++) {\n            if(nums[i] == 0)\n                return 0;\n            if(nums[i] &lt; 0) {\n                check = true;\n            }\n            if(nums[i] &gt; 0 &amp;&amp; check == true) {\n                if(nums[i] + nums[i - 1] &gt; 0)\n                    return nums[i - 1];\n                else\n                    return nums[i];\n            }\n        }\n        return 0;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int findClosestNumber(vector&lt;int&gt;&amp; nums) {\n        int res = abs(nums[0]);\n        int resIdx = 0;\n        for(int i = 1; i &lt; nums.size(); i++){\n            if(abs(nums[i]) &lt; res) {\n                res = abs(nums[i]);\n                resIdx = i;\n            } else if(abs(nums[i]) == res){\n                if(nums[i]&gt;nums[resIdx]) resIdx = i;\n            }\n        }\n        return nums[resIdx];\n    }\n};\n\n",
        "content": "&lt;-E 2239&gt; Find Closest Number to Zero\n\n// Method 1\nclass Solution {\npublic:\n    int findClosestNumber(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        if(nums[0] &gt; 0)\n            return nums[0];\n        if (nums[nums.size() - 1] &lt; 0)\n            return nums[nums.size() - 1];\n        bool check = false;\n        for(int i  = 0; i != nums.size(); i++) {\n            if(nums[i] == 0)\n                return 0;\n            if(nums[i] &lt; 0) {\n                check = true;\n            }\n            if(nums[i] &gt; 0 &amp;&amp; check == true) {\n                if(nums[i] + nums[i - 1] &gt; 0)\n                    return nums[i - 1];\n                else\n                    return nums[i];\n            }\n        }\n        return 0;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int findClosestNumber(vector&lt;int&gt;&amp; nums) {\n        int res = abs(nums[0]);\n        int resIdx = 0;\n        for(int i = 1; i &lt; nums.size(); i++){\n            if(abs(nums[i]) &lt; res) {\n                res = abs(nums[i]);\n                resIdx = i;\n            } else if(abs(nums[i]) == res){\n                if(nums[i]&gt;nums[resIdx]) resIdx = i;\n            }\n        }\n        return nums[resIdx];\n    }\n};\n\n",
        "url": "/2022/04/16/2239-Find-Closest-Number-to-Zero/"
      },
    
      {
        "title": "Calculate Digit Sum of a String",
        "excerpt": "&lt;-E 2243&gt; Calculate Digit Sum of a String\n\nclass Solution {\npublic:\n    string digitSum(string s, int k) {\n        while(s.length() &gt; k) {\n            int i = 0 ;\n            string tmp = \"\";\n            while (i &lt; s.length()) {\n                int sum = 0;\n                int cnt = 0;\n                while (i &lt; s.length() &amp;&amp; cnt &lt; k) {\n                    sum += s[i] - '0';\n                    i++;\n                    cnt++;\n                }\n                tmp += to_string(sum);\n            }\n            s = tmp;\n        }\n        return s;\n    }\n};\n\n",
        "content": "&lt;-E 2243&gt; Calculate Digit Sum of a String\n\nclass Solution {\npublic:\n    string digitSum(string s, int k) {\n        while(s.length() &gt; k) {\n            int i = 0 ;\n            string tmp = \"\";\n            while (i &lt; s.length()) {\n                int sum = 0;\n                int cnt = 0;\n                while (i &lt; s.length() &amp;&amp; cnt &lt; k) {\n                    sum += s[i] - '0';\n                    i++;\n                    cnt++;\n                }\n                tmp += to_string(sum);\n            }\n            s = tmp;\n        }\n        return s;\n    }\n};\n\n",
        "url": "/2022/04/16/2243-Calculate-Digit-Sum-of-a-String/"
      },
    
      {
        "title": "Intersection of Multiple Arrays",
        "excerpt": "&lt;-E 2248&gt; Intersection of Multiple Arrays\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {\n        int check[1001] = {0};\n        for(auto num : nums) {\n            for(auto i : num) {\n                check[i]++;\n            }\n        }\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != 1001; i++) {\n            if(check[i] == nums.size())\n                ans.push_back(i);\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {\n        vector&lt;int&gt; res;\n        int n = nums.size();\n        map&lt;int, int&gt; mp;\n        for (auto&amp; l : nums) {\n            for (auto&amp; i : l)\n                mp[i]++;\n        }\n        for (auto&amp; iter:mp) {\n            if (iter.second == n)\n                res.push_back(iter.first);\n        }\n        return res;\n    }\n};\n\n",
        "content": "&lt;-E 2248&gt; Intersection of Multiple Arrays\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {\n        int check[1001] = {0};\n        for(auto num : nums) {\n            for(auto i : num) {\n                check[i]++;\n            }\n        }\n        vector&lt;int&gt; ans;\n        for(int i = 0; i != 1001; i++) {\n            if(check[i] == nums.size())\n                ans.push_back(i);\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {\n        vector&lt;int&gt; res;\n        int n = nums.size();\n        map&lt;int, int&gt; mp;\n        for (auto&amp; l : nums) {\n            for (auto&amp; i : l)\n                mp[i]++;\n        }\n        for (auto&amp; iter:mp) {\n            if (iter.second == n)\n                res.push_back(iter.first);\n        }\n        return res;\n    }\n};\n\n",
        "url": "/2022/04/16/2248-Intersection-of-Multiple-Arrays/"
      },
    
      {
        "title": "Count Prefixes of a Given String",
        "excerpt": "&lt;-E 2255&gt; Count Prefixes of a Given String\n\n// Method 1\nclass Solution {\npublic:\n    int countPrefixes(vector&lt;string&gt;&amp; words, string s) {\n        int ans = 0;\n        for(auto word : words) {\n            int i = 0;\n            bool check = true;\n            for(auto c : word) {\n                if(check == true) {\n                    if(s[i++] != c)\n                        check = false;\n                }\n            }\n            if(check == true) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n\n\n// Method 2\nclass Solution {\npublic:\n    int countPrefixes(vector&lt;string&gt;&amp; words, string s)\n    {\n        int count=0;\n        for(int i=0;i&lt;words.size();i++)\n        {\n            size_t found=s.find(words[i]);\n            if(found==0)\n                count++;\n        }\n        return count;\n    }\n};\n\n",
        "content": "&lt;-E 2255&gt; Count Prefixes of a Given String\n\n// Method 1\nclass Solution {\npublic:\n    int countPrefixes(vector&lt;string&gt;&amp; words, string s) {\n        int ans = 0;\n        for(auto word : words) {\n            int i = 0;\n            bool check = true;\n            for(auto c : word) {\n                if(check == true) {\n                    if(s[i++] != c)\n                        check = false;\n                }\n            }\n            if(check == true) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n\n\n// Method 2\nclass Solution {\npublic:\n    int countPrefixes(vector&lt;string&gt;&amp; words, string s)\n    {\n        int count=0;\n        for(int i=0;i&lt;words.size();i++)\n        {\n            size_t found=s.find(words[i]);\n            if(found==0)\n                count++;\n        }\n        return count;\n    }\n};\n\n",
        "url": "/2022/04/16/2255-Count-Prefixes-of-a-Given-String/"
      },
    
      {
        "title": "Remove Digit From Number to Maximize Result",
        "excerpt": "&lt;-E 2259&gt; Remove Digit From Number to Maximize Result\n\n// Method 1\nclass Solution {\npublic:\n    string removeDigit(string number, char digit) {\n         vector&lt;string&gt; v;\n            for(int i = 0; i &lt; number.size(); i++) {\n                string s = number;\n                if(number[i] == digit) {\n                    s.erase(i,1);\n                    v.push_back(s);\n                }\n            }\n        return *max_element(v.begin(), v.end());\n    }\n};\n\nclass Solution {\npublic:\n    string removeDigit(string number, char digit) {\n        string str = \"0\";\n        for(int i = 0;i&lt;=number.size();i++) {\n            if(number[i] == digit){\n                string temp = number.substr(0,i) + number.substr(i+1);\n                if(str &lt; temp) {\n                    str = temp;\n                }\n            }\n        }\n        return str;\n    }\n};\n\n",
        "content": "&lt;-E 2259&gt; Remove Digit From Number to Maximize Result\n\n// Method 1\nclass Solution {\npublic:\n    string removeDigit(string number, char digit) {\n         vector&lt;string&gt; v;\n            for(int i = 0; i &lt; number.size(); i++) {\n                string s = number;\n                if(number[i] == digit) {\n                    s.erase(i,1);\n                    v.push_back(s);\n                }\n            }\n        return *max_element(v.begin(), v.end());\n    }\n};\n\nclass Solution {\npublic:\n    string removeDigit(string number, char digit) {\n        string str = \"0\";\n        for(int i = 0;i&lt;=number.size();i++) {\n            if(number[i] == digit){\n                string temp = number.substr(0,i) + number.substr(i+1);\n                if(str &lt; temp) {\n                    str = temp;\n                }\n            }\n        }\n        return str;\n    }\n};\n\n",
        "url": "/2022/04/16/2259-Remove-Digit-From-Number-to-Maximize-Result/"
      },
    
      {
        "title": "Largest 3-Same-Digit Number in String",
        "excerpt": "&lt;-E 2264&gt; Largest 3-Same-Digit Number in String\n\nclass Solution {\npublic:\n    string largestGoodInteger(string num) {\n        string ans;\n        for(int i=0;i&lt;num.size()-2;i++)\n            if(num[i] == num[i+1] &amp;&amp; num[i+1] == num[i+2])\n                ans = max(ans, num.substr(i,3));\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2264&gt; Largest 3-Same-Digit Number in String\n\nclass Solution {\npublic:\n    string largestGoodInteger(string num) {\n        string ans;\n        for(int i=0;i&lt;num.size()-2;i++)\n            if(num[i] == num[i+1] &amp;&amp; num[i+1] == num[i+2])\n                ans = max(ans, num.substr(i,3));\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2264-Largest-3-Same-Digit-Number-in-String/"
      },
    
      {
        "title": "Find the K-Beauty of a Number",
        "excerpt": "&lt;-E 2269&gt; Find the K-Beauty of a Number\n\nclass Solution {\npublic:\n    int divisorSubstrings(int num, int k) {\n        string strAns = to_string(num);\n        int n = strAns.size(),ans=0;\n        for (int i = 0; i &lt; (n-k+1); i++){\n            if(stoi(strAns.substr(i, k)) != 0)\n                if(!(num % stoi(strAns.substr(i, k))))\n                    ans++;\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2269&gt; Find the K-Beauty of a Number\n\nclass Solution {\npublic:\n    int divisorSubstrings(int num, int k) {\n        string strAns = to_string(num);\n        int n = strAns.size(),ans=0;\n        for (int i = 0; i &lt; (n-k+1); i++){\n            if(stoi(strAns.substr(i, k)) != 0)\n                if(!(num % stoi(strAns.substr(i, k))))\n                    ans++;\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2269.-Find-the-K-Beauty-of-a-Number/"
      },
    
      {
        "title": "Find Resultant Array After Removing Anagrams",
        "excerpt": "&lt;-E 2273&gt; Find Resultant Array After Removing Anagrams\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; removeAnagrams(vector&lt;string&gt;&amp; words) {\n        set&lt;string&gt; ans_temp;\n        vector&lt;string&gt; ans;\n        for(auto word : words) {\n            int n = ans_temp.size();\n            string temp = word;\n            sort(temp.begin(), temp.end());\n            ans_temp.insert(temp);\n            if(ans_temp.size() &gt; 1) {\n                ans_temp.clear();\n                ans_temp.insert(temp);\n                ans.push_back(word);\n            }\n\n            if(ans_temp.size() != n) {\n                ans.push_back(word);\n\n            }\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;string&gt; removeAnagrams(vector&lt;string&gt;&amp; words) {\n        vector&lt;string&gt;ans;\n        for(int i = 0; i&lt;words.size();) {\n            int  j = i + 1;\n            while(j &lt; words.size() &amp;&amp; isAnagram(words[i], words[j]))\n                j++;\n            ans.push_back(words[i]);\n            i = j;\n        }\n        return ans;\n    }\n\n    bool isAnagram(string w,string x){\n        vector&lt;int&gt;a(26);\n        for(auto i : w)\n            a[i - 'a']++;\n\n        for(auto i : x)\n            a[i - 'a']--;\n\n        for(auto i:a)\n            if(i != 0)\n                return false;\n\n        return true;\n    }\n};\n\n",
        "content": "&lt;-E 2273&gt; Find Resultant Array After Removing Anagrams\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; removeAnagrams(vector&lt;string&gt;&amp; words) {\n        set&lt;string&gt; ans_temp;\n        vector&lt;string&gt; ans;\n        for(auto word : words) {\n            int n = ans_temp.size();\n            string temp = word;\n            sort(temp.begin(), temp.end());\n            ans_temp.insert(temp);\n            if(ans_temp.size() &gt; 1) {\n                ans_temp.clear();\n                ans_temp.insert(temp);\n                ans.push_back(word);\n            }\n\n            if(ans_temp.size() != n) {\n                ans.push_back(word);\n\n            }\n        }\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;string&gt; removeAnagrams(vector&lt;string&gt;&amp; words) {\n        vector&lt;string&gt;ans;\n        for(int i = 0; i&lt;words.size();) {\n            int  j = i + 1;\n            while(j &lt; words.size() &amp;&amp; isAnagram(words[i], words[j]))\n                j++;\n            ans.push_back(words[i]);\n            i = j;\n        }\n        return ans;\n    }\n\n    bool isAnagram(string w,string x){\n        vector&lt;int&gt;a(26);\n        for(auto i : w)\n            a[i - 'a']++;\n\n        for(auto i : x)\n            a[i - 'a']--;\n\n        for(auto i:a)\n            if(i != 0)\n                return false;\n\n        return true;\n    }\n};\n\n",
        "url": "/2022/04/16/2273-Find-Resultant-Array-After-Removing-Anagrams/"
      },
    
      {
        "title": "Percentage of Letter in String",
        "excerpt": "&lt;-E 2278&gt; Percentage of Letter in String\n\nclass Solution {\npublic:\n    int percentageLetter(string s, char letter) {\n        int n = s.size();\n\t\tint c = 0;\n\t\tfor(auto i : s){\n\t\t\tif(i == letter)\n\t\t\t\tc++;\n\t\t}\n\t\treturn c * 100 / n;\n    }\n};\n\n",
        "content": "&lt;-E 2278&gt; Percentage of Letter in String\n\nclass Solution {\npublic:\n    int percentageLetter(string s, char letter) {\n        int n = s.size();\n\t\tint c = 0;\n\t\tfor(auto i : s){\n\t\t\tif(i == letter)\n\t\t\t\tc++;\n\t\t}\n\t\treturn c * 100 / n;\n    }\n};\n\n",
        "url": "/2022/04/16/2278-Percentage-of-Letter-in-String/"
      },
    
      {
        "title": "Check if Number Has Equal Digit Count and Digit Value",
        "excerpt": "&lt;-E 2283&gt; Check if Number Has Equal Digit Count and Digit Value\n\nclass Solution {\npublic:\n    bool digitCount(string num) {\n        int check[10] = {0};\n        for(auto i : num) {\n            check[i - '0']++;\n        }\n\n        for(int i = 0; i != num.size(); i++) {\n            if(check[i] != (num[i] - '0'))\n                return false;\n        }\n        return true;\n    }\n};\n\n",
        "content": "&lt;-E 2283&gt; Check if Number Has Equal Digit Count and Digit Value\n\nclass Solution {\npublic:\n    bool digitCount(string num) {\n        int check[10] = {0};\n        for(auto i : num) {\n            check[i - '0']++;\n        }\n\n        for(int i = 0; i != num.size(); i++) {\n            if(check[i] != (num[i] - '0'))\n                return false;\n        }\n        return true;\n    }\n};\n\n",
        "url": "/2022/04/16/2283-Check-if-Number-Has-Equal-Digit-Count-and-Digit-Value/"
      },
    
      {
        "title": "Rearrange Characters to Make Target String",
        "excerpt": "&lt;-E 2287&gt; Rearrange Characters to Make Target String\n\n// Method 1\nclass Solution {\npublic:\n    int rearrangeCharacters(string s, string target) {\n        int check_1[26] = {0};\n        int check_2[26] = {0};\n        for(auto c : s) {\n            check_1[c - 'a']++;\n        }\n         for(auto c : target) {\n            check_2[c - 'a']++;\n        }\n        int ans = 100000;\n\n        for(int i = 0; i != 26; i++) {\n            if(check_2[i] != 0) {\n                ans = min(ans, check_1[i] / check_2[i]);\n            }\n        }\n\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int rearrangeCharacters(string s, string target) {\n        vector&lt;int&gt; vs(26,0);vector&lt;int&gt; vt(26,0);\n        for(int i=0;i&lt;target.size();i++){\n            vt[target[i]-'a']++;\n        }\n        for(int i=0;i&lt;s.size();i++){\n            vs[s[i]-'a']++;\n        }\n        int min_multiple = INT_MAX;\n        for(int i=0;i&lt;26;i++){\n            if(vt[i] !=0){\n                min_multiple = min(min_multiple,vs[i]/vt[i]);\n            }\n        }\n        return min_multiple;\n    }\n};\n\n",
        "content": "&lt;-E 2287&gt; Rearrange Characters to Make Target String\n\n// Method 1\nclass Solution {\npublic:\n    int rearrangeCharacters(string s, string target) {\n        int check_1[26] = {0};\n        int check_2[26] = {0};\n        for(auto c : s) {\n            check_1[c - 'a']++;\n        }\n         for(auto c : target) {\n            check_2[c - 'a']++;\n        }\n        int ans = 100000;\n\n        for(int i = 0; i != 26; i++) {\n            if(check_2[i] != 0) {\n                ans = min(ans, check_1[i] / check_2[i]);\n            }\n        }\n\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int rearrangeCharacters(string s, string target) {\n        vector&lt;int&gt; vs(26,0);vector&lt;int&gt; vt(26,0);\n        for(int i=0;i&lt;target.size();i++){\n            vt[target[i]-'a']++;\n        }\n        for(int i=0;i&lt;s.size();i++){\n            vs[s[i]-'a']++;\n        }\n        int min_multiple = INT_MAX;\n        for(int i=0;i&lt;26;i++){\n            if(vt[i] !=0){\n                min_multiple = min(min_multiple,vs[i]/vt[i]);\n            }\n        }\n        return min_multiple;\n    }\n};\n\n",
        "url": "/2022/04/16/2287-Rearrange-Characters-to-Make-Target-String/"
      },
    
      {
        "title": "Min Max Game",
        "excerpt": "&lt;-E 2293&gt; Min Max Game\n\n// Method 1\nclass Solution {\npublic:\n    int minMaxGame(vector&lt;int&gt;&amp; nums) {\n        while(nums.size() &gt; 1){\n            vector&lt;int&gt; temp;\n            bool m = false;\n            for(int i = 1; i &lt; nums.size(); i += 2) {\n                int n;\n                m ? n = max(nums[i], nums[i - 1]) : n = min(nums[i], nums[i - 1]);\n                temp.push_back(n);\n                m = !m;\n            }\n            nums = temp;\n        }\n        return nums[0];\n    }\n};\n\n\n// Method 2\nclass Solution {\npublic:\n    int minMaxGame(vector&lt;int&gt;&amp;v) {\n        int n = v.size();\n        while(n &gt; 1) {\n            for(int i = 0; i &lt; n / 2; i++) {\n                if(i % 2) {\n                    int a = max(v[2 * i], v[2 * i + 1]);\n                    v[i] = a;\n                }\n                else {\n                     int a = min(v[2 * i], v[2 * i + 1]);\n                     v[i] = a;\n                }\n            }\n            n = n / 2;\n        }\n        return v[0];\n    }\n};\n\n",
        "content": "&lt;-E 2293&gt; Min Max Game\n\n// Method 1\nclass Solution {\npublic:\n    int minMaxGame(vector&lt;int&gt;&amp; nums) {\n        while(nums.size() &gt; 1){\n            vector&lt;int&gt; temp;\n            bool m = false;\n            for(int i = 1; i &lt; nums.size(); i += 2) {\n                int n;\n                m ? n = max(nums[i], nums[i - 1]) : n = min(nums[i], nums[i - 1]);\n                temp.push_back(n);\n                m = !m;\n            }\n            nums = temp;\n        }\n        return nums[0];\n    }\n};\n\n\n// Method 2\nclass Solution {\npublic:\n    int minMaxGame(vector&lt;int&gt;&amp;v) {\n        int n = v.size();\n        while(n &gt; 1) {\n            for(int i = 0; i &lt; n / 2; i++) {\n                if(i % 2) {\n                    int a = max(v[2 * i], v[2 * i + 1]);\n                    v[i] = a;\n                }\n                else {\n                     int a = min(v[2 * i], v[2 * i + 1]);\n                     v[i] = a;\n                }\n            }\n            n = n / 2;\n        }\n        return v[0];\n    }\n};\n\n",
        "url": "/2022/04/16/2293-Min-Max-Game/"
      },
    
      {
        "title": "Strong Password Checker II",
        "excerpt": "&lt;-E 2299&gt; Strong Password Checker II\n\nclass Solution {\npublic:\n    bool strongPasswordCheckerII(string password) {\n        int  lowercase=0;\n        int uppercase =0;\n        int digit=0;\n        int character=0;\n\n        if(password.size()&lt;8)\n            return false;\n\n        for(int i = 0; i &lt; password.size(); i++) {\n            if(i &gt; 0) {\n                if(password[i-1]==password[i])\n                    return false;\n            }\n\n            if(isupper(password[i]))\n                uppercase++;\n            else if(islower(password[i]))\n                lowercase++;\n            else if(isdigit(password[i]))\n                digit++;\n            else\n                character++;\n        }\n\n        if(lowercase &gt;= 1 &amp;&amp; uppercase &gt;=1 &amp;&amp; digit &gt;=1 &amp;&amp; character &gt;=1)\n            return true;\n\n        return false;\n    }\n};\n\n",
        "content": "&lt;-E 2299&gt; Strong Password Checker II\n\nclass Solution {\npublic:\n    bool strongPasswordCheckerII(string password) {\n        int  lowercase=0;\n        int uppercase =0;\n        int digit=0;\n        int character=0;\n\n        if(password.size()&lt;8)\n            return false;\n\n        for(int i = 0; i &lt; password.size(); i++) {\n            if(i &gt; 0) {\n                if(password[i-1]==password[i])\n                    return false;\n            }\n\n            if(isupper(password[i]))\n                uppercase++;\n            else if(islower(password[i]))\n                lowercase++;\n            else if(isdigit(password[i]))\n                digit++;\n            else\n                character++;\n        }\n\n        if(lowercase &gt;= 1 &amp;&amp; uppercase &gt;=1 &amp;&amp; digit &gt;=1 &amp;&amp; character &gt;=1)\n            return true;\n\n        return false;\n    }\n};\n\n",
        "url": "/2022/04/16/2299-Strong-Password-Checker-II/"
      },
    
      {
        "title": "Calculate Amount Paid in Taxes",
        "excerpt": "&lt;-E 2303&gt; Calculate Amount Paid in Taxes\n\nclass Solution {\npublic:\n    double calculateTax(vector&lt;vector&lt;int&gt;&gt;&amp; brackets, int income) {\n        double ans = 0;\n        int j = 0;\n        for (auto v : brackets) {\n            int upper = v[0], prcnt = v[1];\n            int curr = min(income, upper - j);\n            ans +=  prcnt * 0.01 * curr;\n            income -= curr;\n            j = upper;\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2303&gt; Calculate Amount Paid in Taxes\n\nclass Solution {\npublic:\n    double calculateTax(vector&lt;vector&lt;int&gt;&gt;&amp; brackets, int income) {\n        double ans = 0;\n        int j = 0;\n        for (auto v : brackets) {\n            int upper = v[0], prcnt = v[1];\n            int curr = min(income, upper - j);\n            ans +=  prcnt * 0.01 * curr;\n            income -= curr;\n            j = upper;\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2303-Calculate-Amount-Paid-in-Taxes/"
      },
    
      {
        "title": "Greatest English Letter in Upper and Lower Case",
        "excerpt": "&lt;-E 2309&gt; Greatest English Letter in Upper and Lower Case\n\nclass Solution {\npublic:\n    string greatestLetter(string s) {\n        int check_u[26] = {0};\n        int check_l[26] = {0};\n\n        for(auto c : s) {\n            if(isupper(c)) {\n                check_u[c - 'A']++;\n            }\n            else {\n                check_l[c - 'a']++;\n            }\n        }\n        string ans = \"\";\n        for(int i = 25; i &gt;= 0; i--) {\n            if (check_u[i] &amp;&amp; check_l[i]) {\n                ans.push_back('A' + i);\n                return ans;\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2309&gt; Greatest English Letter in Upper and Lower Case\n\nclass Solution {\npublic:\n    string greatestLetter(string s) {\n        int check_u[26] = {0};\n        int check_l[26] = {0};\n\n        for(auto c : s) {\n            if(isupper(c)) {\n                check_u[c - 'A']++;\n            }\n            else {\n                check_l[c - 'a']++;\n            }\n        }\n        string ans = \"\";\n        for(int i = 25; i &gt;= 0; i--) {\n            if (check_u[i] &amp;&amp; check_l[i]) {\n                ans.push_back('A' + i);\n                return ans;\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2309-Greatest-English-Letter-in-Upper-and-Lower-Case/"
      },
    
      {
        "title": "Count Asterisks",
        "excerpt": "&lt;-E 2315&gt; Count Asterisks\n\n// Method 1\nclass Solution {\npublic:\n    int countAsterisks(string s) {\n        if(s.size() == 0)\n            return 0;\n        int cnt = 0;\n        int bar = 0;\n        for(int i = 0; i != s.size(); i++) {\n            if(s[i]=='|')\n                 bar++;\n            if(bar % 2 == 0 &amp;&amp; s[i]=='*')\n                cnt++;\n        }\n        return cnt;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countAsterisks(string s) {\n        int ans = 0;\n\n        for(int i = 0; i &lt; s.size(); i++) {\n            if(s[i] == '|') {\n                while(s[++i] != '|');\n            } else if(s[i] == '*')\n                ans++;\n        }\n\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 2315&gt; Count Asterisks\n\n// Method 1\nclass Solution {\npublic:\n    int countAsterisks(string s) {\n        if(s.size() == 0)\n            return 0;\n        int cnt = 0;\n        int bar = 0;\n        for(int i = 0; i != s.size(); i++) {\n            if(s[i]=='|')\n                 bar++;\n            if(bar % 2 == 0 &amp;&amp; s[i]=='*')\n                cnt++;\n        }\n        return cnt;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int countAsterisks(string s) {\n        int ans = 0;\n\n        for(int i = 0; i &lt; s.size(); i++) {\n            if(s[i] == '|') {\n                while(s[++i] != '|');\n            } else if(s[i] == '*')\n                ans++;\n        }\n\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/16/2315-Count-Asterisks/"
      },
    
      {
        "title": "Check if Matrix Is X-Matrix",
        "excerpt": "&lt;-E 2319&gt; Check if Matrix Is X-Matrix\n\nclass Solution {\npublic:\n    bool checkXMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int n = grid.size();\n        for(int i = 0; i &lt; n; i++) {\n            for(int j = 0; j &lt; n; j++) {\n                if((i == j) || (i + j) == (n - 1)) {\n                    if(grid[i][j] == 0)\n                        return false;\n                }\n                else {\n                    if(grid[i][j]!=0)\n                        return false;\n                }\n            }\n        }\n        return true;;\n    }\n};\n\n",
        "content": "&lt;-E 2319&gt; Check if Matrix Is X-Matrix\n\nclass Solution {\npublic:\n    bool checkXMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int n = grid.size();\n        for(int i = 0; i &lt; n; i++) {\n            for(int j = 0; j &lt; n; j++) {\n                if((i == j) || (i + j) == (n - 1)) {\n                    if(grid[i][j] == 0)\n                        return false;\n                }\n                else {\n                    if(grid[i][j]!=0)\n                        return false;\n                }\n            }\n        }\n        return true;;\n    }\n};\n\n",
        "url": "/2022/04/16/2319-Check-if-Matrix-Is-X-Matrix/"
      },
    
      {
        "title": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
        "excerpt": "&lt;-E 1379&gt; Find a Corresponding Node of a Binary Tree in a Clone of That Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\n    TreeNode *ans;\npublic:\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\n        if(!cloned)\n            return NULL;\n\n        getTargetCopy(original, cloned -&gt; left, target);\n        getTargetCopy(original, cloned -&gt; right, target);\n\n        if(cloned -&gt; val == target -&gt; val) ans = cloned;\n\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-E 1379&gt; Find a Corresponding Node of a Binary Tree in a Clone of That Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\n    TreeNode *ans;\npublic:\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\n        if(!cloned)\n            return NULL;\n\n        getTargetCopy(original, cloned -&gt; left, target);\n        getTargetCopy(original, cloned -&gt; right, target);\n\n        if(cloned -&gt; val == target -&gt; val) ans = cloned;\n\n        return ans;\n    }\n};\n\n",
        "url": "/2022/04/17/1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree/"
      },
    
      {
        "title": "Largest Odd Number in String",
        "excerpt": "&lt;-E 1903&gt; Largest Odd Number in String\n\nclass Solution {\npublic:\n    string largestOddNumber(string num) {\n        int i = num.size();\n        for(;i &gt;= 0; i--)\n            if((num[i] - '0') % 2 != 0)\n                break;\n        return num.substr(0, i+1);\n    }\n};\n\n",
        "content": "&lt;-E 1903&gt; Largest Odd Number in String\n\nclass Solution {\npublic:\n    string largestOddNumber(string num) {\n        int i = num.size();\n        for(;i &gt;= 0; i--)\n            if((num[i] - '0') % 2 != 0)\n                break;\n        return num.substr(0, i+1);\n    }\n};\n\n",
        "url": "/2022/04/17/1903-Largest-Odd-Number-in-String/"
      },
    
      {
        "title": "HTML and CSS",
        "excerpt": "HTML and CSS\n\nThis a note of studying HTML and CSS\n\nWarming\n\n.example .pp = E F 是后代选择器。\n\n.example.pp2 则是在一个元素上，这个元素包括这两个类才会有效果。\n\ndo not repeat id in the same page\n\n\nThe basic of HTML\n\n\n  Elements surrounded in angle brackets\n  Usually have a start &amp; end tag\n  Some tags closse themselves(Remnant of XHTML)\n\n\nindex.html is your home page.\n\nMust use &lt;!DOCTYPE html&gt; and this means this page is using html 5.\n\n&lt;!-- the content showed on the search engine --&gt;\n&lt;meta name=\"\" content=\"\" /&gt;\n&lt;!-- Do not index page --&gt;\n&lt;meta name=\"robots\" content=\"NOINDEX, NOFOLLOW\" /&gt;\n\n\nw3school can provide:\n\n\n  blocks level this element contain whole line and give an cross line\n  inline element\n\n\nQuick input div#idname + tab = &lt;div id=\"idname\"&gt;&lt;/div&gt;\n\n#idname + tab = &lt;div id=\"idname\"&gt;&lt;/div&gt;  other need to be specificy\n\nHTML5 Semantic Tags:\n\n\n\nThe difference between an ID and a class is that an ID is only used to identify one single element in our HTML. IDs are only used when one element on the page should have a particular style applied to it. However, a class can be used to identify more than one HTML element.\n\nCSS selectors\n\n\n  Descendant Selector (space)\n  Child Selector (&gt;)\n  Adjacent Sibling Selector (+)\n  General Sibling Selector (~)\n\n\nSpace Symbol\n\nIt is called the Descendant selector. It will target all &lt;p&gt; tags within container div. All &lt;p&gt; elements that are children of #container at any depth.\n\n‘&gt;’ Symbol\n\nThis is called the child selector. CSS rules will be applied to elements which are direct children of the particular element.\n\nIt will target all the &lt;p&gt; tags which are immediate children of container &lt;div&gt;, but the children of children will not be selected\n\n‘+’ Symbol\n\nThis is Adjacent Sibling Selector. It selects all elements that are the adjacent siblings of a specified element.\n\nSibling elements must have the same parent element, and “adjacent” means “immediately following”.\n\n‘~’ Symbol\n\nIt is General Sibling Selector and similar to Adjacent Sibling Selector. It selects all next elements that are siblings of a specified element.\n\nThe following example selects all next &lt;p&gt; elements that are siblings of &lt;div&gt; elements.\n\nShortcut\n\ncommand + enter add a new ling whatever your mouse are\n\nshift + option + down copy the line\n\noption + arrows cross the words\n\nholding option + arrows move the line\n\nholidng option + D select the same words(you can change them all)\n\nmac: command + option + U show the source code of the website.\n\nCSS Units\n\nAbsolute\n\ncm Centimeter\nmm Millimeters\nin Inches\npx Pixels (1px = 1/96 of 1 in)\npt Ponint (1pt = 1/72 of 1 in)\npc Picas picas (1pc = 12 pt)\n\n\nRelative\n\n%   To parent element\nem  To font-size of parent element\nrem To font size of root element\nvw  To 1% of viewport width\nvh  To 1% of viewport height\n\n\nUseful links\n\nfind beauty color:\nhttps://www.color-hex.com/\n\nfont icon:\nhttps://fontawesome.com/start\n\nadd font:\nhttps://fonts.google.com/\n\nphoto engine:\nhttps://unsplash.com/developers\n\ncdnjs is a free and open-source CDN service:\nhttps://cdnjs.com/\n\njquery:\nhttps://releases.jquery.com/\n\nLIGHTBOX:\nhttps://lokeshdhakar.com/projects/lightbox2/\n\ngenerate the icon in the website title:\nhttp://tools.dynamicdrive.com/favicon/\n\ndisplay\n\n- margin\n-- border (outside)\n--- padding (inside)\n---- element\n\n\nthe one in the furthdown will overwirte the furthup in css\n\nmake inline as block :\n\ndisplay: block;\n\n\nmake block as inline :\n\ndisplay: inline;\n\n\nmake block as inline and use margin and width:\n\ndisplay: inline-block;\n\n\nPosition\n\nStatic Not effected by tblr(Top, bottom, left, right) properties/values\n\nRelative tblr values cause element to be moved from its normal position\n\nAbsolute Positioned relative to its parent element that is positioned “relative”\n\nFixed Positioned relative to the viewport\n\nSticky Positioned based on scroll position\n\nResponsive Design\n\nPractices To Use\n\n\n  Set the viewport / scale\n  Use fluid widths as oppose to fixed\n  Media queries - Different css styling for different screeen sizes\n  Rem units over px\n  Mobile first method\n\n\nEm &amp; Rem\n\nRem is only based on root\n\n/* change the base root font size */\nhtml {\n  font-size: 10px;\n}\n\n\nem is based on the element which in front of it\n\nAlognment Properties\n\n\n  justify-content: Align along the main axis (horizontal)\n  align-item: Align item along the cross axis(Vertical)\n  align-content: Align when extra space in cross axis\n\n\nTypes of Web Hosting\n\n\n  Shared Hosting\n  VPS Hosting\n  Dedicated Server\n  Reseller Hosting\n  Cloud Hosting\n  Static Hosting\n\n\nShared Hosting\n\n\n  One account of many on a server (same environment)\n  Cheapest(aside from free static hosting)\n  Used for small websites\n  Most include email, FTP, PHP, databases, software\n  $3 ~ $15 per month\n\n\nExample: Inmotion Hosting, Hostgator, Bluehost\n\nVPS Hosting（Virtual Private Server)\n\n\n  Your own virtualized server\n  Can create &amp; multiple shared accounts\n  More access &amp; privileges\n  Everything shared hosting offers\n  $20 ~ $100 per month\n\n\nExample: Inmotion Hosting, Hostgator, Bluehost\n\nDedicated Server\n\n\n  Your own actual server\n  You rent out a physcial machine\n  Full access &amp; privileges\n  Header to manager but very powerful\n  $100 ~ $400 per month\n\n\nExample: Inmotion Hosting, Hostgator, Bluehost\n\nReseller Hosting\n\n\n  Can create &amp; multiple shared accounts\n  Can sell shared accounts to your own customers\n  Very similar to a VPS\n  Usually comes with reseller software\n  $15 ~ $100q per month\n\n\nExample: Inmotion Hosting, Hostgator\n\nCloud Hosting\n\n\n  Used for web apps\n  Multiple servers work together\n  Very scalable and great for large apps\n  Not for beginners / harder to manager\n  pay as you go\n\n\nExample: Digital Ocean, Linode, Vultr\n\nStatic Hosting\n\n\n  Does not come with bells and whistles of managed hosting\n  Upload static site via Git\n  Great for static websites\n  Free, but pay for extra features\n\n\nExample: Netlify, Github Pages\n",
        "content": "HTML and CSS\n\nThis a note of studying HTML and CSS\n\nWarming\n\n.example .pp = E F 是后代选择器。\n\n.example.pp2 则是在一个元素上，这个元素包括这两个类才会有效果。\n\ndo not repeat id in the same page\n\n\nThe basic of HTML\n\n\n  Elements surrounded in angle brackets\n  Usually have a start &amp; end tag\n  Some tags closse themselves(Remnant of XHTML)\n\n\nindex.html is your home page.\n\nMust use &lt;!DOCTYPE html&gt; and this means this page is using html 5.\n\n&lt;!-- the content showed on the search engine --&gt;\n&lt;meta name=\"\" content=\"\" /&gt;\n&lt;!-- Do not index page --&gt;\n&lt;meta name=\"robots\" content=\"NOINDEX, NOFOLLOW\" /&gt;\n\n\nw3school can provide:\n\n\n  blocks level this element contain whole line and give an cross line\n  inline element\n\n\nQuick input div#idname + tab = &lt;div id=\"idname\"&gt;&lt;/div&gt;\n\n#idname + tab = &lt;div id=\"idname\"&gt;&lt;/div&gt;  other need to be specificy\n\nHTML5 Semantic Tags:\n\n\n\nThe difference between an ID and a class is that an ID is only used to identify one single element in our HTML. IDs are only used when one element on the page should have a particular style applied to it. However, a class can be used to identify more than one HTML element.\n\nCSS selectors\n\n\n  Descendant Selector (space)\n  Child Selector (&gt;)\n  Adjacent Sibling Selector (+)\n  General Sibling Selector (~)\n\n\nSpace Symbol\n\nIt is called the Descendant selector. It will target all &lt;p&gt; tags within container div. All &lt;p&gt; elements that are children of #container at any depth.\n\n‘&gt;’ Symbol\n\nThis is called the child selector. CSS rules will be applied to elements which are direct children of the particular element.\n\nIt will target all the &lt;p&gt; tags which are immediate children of container &lt;div&gt;, but the children of children will not be selected\n\n‘+’ Symbol\n\nThis is Adjacent Sibling Selector. It selects all elements that are the adjacent siblings of a specified element.\n\nSibling elements must have the same parent element, and “adjacent” means “immediately following”.\n\n‘~’ Symbol\n\nIt is General Sibling Selector and similar to Adjacent Sibling Selector. It selects all next elements that are siblings of a specified element.\n\nThe following example selects all next &lt;p&gt; elements that are siblings of &lt;div&gt; elements.\n\nShortcut\n\ncommand + enter add a new ling whatever your mouse are\n\nshift + option + down copy the line\n\noption + arrows cross the words\n\nholding option + arrows move the line\n\nholidng option + D select the same words(you can change them all)\n\nmac: command + option + U show the source code of the website.\n\nCSS Units\n\nAbsolute\n\ncm Centimeter\nmm Millimeters\nin Inches\npx Pixels (1px = 1/96 of 1 in)\npt Ponint (1pt = 1/72 of 1 in)\npc Picas picas (1pc = 12 pt)\n\n\nRelative\n\n%   To parent element\nem  To font-size of parent element\nrem To font size of root element\nvw  To 1% of viewport width\nvh  To 1% of viewport height\n\n\nUseful links\n\nfind beauty color:\nhttps://www.color-hex.com/\n\nfont icon:\nhttps://fontawesome.com/start\n\nadd font:\nhttps://fonts.google.com/\n\nphoto engine:\nhttps://unsplash.com/developers\n\ncdnjs is a free and open-source CDN service:\nhttps://cdnjs.com/\n\njquery:\nhttps://releases.jquery.com/\n\nLIGHTBOX:\nhttps://lokeshdhakar.com/projects/lightbox2/\n\ngenerate the icon in the website title:\nhttp://tools.dynamicdrive.com/favicon/\n\ndisplay\n\n- margin\n-- border (outside)\n--- padding (inside)\n---- element\n\n\nthe one in the furthdown will overwirte the furthup in css\n\nmake inline as block :\n\ndisplay: block;\n\n\nmake block as inline :\n\ndisplay: inline;\n\n\nmake block as inline and use margin and width:\n\ndisplay: inline-block;\n\n\nPosition\n\nStatic Not effected by tblr(Top, bottom, left, right) properties/values\n\nRelative tblr values cause element to be moved from its normal position\n\nAbsolute Positioned relative to its parent element that is positioned “relative”\n\nFixed Positioned relative to the viewport\n\nSticky Positioned based on scroll position\n\nResponsive Design\n\nPractices To Use\n\n\n  Set the viewport / scale\n  Use fluid widths as oppose to fixed\n  Media queries - Different css styling for different screeen sizes\n  Rem units over px\n  Mobile first method\n\n\nEm &amp; Rem\n\nRem is only based on root\n\n/* change the base root font size */\nhtml {\n  font-size: 10px;\n}\n\n\nem is based on the element which in front of it\n\nAlognment Properties\n\n\n  justify-content: Align along the main axis (horizontal)\n  align-item: Align item along the cross axis(Vertical)\n  align-content: Align when extra space in cross axis\n\n\nTypes of Web Hosting\n\n\n  Shared Hosting\n  VPS Hosting\n  Dedicated Server\n  Reseller Hosting\n  Cloud Hosting\n  Static Hosting\n\n\nShared Hosting\n\n\n  One account of many on a server (same environment)\n  Cheapest(aside from free static hosting)\n  Used for small websites\n  Most include email, FTP, PHP, databases, software\n  $3 ~ $15 per month\n\n\nExample: Inmotion Hosting, Hostgator, Bluehost\n\nVPS Hosting（Virtual Private Server)\n\n\n  Your own virtualized server\n  Can create &amp; multiple shared accounts\n  More access &amp; privileges\n  Everything shared hosting offers\n  $20 ~ $100 per month\n\n\nExample: Inmotion Hosting, Hostgator, Bluehost\n\nDedicated Server\n\n\n  Your own actual server\n  You rent out a physcial machine\n  Full access &amp; privileges\n  Header to manager but very powerful\n  $100 ~ $400 per month\n\n\nExample: Inmotion Hosting, Hostgator, Bluehost\n\nReseller Hosting\n\n\n  Can create &amp; multiple shared accounts\n  Can sell shared accounts to your own customers\n  Very similar to a VPS\n  Usually comes with reseller software\n  $15 ~ $100q per month\n\n\nExample: Inmotion Hosting, Hostgator\n\nCloud Hosting\n\n\n  Used for web apps\n  Multiple servers work together\n  Very scalable and great for large apps\n  Not for beginners / harder to manager\n  pay as you go\n\n\nExample: Digital Ocean, Linode, Vultr\n\nStatic Hosting\n\n\n  Does not come with bells and whistles of managed hosting\n  Upload static site via Git\n  Great for static websites\n  Free, but pay for extra features\n\n\nExample: Netlify, Github Pages\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2022/05/11/HTML-and-CSS/"
      },
    
      {
        "title": "XT4",
        "excerpt": "XT4\n\n光圈 在镜头上\n\n右边 快门设置\n\n左边 iso 设置\n\n左边 下面：\n模式拨盘：s 单张拍摄模式\n        cl 低速连拍\n        ch 高速连拍\n        bkt 包围曝光模式（有6种模式）\n        adv 高级模式（滤镜）\n（胶片模拟只能在s，cl， ch 里用，右下按钮左键）\n\naf 是 开启自动对焦\nael 自动曝光\n\n正面 右下\n \nm 手动对焦\nc 连续自动对焦\ns 单词自动对焦\n\n\n\n曝光模式\n\n\n  P 挡\n\n\n光圈（镜头上的） a\n\n右面 （快门） a\n\n\n  A 挡 （光圈优先）\n\n\n光圈（镜头上的）不是 a\n\n右面 （快门） a\n\n\n  S 挡 （快门优先）街上拍\n\n\n光圈（镜头上的） a\n\n右面 （快门） 不是a\n\n\n  M 挡 （自动挡）\n\n\n光圈（镜头上的）不是 a\n\n右面 （快门） 不是a\n\n\n  \n    全自动，3个a\n  \n  \n    3个里面有一个a和曝光补偿一起才会有用，没有a 的话，曝光补偿无用\n  \n\n",
        "content": "XT4\n\n光圈 在镜头上\n\n右边 快门设置\n\n左边 iso 设置\n\n左边 下面：\n模式拨盘：s 单张拍摄模式\n        cl 低速连拍\n        ch 高速连拍\n        bkt 包围曝光模式（有6种模式）\n        adv 高级模式（滤镜）\n（胶片模拟只能在s，cl， ch 里用，右下按钮左键）\n\naf 是 开启自动对焦\nael 自动曝光\n\n正面 右下\n \nm 手动对焦\nc 连续自动对焦\ns 单词自动对焦\n\n\n\n曝光模式\n\n\n  P 挡\n\n\n光圈（镜头上的） a\n\n右面 （快门） a\n\n\n  A 挡 （光圈优先）\n\n\n光圈（镜头上的）不是 a\n\n右面 （快门） a\n\n\n  S 挡 （快门优先）街上拍\n\n\n光圈（镜头上的） a\n\n右面 （快门） 不是a\n\n\n  M 挡 （自动挡）\n\n\n光圈（镜头上的）不是 a\n\n右面 （快门） 不是a\n\n\n  \n    全自动，3个a\n  \n  \n    3个里面有一个a和曝光补偿一起才会有用，没有a 的话，曝光补偿无用\n  \n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2022/05/14/XT4/"
      },
    
      {
        "title": "JavaScript",
        "excerpt": "JavaScript\n\nThis a note of studying HTML and CSS\n\nWarming\n\nvar 声明是全局作用域或函数作用域，\n\nlet 和 const 是块作用域。\n\nvar 变量可以在其范围内更新和重新声明；\n\nlet 变量可以被更新但不能重新声明； const 变量既不能更新也不能重新声明。 它们都被提升到其作用域的顶端。\n\n99.99% 是const 0.01% 是let\n\n\nThe basic of JS\n\n== equality 等同，=== identity 恒等。\n\n==， 两边值类型不同的时候，要先进行类型转换，再比较。\n==，不做类型转换，类型不同的一定不等。\n\n下面分别说明：\n先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等：\n\n\n  如果类型不同，就[不相等]\n  如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是 NaN，那么[不相等]。（判断一个值是否是 NaN，只能用 isNaN()来判断）\n  如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。\n  如果两个值都是 true，或者都是 false，那么[相等]。\n  如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]\n  如果两个值都是 null，或者都是 undefined，那么[相等]。\n\n\n再说 ==，根据以下规则：\n\n\n  如果两个值类型相同，进行 === 比较。\n  \n    如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：\n\n    a. 如果一个是 null. 一个是 undefined，那么[相等]。\n\n    b. 如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。\n\n    c. 如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。\n\n    d. 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 js 核心内置类，会尝试 valueOf 先于 toString；例外的是 Date，Date 利用的是 toString 转换。非 js 核心的对象单独说\n\n    e. 任何其他组合，都[不相等]。\n  \n\n",
        "content": "JavaScript\n\nThis a note of studying HTML and CSS\n\nWarming\n\nvar 声明是全局作用域或函数作用域，\n\nlet 和 const 是块作用域。\n\nvar 变量可以在其范围内更新和重新声明；\n\nlet 变量可以被更新但不能重新声明； const 变量既不能更新也不能重新声明。 它们都被提升到其作用域的顶端。\n\n99.99% 是const 0.01% 是let\n\n\nThe basic of JS\n\n== equality 等同，=== identity 恒等。\n\n==， 两边值类型不同的时候，要先进行类型转换，再比较。\n==，不做类型转换，类型不同的一定不等。\n\n下面分别说明：\n先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等：\n\n\n  如果类型不同，就[不相等]\n  如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是 NaN，那么[不相等]。（判断一个值是否是 NaN，只能用 isNaN()来判断）\n  如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。\n  如果两个值都是 true，或者都是 false，那么[相等]。\n  如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]\n  如果两个值都是 null，或者都是 undefined，那么[相等]。\n\n\n再说 ==，根据以下规则：\n\n\n  如果两个值类型相同，进行 === 比较。\n  \n    如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：\n\n    a. 如果一个是 null. 一个是 undefined，那么[相等]。\n\n    b. 如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。\n\n    c. 如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。\n\n    d. 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 js 核心内置类，会尝试 valueOf 先于 toString；例外的是 Date，Date 利用的是 toString 转换。非 js 核心的对象单独说\n\n    e. 任何其他组合，都[不相等]。\n  \n\n",
        "url": "/%E4%B8%AD%E6%96%87%E7%AC%94%E8%AE%B0/2022/05/21/JavaScript/"
      },
    
      {
        "title": "Regular Expression Matching",
        "excerpt": "&lt;-H 10&gt; Regular Expression Matching\n\n// Method 1\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        char char_s[s.size() + 1];\n        char char_p[p.size() + 1];\n        strcpy(char_s, s.c_str());\n        strcpy(char_p, p.c_str());\n        return isMatch(char_s, char_p);\n    }\nprivate:\n    bool isMatch(const char *s, const char *p) {\n        if(*p == '\\0')\n            return *s == '\\0';\n        if(*(p + 1) != '*') {\n            if(*p == *s || (*p == '.' &amp;&amp; *s != '\\0'))\n                return isMatch(s + 1, p + 1);\n            else\n                return false;\n        }\n        else {\n            while(*p == *s || (*p == '.' &amp;&amp; *s != '\\0')) {\n                if(isMatch(s, p + 2))\n                    return true;\n                s++;\n            }\n            return isMatch(s, p + 2);\n        }\n    }\n};\n\n// Method 2\nclass Solution {\n\n   \t// s=\"aab\"  p=\"c*a*b\"  c* -&gt; j-2 as c will be repeated 0 times\n\nprivate:\n    bool helper(int i, int j, string &amp;s, string &amp;p, vector&lt;vector &lt; int&gt;&gt; &amp;dp) {\n        if (i &lt; 0 &amp;&amp; j &lt; 0)\n            return true;\n        if (i &gt;= 0 &amp;&amp; j &lt; 0)\n            return false;\n        if (i &lt; 0 &amp;&amp; j &gt;= 0) {\n            int count = 0, len = j + 1;\n            if (len &amp; 1)\n                return false;\n            while (j &gt;= 0) {\n                if (p[j--] == '*')\n                    count++;\n            }\n            return count == len / 2;\n        }\n\n        if (dp[i][j] != -1)\n            return dp[i][j];\n        if (s[i] == p[j] or p[j] == '.')\n            return dp[i][j] = helper(i - 1, j - 1, s, p, dp);\n        else if (p[j] == '*')\n            return dp[i][j] = helper(i, j - 2, s, p, dp)\n                || ((s[i] == p[j - 1] || p[j - 1] == '.')\n                &amp;&amp; helper(i - 1, j, s, p, dp));\n\n        return dp[i][j] = false;\n    }\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector&lt;vector &lt; int&gt;&gt; dp(m, vector&lt;int&gt; (n, -1));\n        return helper(m - 1, n - 1, s, p, dp);\n    }\n};\n\n",
        "content": "&lt;-H 10&gt; Regular Expression Matching\n\n// Method 1\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        char char_s[s.size() + 1];\n        char char_p[p.size() + 1];\n        strcpy(char_s, s.c_str());\n        strcpy(char_p, p.c_str());\n        return isMatch(char_s, char_p);\n    }\nprivate:\n    bool isMatch(const char *s, const char *p) {\n        if(*p == '\\0')\n            return *s == '\\0';\n        if(*(p + 1) != '*') {\n            if(*p == *s || (*p == '.' &amp;&amp; *s != '\\0'))\n                return isMatch(s + 1, p + 1);\n            else\n                return false;\n        }\n        else {\n            while(*p == *s || (*p == '.' &amp;&amp; *s != '\\0')) {\n                if(isMatch(s, p + 2))\n                    return true;\n                s++;\n            }\n            return isMatch(s, p + 2);\n        }\n    }\n};\n\n// Method 2\nclass Solution {\n\n   \t// s=\"aab\"  p=\"c*a*b\"  c* -&gt; j-2 as c will be repeated 0 times\n\nprivate:\n    bool helper(int i, int j, string &amp;s, string &amp;p, vector&lt;vector &lt; int&gt;&gt; &amp;dp) {\n        if (i &lt; 0 &amp;&amp; j &lt; 0)\n            return true;\n        if (i &gt;= 0 &amp;&amp; j &lt; 0)\n            return false;\n        if (i &lt; 0 &amp;&amp; j &gt;= 0) {\n            int count = 0, len = j + 1;\n            if (len &amp; 1)\n                return false;\n            while (j &gt;= 0) {\n                if (p[j--] == '*')\n                    count++;\n            }\n            return count == len / 2;\n        }\n\n        if (dp[i][j] != -1)\n            return dp[i][j];\n        if (s[i] == p[j] or p[j] == '.')\n            return dp[i][j] = helper(i - 1, j - 1, s, p, dp);\n        else if (p[j] == '*')\n            return dp[i][j] = helper(i, j - 2, s, p, dp)\n                || ((s[i] == p[j - 1] || p[j - 1] == '.')\n                &amp;&amp; helper(i - 1, j, s, p, dp));\n\n        return dp[i][j] = false;\n    }\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector&lt;vector &lt; int&gt;&gt; dp(m, vector&lt;int&gt; (n, -1));\n        return helper(m - 1, n - 1, s, p, dp);\n    }\n};\n\n",
        "url": "/2022/06/24/10-Regular-Expression-Matching/"
      },
    
      {
        "title": "Construct Binary Search Tree from Preorder Traversal",
        "excerpt": "&lt;-M 1008&gt; Construct Binary Search Tree from Preorder Traversal\n\nclass Solution {\npublic:\n    TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) {\n        int i=0;\n        return treeHelp(preorder, i, LONG_MAX);\n    }\n\n    TreeNode* treeHelp(vector&lt;int&gt; &amp;preorder, int &amp;i, long maxVal) {\n        if(i == preorder.size() || preorder[i] &gt; maxVal)\n            return NULL;\n\n        TreeNode *n = new TreeNode(preorder[i++]);\n\n        n-&gt;left = treeHelp(preorder, i, n-&gt;val);\n        n-&gt;right = treeHelp(preorder, i, maxVal);\n\n        return n;\n    }\n};\n\n",
        "content": "&lt;-M 1008&gt; Construct Binary Search Tree from Preorder Traversal\n\nclass Solution {\npublic:\n    TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) {\n        int i=0;\n        return treeHelp(preorder, i, LONG_MAX);\n    }\n\n    TreeNode* treeHelp(vector&lt;int&gt; &amp;preorder, int &amp;i, long maxVal) {\n        if(i == preorder.size() || preorder[i] &gt; maxVal)\n            return NULL;\n\n        TreeNode *n = new TreeNode(preorder[i++]);\n\n        n-&gt;left = treeHelp(preorder, i, n-&gt;val);\n        n-&gt;right = treeHelp(preorder, i, maxVal);\n\n        return n;\n    }\n};\n\n",
        "url": "/2022/06/24/1008-Construct-Binary-Search-Tree-from-Preorder-Traversal/"
      },
    
      {
        "title": "Binary Tree Level Order Traversal",
        "excerpt": "&lt;-M 102&gt; Binary Tree Level Order Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\n\nprivate:\n    void traverse(TreeNode *root, int level, vector&lt;vector&lt;int&gt;&gt; &amp;result) {\n        if(!root)\n            return;\n        if(level &gt; result.size())\n            result.push_back(vector&lt;int&gt;());\n\n        result[level - 1].push_back(root-&gt;val);\n        traverse(root-&gt;left, level + 1, result);\n        traverse(root-&gt;right, level + 1, result);\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        vector&lt;vector&lt;int&gt;&gt; result;\n        traverse(root, 1, result);\n        return result;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        if(root == NULL)\n            return ans;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        vector&lt;int&gt;level;\n        while(!q.empty()) {\n            int s = q.size();\n            while(s--) {\n                TreeNode* node = q.front();\n                q.pop();\n                level.push_back(node-&gt;val);\n                if(node-&gt;left)\n                    q.push(node-&gt;left);\n                if(node-&gt;right)\n                    q.push(node-&gt;right);\n            }\n            ans.push_back(level);\n            level.clear();\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 102&gt; Binary Tree Level Order Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\n\nprivate:\n    void traverse(TreeNode *root, int level, vector&lt;vector&lt;int&gt;&gt; &amp;result) {\n        if(!root)\n            return;\n        if(level &gt; result.size())\n            result.push_back(vector&lt;int&gt;());\n\n        result[level - 1].push_back(root-&gt;val);\n        traverse(root-&gt;left, level + 1, result);\n        traverse(root-&gt;right, level + 1, result);\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        vector&lt;vector&lt;int&gt;&gt; result;\n        traverse(root, 1, result);\n        return result;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        if(root == NULL)\n            return ans;\n        queue&lt;TreeNode*&gt; q;\n        q.push(root);\n        vector&lt;int&gt;level;\n        while(!q.empty()) {\n            int s = q.size();\n            while(s--) {\n                TreeNode* node = q.front();\n                q.pop();\n                level.push_back(node-&gt;val);\n                if(node-&gt;left)\n                    q.push(node-&gt;left);\n                if(node-&gt;right)\n                    q.push(node-&gt;right);\n            }\n            ans.push_back(level);\n            level.clear();\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/102-Binary-Tree-Level-Order-Traversal/"
      },
    
      {
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "excerpt": "&lt;-M 105&gt; Construct Binary Tree from Preorder and Inorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        map&lt;int,int&gt; mp;\n        for(int i = 0; i &lt; inorder.size(); i++) {\n            mp[inorder[i]] = i;\n        }\n\n        TreeNode* root = Tree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, mp);\n        return root;\n    }\n\n    TreeNode* Tree(vector&lt;int&gt;&amp;preorder, int preStart, int preEnd, vector&lt;int&gt;&amp;inorder, int inStart, int inEnd, map&lt;int,int&gt;&amp;mp) {\n         if (preStart &gt; preEnd || inStart &gt; inEnd)\n             return NULL;\n\n          TreeNode * root = new TreeNode(preorder[preStart]);\n          int elem = mp[root-&gt;val];\n          int nElem = elem - inStart;\n\n          root-&gt;left = Tree(preorder, preStart + 1, preStart + nElem, inorder,\n          inStart, elem - 1, mp);\n          root-&gt;right = Tree(preorder, preStart + nElem + 1, preEnd, inorder,\n          elem + 1, inEnd, mp);\n\n          return root;\n    }\n};\n\n",
        "content": "&lt;-M 105&gt; Construct Binary Tree from Preorder and Inorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        map&lt;int,int&gt; mp;\n        for(int i = 0; i &lt; inorder.size(); i++) {\n            mp[inorder[i]] = i;\n        }\n\n        TreeNode* root = Tree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, mp);\n        return root;\n    }\n\n    TreeNode* Tree(vector&lt;int&gt;&amp;preorder, int preStart, int preEnd, vector&lt;int&gt;&amp;inorder, int inStart, int inEnd, map&lt;int,int&gt;&amp;mp) {\n         if (preStart &gt; preEnd || inStart &gt; inEnd)\n             return NULL;\n\n          TreeNode * root = new TreeNode(preorder[preStart]);\n          int elem = mp[root-&gt;val];\n          int nElem = elem - inStart;\n\n          root-&gt;left = Tree(preorder, preStart + 1, preStart + nElem, inorder,\n          inStart, elem - 1, mp);\n          root-&gt;right = Tree(preorder, preStart + nElem + 1, preEnd, inorder,\n          elem + 1, inEnd, mp);\n\n          return root;\n    }\n};\n\n",
        "url": "/2022/06/24/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"
      },
    
      {
        "title": "Convert Sorted List to Binary Search Tree",
        "excerpt": "&lt;-M 109&gt; Convert Sorted List to Binary Search Tree\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortedListToBST(head, listLength(head));\n    }\nprivate:\n    TreeNode* sortedListToBST(ListNode *head, int len) {\n        if(len == 0)\n            return nullptr;\n        if(len == 1)\n            return new TreeNode(head-&gt;val);\n\n        TreeNode *root = new TreeNode(nth_node(head, len / 2 + 1)-&gt;val);\n        root-&gt;left = sortedListToBST(head, len / 2);\n        root-&gt;right = sortedListToBST(nth_node(head, len / 2 + 2), (len - 1) / 2);\n        return root;\n    }\n\n\n    int listLength(ListNode *node) {\n        int n = 0;\n        while(node) {\n            ++n;\n            node = node-&gt;next;\n        }\n        return n;\n    }\n\n    ListNode* nth_node(ListNode* node, int n) {\n        while(--n) {\n            node = node-&gt;next;\n        }\n        return node;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    TreeNode * buildBST(const vector&lt;int&gt; &amp;v, const int lo, const int hi) {\n        if (lo &gt; hi)\n            return NULL;\n\n        const int m = lo + ((hi - lo) &gt;&gt; 1);\n        TreeNode * ret = new TreeNode(v[ m ]);\n        ret-&gt;left = buildBST(v, lo, m - 1);\n        ret-&gt;right = buildBST(v, m + 1, hi);\n        return ret;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector&lt;int&gt; v;\n        for (ListNode * cur = head; cur != NULL; cur = cur-&gt;next)\n            v.push_back(cur-&gt;val);\n\n        TreeNode * ret = buildBST(v, 0, v.size() - 1);\n        return ret;\n    }\n};\n\n",
        "content": "&lt;-M 109&gt; Convert Sorted List to Binary Search Tree\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortedListToBST(head, listLength(head));\n    }\nprivate:\n    TreeNode* sortedListToBST(ListNode *head, int len) {\n        if(len == 0)\n            return nullptr;\n        if(len == 1)\n            return new TreeNode(head-&gt;val);\n\n        TreeNode *root = new TreeNode(nth_node(head, len / 2 + 1)-&gt;val);\n        root-&gt;left = sortedListToBST(head, len / 2);\n        root-&gt;right = sortedListToBST(nth_node(head, len / 2 + 2), (len - 1) / 2);\n        return root;\n    }\n\n\n    int listLength(ListNode *node) {\n        int n = 0;\n        while(node) {\n            ++n;\n            node = node-&gt;next;\n        }\n        return n;\n    }\n\n    ListNode* nth_node(ListNode* node, int n) {\n        while(--n) {\n            node = node-&gt;next;\n        }\n        return node;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    TreeNode * buildBST(const vector&lt;int&gt; &amp;v, const int lo, const int hi) {\n        if (lo &gt; hi)\n            return NULL;\n\n        const int m = lo + ((hi - lo) &gt;&gt; 1);\n        TreeNode * ret = new TreeNode(v[ m ]);\n        ret-&gt;left = buildBST(v, lo, m - 1);\n        ret-&gt;right = buildBST(v, m + 1, hi);\n        return ret;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector&lt;int&gt; v;\n        for (ListNode * cur = head; cur != NULL; cur = cur-&gt;next)\n            v.push_back(cur-&gt;val);\n\n        TreeNode * ret = buildBST(v, 0, v.size() - 1);\n        return ret;\n    }\n};\n\n",
        "url": "/2022/06/24/109-Convert-Sorted-List-to-Binary-Search-Tree/"
      },
    
      {
        "title": "Combination Sum",
        "excerpt": "&lt;-M 39&gt; Combination Sum\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    void solve(int i, vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; temp, int target) {\n        if(target == 0) {\n            ans.push_back(temp);\n            return;\n        }\n\n        if(target &lt; 0)\n            return;\n\n        if(i == arr.size())\n            return;\n\n        solve(i + 1, arr, temp, target);\n\n        temp.push_back(arr[i]);\n        solve(i, arr, temp, target - arr[i]);\n        temp.pop_back();\n\n    }\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; arr, int target) {\n        ans.clear();\n        vector&lt;int&gt; temp;\n        solve(0, arr, temp, target);\n\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n\n    void comb(vector&lt;int&gt;&amp; t ,vector&lt;vector&lt;int&gt;&gt;&amp; ans , vector&lt;int&gt;&amp; candidates , int target ,int i ){\n        if(target == 0){\n            ans.push_back(t) ;\n            return ;\n        }\n        while(i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= 0){\n            t.push_back(candidates[i]) ;\n            comb(t , ans , candidates , target - candidates[i] , i ) ;\n                i++ ;\n            t.pop_back() ;\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\n        sort(candidates.begin() , candidates.end()) ;\n        candidates.erase(unique(candidates.begin() , candidates.end()) ,candidates.end()) ;\n        vector&lt;int&gt; t ;\n        vector&lt;vector&lt;int&gt;&gt; ans ;\n        comb(t , ans , candidates , target , 0 ) ;\n        return ans ;\n    }\n};\n\n",
        "content": "&lt;-M 39&gt; Combination Sum\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; ans;\n    void solve(int i, vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; temp, int target) {\n        if(target == 0) {\n            ans.push_back(temp);\n            return;\n        }\n\n        if(target &lt; 0)\n            return;\n\n        if(i == arr.size())\n            return;\n\n        solve(i + 1, arr, temp, target);\n\n        temp.push_back(arr[i]);\n        solve(i, arr, temp, target - arr[i]);\n        temp.pop_back();\n\n    }\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; arr, int target) {\n        ans.clear();\n        vector&lt;int&gt; temp;\n        solve(0, arr, temp, target);\n\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n\n    void comb(vector&lt;int&gt;&amp; t ,vector&lt;vector&lt;int&gt;&gt;&amp; ans , vector&lt;int&gt;&amp; candidates , int target ,int i ){\n        if(target == 0){\n            ans.push_back(t) ;\n            return ;\n        }\n        while(i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= 0){\n            t.push_back(candidates[i]) ;\n            comb(t , ans , candidates , target - candidates[i] , i ) ;\n                i++ ;\n            t.pop_back() ;\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {\n        sort(candidates.begin() , candidates.end()) ;\n        candidates.erase(unique(candidates.begin() , candidates.end()) ,candidates.end()) ;\n        vector&lt;int&gt; t ;\n        vector&lt;vector&lt;int&gt;&gt; ans ;\n        comb(t , ans , candidates , target , 0 ) ;\n        return ans ;\n    }\n};\n\n",
        "url": "/2022/06/24/11-39-Combination-Sum/"
      },
    
      {
        "title": "Container With Most Water",
        "excerpt": "&lt;-M 11&gt; Container With Most Water\n\nclass Solution {\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) {\n        int l = 0, r = height.size() - 1;\n        int ans = 0;\n        while(l &lt; r) {\n            ans = max(ans, (r - l) * min(height[l], height[r]));\n            if(height[l] &lt; height[r])\n                l++;\n            else\n                r--;\n        }\n      return ans;\n    }\n};\n\n",
        "content": "&lt;-M 11&gt; Container With Most Water\n\nclass Solution {\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) {\n        int l = 0, r = height.size() - 1;\n        int ans = 0;\n        while(l &lt; r) {\n            ans = max(ans, (r - l) * min(height[l], height[r]));\n            if(height[l] &lt; height[r])\n                l++;\n            else\n                r--;\n        }\n      return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/11-Container-With-Most-Water/"
      },
    
      {
        "title": "Path Sum II",
        "excerpt": "&lt;-M 113&gt; Path Sum II\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; cur;\n        pathSum(root, targetSum, cur, ans);\n        return ans;\n    }\nprivate:\n    void pathSum(TreeNode *root, int gap, vector&lt;int&gt; &amp;cur, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if(root == nullptr)\n            return;\n        cur.push_back(root-&gt;val);\n        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)\n            if(gap == root-&gt;val)\n                ans.push_back(cur);\n        pathSum(root-&gt;left, gap - root-&gt;val, cur, ans);\n        pathSum(root-&gt;right, gap - root-&gt;val, cur, ans);\n        cur.pop_back();\n\n    }\n};\n\n",
        "content": "&lt;-M 113&gt; Path Sum II\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; cur;\n        pathSum(root, targetSum, cur, ans);\n        return ans;\n    }\nprivate:\n    void pathSum(TreeNode *root, int gap, vector&lt;int&gt; &amp;cur, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if(root == nullptr)\n            return;\n        cur.push_back(root-&gt;val);\n        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)\n            if(gap == root-&gt;val)\n                ans.push_back(cur);\n        pathSum(root-&gt;left, gap - root-&gt;val, cur, ans);\n        pathSum(root-&gt;right, gap - root-&gt;val, cur, ans);\n        cur.pop_back();\n\n    }\n};\n\n",
        "url": "/2022/06/24/113-Path-Sum-II/"
      },
    
      {
        "title": "Flatten Binary Tree to Linked List",
        "excerpt": "&lt;-M 114&gt; Flatten Binary Tree to Linked List\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        flatten(root, NULL);\n    }\nprivate:\n    TreeNode *flatten(TreeNode *root, TreeNode *tail) {\n        if(NULL == root)\n            return tail;\n        root-&gt;right = flatten(root-&gt;left, flatten(root-&gt;right, tail));\n        root-&gt;left = NULL;\n        return root;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr = root,*prev;\n        while(curr != NULL) {\n            if(curr-&gt;left != NULL) {\n                prev = curr-&gt;left;//move to the left if it is exist\n                while(prev-&gt;right != NULL) {\n                    prev = prev-&gt;right;\n                }\n                //making connection from left subtree right to the right of curr\n                prev-&gt;right = curr-&gt;right;\n                curr-&gt;right = curr-&gt;left;\n                curr-&gt;left = NULL;\n\n            }\n            curr = curr-&gt;right;//basically we are moving left\n        }\n\n    }\n};\n\n",
        "content": "&lt;-M 114&gt; Flatten Binary Tree to Linked List\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        flatten(root, NULL);\n    }\nprivate:\n    TreeNode *flatten(TreeNode *root, TreeNode *tail) {\n        if(NULL == root)\n            return tail;\n        root-&gt;right = flatten(root-&gt;left, flatten(root-&gt;right, tail));\n        root-&gt;left = NULL;\n        return root;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr = root,*prev;\n        while(curr != NULL) {\n            if(curr-&gt;left != NULL) {\n                prev = curr-&gt;left;//move to the left if it is exist\n                while(prev-&gt;right != NULL) {\n                    prev = prev-&gt;right;\n                }\n                //making connection from left subtree right to the right of curr\n                prev-&gt;right = curr-&gt;right;\n                curr-&gt;right = curr-&gt;left;\n                curr-&gt;left = NULL;\n\n            }\n            curr = curr-&gt;right;//basically we are moving left\n        }\n\n    }\n};\n\n",
        "url": "/2022/06/24/114-Flatten-Binary-Tree-to-Linked-List/"
      },
    
      {
        "title": "Populating Next Right Pointers in Each Node",
        "excerpt": "&lt;-M 116&gt; Populating Next Right Pointers in Each Node\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        connect(root, nullptr);\n        return root;\n    }\nprivate:\n    void connect(Node *root, Node *sibling) {\n        if(root == nullptr)\n            return;\n        else\n            root-&gt;next = sibling;\n        connect(root-&gt;left, root-&gt;right);\n        if(sibling)\n            connect(root-&gt;right, sibling-&gt;left);\n        else\n            connect(root-&gt;right, nullptr);\n\n    }\n};\n\n",
        "content": "&lt;-M 116&gt; Populating Next Right Pointers in Each Node\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        connect(root, nullptr);\n        return root;\n    }\nprivate:\n    void connect(Node *root, Node *sibling) {\n        if(root == nullptr)\n            return;\n        else\n            root-&gt;next = sibling;\n        connect(root-&gt;left, root-&gt;right);\n        if(sibling)\n            connect(root-&gt;right, sibling-&gt;left);\n        else\n            connect(root-&gt;right, nullptr);\n\n    }\n};\n\n",
        "url": "/2022/06/24/116-Populating-Next-Right-Pointers-in-Each-Node/"
      },
    
      {
        "title": "Populating Next Right Pointers in Each Node II",
        "excerpt": "&lt;-M 117&gt; Populating Next Right Pointers in Each Node II\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if(root == NULL)\n            return root;\n        queue&lt;Node*&gt; q;\n        q.push(root);\n        while(q.empty() == false) {\n            int cnt = q.size();\n            for(int i = 0; i &lt; cnt; i++) {\n                Node* curr = q.front();\n                q.pop();\n                if(cnt - 1 == i)\n                    curr-&gt;next = NULL;\n                else if(cnt - 1 != i)\n                    curr-&gt;next = q.front();\n                if(curr-&gt;left)\n                    q.push(curr-&gt;left);\n                if(curr-&gt;right)\n                    q.push(curr-&gt;right);\n            }\n        }\n        return root;\n    }\n};\n\n",
        "content": "&lt;-M 117&gt; Populating Next Right Pointers in Each Node II\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if(root == NULL)\n            return root;\n        queue&lt;Node*&gt; q;\n        q.push(root);\n        while(q.empty() == false) {\n            int cnt = q.size();\n            for(int i = 0; i &lt; cnt; i++) {\n                Node* curr = q.front();\n                q.pop();\n                if(cnt - 1 == i)\n                    curr-&gt;next = NULL;\n                else if(cnt - 1 != i)\n                    curr-&gt;next = q.front();\n                if(curr-&gt;left)\n                    q.push(curr-&gt;left);\n                if(curr-&gt;right)\n                    q.push(curr-&gt;right);\n            }\n        }\n        return root;\n    }\n};\n\n",
        "url": "/2022/06/24/117-Populating-Next-Right-Pointers-in-Each-Node-II/"
      },
    
      {
        "title": "Triangle",
        "excerpt": "&lt;-M 120&gt; Triangle\n\nclass Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        for(int i = triangle.size() - 2; i &gt;= 0; i--)\n            for(int j = 0; j &lt; i + 1; j++)\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n        return triangle[0][0];\n    }\n};\n\n",
        "content": "&lt;-M 120&gt; Triangle\n\nclass Solution {\npublic:\n    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n        for(int i = triangle.size() - 2; i &gt;= 0; i--)\n            for(int j = 0; j &lt; i + 1; j++)\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n        return triangle[0][0];\n    }\n};\n\n",
        "url": "/2022/06/24/120-Triangle/"
      },
    
      {
        "title": "Best Time to Buy and Sell Stock III",
        "excerpt": "&lt;-H 123&gt; Best Time to Buy and Sell Stock III\n\nclass Solution {\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) {\n        if(prices.size() &lt; 2)\n            return 0;\n\n        const int n = prices.size();\n\n        vector&lt;int&gt; f(n, 0);\n        vector&lt;int&gt; g(n, 0);\n\n        for(int i = 1, val = prices[0]; i &lt; n; i++) {\n            val = min(val, prices[i]);\n            f[i] = max(f[i - 1], prices[i] - val);\n        }\n        for(int i = n - 2, peak = prices[n - 1]; i &gt;= 0; i--) {\n            peak = max(peak, prices[i]);\n            g[i] = max(g[i], peak - prices[i]);\n        }\n\n        int max_profit = 0;\n\n        for(int i = 0; i &lt; n; i++) {\n            max_profit = max(max_profit, f[i] + g[i]);\n        }\n        return max_profit;\n    }\n};\n\n",
        "content": "&lt;-H 123&gt; Best Time to Buy and Sell Stock III\n\nclass Solution {\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) {\n        if(prices.size() &lt; 2)\n            return 0;\n\n        const int n = prices.size();\n\n        vector&lt;int&gt; f(n, 0);\n        vector&lt;int&gt; g(n, 0);\n\n        for(int i = 1, val = prices[0]; i &lt; n; i++) {\n            val = min(val, prices[i]);\n            f[i] = max(f[i - 1], prices[i] - val);\n        }\n        for(int i = n - 2, peak = prices[n - 1]; i &gt;= 0; i--) {\n            peak = max(peak, prices[i]);\n            g[i] = max(g[i], peak - prices[i]);\n        }\n\n        int max_profit = 0;\n\n        for(int i = 0; i &lt; n; i++) {\n            max_profit = max(max_profit, f[i] + g[i]);\n        }\n        return max_profit;\n    }\n};\n\n",
        "url": "/2022/06/24/123-Best-Time-to-Buy-and-Sell-Stock-III/"
      },
    
      {
        "title": "Binary Tree Maximum Path Sum",
        "excerpt": "&lt;-H 124&gt; Binary Tree Maximum Path Sum\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        dfs(root);\n        return max_sum;\n    }\nprivate:\n    int max_sum = INT_MIN;\n    int dfs(const TreeNode *root) {\n        if(root == nullptr)\n            return 0;\n        int left = dfs(root-&gt;left);\n        int right = dfs(root-&gt;right);\n\n        int sum = root-&gt;val;\n        if(left &gt; 0)\n            sum += left;\n        if(right &gt; 0)\n            sum += right;\n        max_sum = max(max_sum, sum);\n        return max(right, left) &gt; 0 ? max(right, left) + root-&gt;val : root-&gt;val;\n    }\n};\n\n// Method 2\nclass Solution {\nprivate:\n    int max_sum = INT_MIN;\n    int dfs(TreeNode* root) {\n        if(!root)\n            return 0;\n        int l = max(dfs(root-&gt;left), 0);\n        int r = max(dfs(root-&gt;right), 0);\n        max_sum = max(max_sum, root-&gt;val + l + r);\n        return root-&gt;val+max(l,r);\n    }\npublic:\n    int maxPathSum(TreeNode* root) {\n        dfs(root);\n        return max_sum;\n    }\n};\n\n",
        "content": "&lt;-H 124&gt; Binary Tree Maximum Path Sum\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        dfs(root);\n        return max_sum;\n    }\nprivate:\n    int max_sum = INT_MIN;\n    int dfs(const TreeNode *root) {\n        if(root == nullptr)\n            return 0;\n        int left = dfs(root-&gt;left);\n        int right = dfs(root-&gt;right);\n\n        int sum = root-&gt;val;\n        if(left &gt; 0)\n            sum += left;\n        if(right &gt; 0)\n            sum += right;\n        max_sum = max(max_sum, sum);\n        return max(right, left) &gt; 0 ? max(right, left) + root-&gt;val : root-&gt;val;\n    }\n};\n\n// Method 2\nclass Solution {\nprivate:\n    int max_sum = INT_MIN;\n    int dfs(TreeNode* root) {\n        if(!root)\n            return 0;\n        int l = max(dfs(root-&gt;left), 0);\n        int r = max(dfs(root-&gt;right), 0);\n        max_sum = max(max_sum, root-&gt;val + l + r);\n        return root-&gt;val+max(l,r);\n    }\npublic:\n    int maxPathSum(TreeNode* root) {\n        dfs(root);\n        return max_sum;\n    }\n};\n\n",
        "url": "/2022/06/24/124-Binary-Tree-Maximum-Path-Sum/"
      },
    
      {
        "title": "Word Ladder II",
        "excerpt": "&lt;-H 126&gt; Word Ladder II\n\nclass Solution {\npublic:\n    vector&lt;string&gt; g_words(string a, unordered_map&lt;string,int&gt; &amp;m){\n        vector&lt;string&gt; ans;\n\n        for(int i = 0; i &lt; a.size(); i++) {\n            string temp = a;\n            for(char j = 'a';j &lt;= 'z'; j++) {\n\n                temp[i] = j;\n                if(temp == a)\n                    continue;\n                if(m.find(temp) != m.end())\n                    ans.push_back(temp);\n            }\n        }\n        return ans;\n    }\n\n    void backtrack(string start,string vertex,\n                   unordered_map&lt;string,vector&lt;string&gt;&gt; &amp;adj_list,\n                   vector&lt;string&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;ans) {\n\n        if(vertex == start) {\n            path.push_back(vertex);\n            vector&lt;string&gt; temp = path;\n            reverse(temp.begin(),temp.end());\n            ans.push_back(temp);\n            path.pop_back();\n            return;\n        }\n\n        path.push_back(vertex);\n        for(auto i:adj_list[vertex])\n            backtrack(start,i,adj_list,path,ans);\n\n        path.pop_back();\n        return;\n\n    }\n\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        string start = beginWord;\n        string end = endWord;\n        vector&lt;string&gt; dict = wordList;\n        unordered_map&lt;string,int&gt; m;\n        unordered_map&lt;string,int&gt; level;\n\n        unordered_map&lt;string,vector&lt;string&gt;&gt; adj_list;\n\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; path;\n\n        for(int i = 0; i &lt; dict.size(); i++)\n            m[dict[i]] = 0;\n\n\n\n        queue&lt;string&gt; q;\n        q.push(start);\n        m[start] =1;\n        level[start] =1;\n\n\n        while(!q.empty()) {\n\n            int s = q.size();\n            while(s--) {\n                string curr = q.front();\n                q.pop();\n                for(auto child : g_words(curr ,m)) {\n                    if(m[child] == 0) {\n                        q.push(child);\n                        m[child]++;\n                        level[child] = level[curr] +1;\n                        adj_list[child].push_back(curr);\n                    }\n                    else{\n                        if(level[child] == level[curr]+1)\n                            adj_list[child].push_back(curr);\n                    }\n                }\n\n            }\n        }\n\n    backtrack(start, end, adj_list, path,ans);\n\n    return ans;\n    }\n};\n\n",
        "content": "&lt;-H 126&gt; Word Ladder II\n\nclass Solution {\npublic:\n    vector&lt;string&gt; g_words(string a, unordered_map&lt;string,int&gt; &amp;m){\n        vector&lt;string&gt; ans;\n\n        for(int i = 0; i &lt; a.size(); i++) {\n            string temp = a;\n            for(char j = 'a';j &lt;= 'z'; j++) {\n\n                temp[i] = j;\n                if(temp == a)\n                    continue;\n                if(m.find(temp) != m.end())\n                    ans.push_back(temp);\n            }\n        }\n        return ans;\n    }\n\n    void backtrack(string start,string vertex,\n                   unordered_map&lt;string,vector&lt;string&gt;&gt; &amp;adj_list,\n                   vector&lt;string&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;ans) {\n\n        if(vertex == start) {\n            path.push_back(vertex);\n            vector&lt;string&gt; temp = path;\n            reverse(temp.begin(),temp.end());\n            ans.push_back(temp);\n            path.pop_back();\n            return;\n        }\n\n        path.push_back(vertex);\n        for(auto i:adj_list[vertex])\n            backtrack(start,i,adj_list,path,ans);\n\n        path.pop_back();\n        return;\n\n    }\n\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        string start = beginWord;\n        string end = endWord;\n        vector&lt;string&gt; dict = wordList;\n        unordered_map&lt;string,int&gt; m;\n        unordered_map&lt;string,int&gt; level;\n\n        unordered_map&lt;string,vector&lt;string&gt;&gt; adj_list;\n\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; path;\n\n        for(int i = 0; i &lt; dict.size(); i++)\n            m[dict[i]] = 0;\n\n\n\n        queue&lt;string&gt; q;\n        q.push(start);\n        m[start] =1;\n        level[start] =1;\n\n\n        while(!q.empty()) {\n\n            int s = q.size();\n            while(s--) {\n                string curr = q.front();\n                q.pop();\n                for(auto child : g_words(curr ,m)) {\n                    if(m[child] == 0) {\n                        q.push(child);\n                        m[child]++;\n                        level[child] = level[curr] +1;\n                        adj_list[child].push_back(curr);\n                    }\n                    else{\n                        if(level[child] == level[curr]+1)\n                            adj_list[child].push_back(curr);\n                    }\n                }\n\n            }\n        }\n\n    backtrack(start, end, adj_list, path,ans);\n\n    return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/126-Word-Ladder-II/"
      },
    
      {
        "title": "Word Ladder",
        "excerpt": "&lt;-H 127&gt; Word Ladder\n\n// Method 1\nclass Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        int flag = 0;\n        for(auto &amp;it : wordList) {\n            if(endWord == it) {\n                flag = 1;\n                break;\n            }\n        }\n        if(!flag)\n            return 0;\n        map&lt;string,vector&lt;string&gt;&gt; m;\n        wordList.push_back(beginWord);\n        for(int i = 0; i &lt; wordList.size(); i++) {\n            for(int j = 0; j &lt; wordList[i].size(); j++) {\n                string res = wordList[i];\n                res[j] = '*';\n                m[res].push_back(wordList[i]);\n            }\n        }\n        map&lt;string,int&gt;vis;\n        queue&lt;string&gt;q;\n        q.push(beginWord);\n        int count = 0;\n        while(!q.empty()) {\n            int size = q.size();\n            count++;\n            for(int i = 0; i &lt; size; i++) {\n                string res = q.front();\n                if(res == endWord)\n                    return count;\n                q.pop();\n\n                // if(vis[res])continue;\n                for(int j = 0; j &lt; res.size(); j++) {\n                    string pattern = res;\n                    pattern[j] = '*';\n                    for(auto &amp;it : m[pattern]) {\n                        if(vis[it])\n                            continue;\n                        else {\n                            vis[it] = 1;\n                            q.push(it);\n                        }\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n\n    int BBFS(unordered_set&lt;string&gt; &amp;dictionary,\n             int length,\n             unordered_set&lt;string&gt; &amp;beginSet,\n             unordered_set&lt;string&gt; &amp;endSet,\n             unordered_set&lt;string&gt; &amp;workingSet) {\n        workingSet.clear();\n        int n = beginSet.begin()-&gt;size();\n\n        for(auto &amp;i : beginSet)\n            dictionary.erase(i);\n\n        for(auto &amp;word : beginSet) {\n            for(int i = 0; i &lt; n; i++) {\n                string newWord = word;\n                for(char c = 'a'; c &lt;= 'z'; c++) {\n                    newWord[i] = c;\n                    if(dictionary.count(newWord)) {\n                        if(endSet.count(newWord))\n                            return length+1;\n                        workingSet.insert(newWord);\n                    }\n                }\n            }\n        }\n\n        if(workingSet.size() == 0)\n            return 0;\n\n        if(endSet.size() &lt; workingSet.size())\n            return BBFS(dictionary, length+1, endSet, workingSet, beginSet);\n\n        return BBFS(dictionary, length+1, workingSet, endSet, beginSet);\n    }\n\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        unordered_set&lt;string&gt; dictionary(wordList.begin(), wordList.end());\n\n        if(dictionary.count(endWord) == 0)\n\n            return 0;\n\n        unordered_set&lt;string&gt; beginSet;\n        beginSet.insert(beginWord);\n\n        unordered_set&lt;string&gt; endSet;\n        endSet.insert(endWord);\n\n        unordered_set&lt;string&gt; workingSet;\n\n        return BBFS(dictionary, 1, beginSet, endSet, workingSet);\n    }\n};\n\n",
        "content": "&lt;-H 127&gt; Word Ladder\n\n// Method 1\nclass Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        int flag = 0;\n        for(auto &amp;it : wordList) {\n            if(endWord == it) {\n                flag = 1;\n                break;\n            }\n        }\n        if(!flag)\n            return 0;\n        map&lt;string,vector&lt;string&gt;&gt; m;\n        wordList.push_back(beginWord);\n        for(int i = 0; i &lt; wordList.size(); i++) {\n            for(int j = 0; j &lt; wordList[i].size(); j++) {\n                string res = wordList[i];\n                res[j] = '*';\n                m[res].push_back(wordList[i]);\n            }\n        }\n        map&lt;string,int&gt;vis;\n        queue&lt;string&gt;q;\n        q.push(beginWord);\n        int count = 0;\n        while(!q.empty()) {\n            int size = q.size();\n            count++;\n            for(int i = 0; i &lt; size; i++) {\n                string res = q.front();\n                if(res == endWord)\n                    return count;\n                q.pop();\n\n                // if(vis[res])continue;\n                for(int j = 0; j &lt; res.size(); j++) {\n                    string pattern = res;\n                    pattern[j] = '*';\n                    for(auto &amp;it : m[pattern]) {\n                        if(vis[it])\n                            continue;\n                        else {\n                            vis[it] = 1;\n                            q.push(it);\n                        }\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n\n    int BBFS(unordered_set&lt;string&gt; &amp;dictionary,\n             int length,\n             unordered_set&lt;string&gt; &amp;beginSet,\n             unordered_set&lt;string&gt; &amp;endSet,\n             unordered_set&lt;string&gt; &amp;workingSet) {\n        workingSet.clear();\n        int n = beginSet.begin()-&gt;size();\n\n        for(auto &amp;i : beginSet)\n            dictionary.erase(i);\n\n        for(auto &amp;word : beginSet) {\n            for(int i = 0; i &lt; n; i++) {\n                string newWord = word;\n                for(char c = 'a'; c &lt;= 'z'; c++) {\n                    newWord[i] = c;\n                    if(dictionary.count(newWord)) {\n                        if(endSet.count(newWord))\n                            return length+1;\n                        workingSet.insert(newWord);\n                    }\n                }\n            }\n        }\n\n        if(workingSet.size() == 0)\n            return 0;\n\n        if(endSet.size() &lt; workingSet.size())\n            return BBFS(dictionary, length+1, endSet, workingSet, beginSet);\n\n        return BBFS(dictionary, length+1, workingSet, endSet, beginSet);\n    }\n\n    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {\n        unordered_set&lt;string&gt; dictionary(wordList.begin(), wordList.end());\n\n        if(dictionary.count(endWord) == 0)\n\n            return 0;\n\n        unordered_set&lt;string&gt; beginSet;\n        beginSet.insert(beginWord);\n\n        unordered_set&lt;string&gt; endSet;\n        endSet.insert(endWord);\n\n        unordered_set&lt;string&gt; workingSet;\n\n        return BBFS(dictionary, 1, beginSet, endSet, workingSet);\n    }\n};\n\n",
        "url": "/2022/06/24/127-Word-Ladder/"
      },
    
      {
        "title": "Longest Consecutive Sequence",
        "excerpt": "&lt;-M 128&gt; Longest Consecutive Sequence\n\n// Method 1\nclass Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        if(len &lt; 1)\n            return 0;\n        set&lt;int&gt; data;\n        for(auto n: nums) {\n            data.insert(n);\n        }\n        bool isFirst = true;\n        int prev, count = 0;\n        int res = 1;\n        for(int num : data) {\n            if(isFirst) {\n                prev = num;\n                count++;\n                isFirst = false;\n            }\n            else if(prev + 1 == num) {\n                count++;\n                prev = num;\n                if(res &lt; count)\n                    res = count;\n            }\n            else {\n                count = 1;\n                prev = num;\n            }\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        int count = 1;\n        int ans = 1;\n\n        if(nums.empty())\n            return 0;\n\n        for(int i = 1; i &lt; nums.size(); i++) {\n            if(nums[i] == nums[i - 1])\n                continue;\n\n            if(nums[i] - nums[i-1]==1) {\n                count++;\n                if(count &gt; ans)\n                    ans = count;\n            }\n            else {\n                count=1;\n            }\n        }\n        return ans;\n    }\n};\n\n// Method 3\nclass Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; num) {\n        unordered_map&lt;int, int&gt; map;\n        int size = num.size();\n        int l = 1;\n        for(int i = 0; i &lt; size; i++) {\n            if (map.find(num[i]) != map.end())\n                continue;\n            map[num[i]] = 1;\n            if (map.find(num[i] - 1) != map.end()) {\n                l = max(l, mergeCluster(map, num[i] - 1, num[i]));\n            }\n            if (map.find(num[i] + 1) != map.end()) {\n                l = max(l, mergeCluster(map, num[i], num[i] + 1));\n            }\n        }\n        return size == 0 ? 0 : l;\n    }\nprivate:\n    int mergeCluster(unordered_map&lt;int, int&gt; &amp;map, int left, int right) {\n        int upper = right + map[right] - 1;\n        int lower = left - map[left] + 1;\n        int length = upper - lower + 1;\n        map[upper] = length;\n        map[lower] = length;\n        return length;\n    }\n};\n\n",
        "content": "&lt;-M 128&gt; Longest Consecutive Sequence\n\n// Method 1\nclass Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) {\n        int len = nums.size();\n        if(len &lt; 1)\n            return 0;\n        set&lt;int&gt; data;\n        for(auto n: nums) {\n            data.insert(n);\n        }\n        bool isFirst = true;\n        int prev, count = 0;\n        int res = 1;\n        for(int num : data) {\n            if(isFirst) {\n                prev = num;\n                count++;\n                isFirst = false;\n            }\n            else if(prev + 1 == num) {\n                count++;\n                prev = num;\n                if(res &lt; count)\n                    res = count;\n            }\n            else {\n                count = 1;\n                prev = num;\n            }\n        }\n        return res;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        int count = 1;\n        int ans = 1;\n\n        if(nums.empty())\n            return 0;\n\n        for(int i = 1; i &lt; nums.size(); i++) {\n            if(nums[i] == nums[i - 1])\n                continue;\n\n            if(nums[i] - nums[i-1]==1) {\n                count++;\n                if(count &gt; ans)\n                    ans = count;\n            }\n            else {\n                count=1;\n            }\n        }\n        return ans;\n    }\n};\n\n// Method 3\nclass Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; num) {\n        unordered_map&lt;int, int&gt; map;\n        int size = num.size();\n        int l = 1;\n        for(int i = 0; i &lt; size; i++) {\n            if (map.find(num[i]) != map.end())\n                continue;\n            map[num[i]] = 1;\n            if (map.find(num[i] - 1) != map.end()) {\n                l = max(l, mergeCluster(map, num[i] - 1, num[i]));\n            }\n            if (map.find(num[i] + 1) != map.end()) {\n                l = max(l, mergeCluster(map, num[i], num[i] + 1));\n            }\n        }\n        return size == 0 ? 0 : l;\n    }\nprivate:\n    int mergeCluster(unordered_map&lt;int, int&gt; &amp;map, int left, int right) {\n        int upper = right + map[right] - 1;\n        int lower = left - map[left] + 1;\n        int length = upper - lower + 1;\n        map[upper] = length;\n        map[lower] = length;\n        return length;\n    }\n};\n\n",
        "url": "/2022/06/24/128-Longest-Consecutive-Sequence/"
      },
    
      {
        "title": "Sum Root to Leaf Numbers",
        "excerpt": "&lt;-M 129&gt; Sum Root to Leaf Numbers\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\nprivate:\n    int dfs(TreeNode *root, int sum) {\n        if(root == nullptr)\n            return 0;\n        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)\n            return sum * 10 + root-&gt;val;\n\n        return dfs(root-&gt;left, sum * 10 + root-&gt;val) +\n            dfs(root-&gt;right, sum * 10 + root-&gt;val);\n    }\n};\n\n",
        "content": "&lt;-M 129&gt; Sum Root to Leaf Numbers\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\nprivate:\n    int dfs(TreeNode *root, int sum) {\n        if(root == nullptr)\n            return 0;\n        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr)\n            return sum * 10 + root-&gt;val;\n\n        return dfs(root-&gt;left, sum * 10 + root-&gt;val) +\n            dfs(root-&gt;right, sum * 10 + root-&gt;val);\n    }\n};\n\n",
        "url": "/2022/06/24/129-Sum-Root-to-Leaf-Numbers/"
      },
    
      {
        "title": "Palindrome Partitioning",
        "excerpt": "&lt;-M 131&gt; Palindrome Partitioning\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        const int n = s.size();\n        bool p[n][n];\n        fill_n(&amp;p[0][0], n * n, false);\n        for(int i = n - 1; i &gt;= 0; i--)\n            for(int j = i; j &lt; n; j++)\n                p[i][j] = s[i] == s[j] &amp;&amp; ((j - i &lt; 2) || p[i + 1][j - 1]);\n\n        vector&lt;vector&lt;string&gt;&gt; sub_palins[n];\n        for(int i = n - 1; i &gt;= 0; i--)\n            for(int j = i; j &lt; n; j++)\n                if(p[i][j]) {\n                    const string plaindrome = s.substr(i, j - i + 1);\n                    if(j + 1 &lt; n)\n                        for(auto v : sub_palins[j + 1]) {\n                            v.insert(v.begin(), plaindrome);\n                            sub_palins[i].push_back(v);\n                        }\n                    else\n                         sub_palins[i].push_back(vector&lt;string&gt; {plaindrome});\n                }\n        return sub_palins[0];\n\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        vector&lt;vector&lt;string&gt; &gt; ret;\n        if(s.empty()) return ret;\n\n        vector&lt;string&gt; path;\n        dfs(0, s, path, ret);\n\n        return ret;\n    }\n\n    void dfs(int index, string&amp; s, vector&lt;string&gt;&amp; path, vector&lt;vector&lt;string&gt; &gt;&amp; ret) {\n        if(index == s.size()) {\n            ret.push_back(path);\n            return;\n        }\n        for(int i = index; i &lt; s.size(); ++i) {\n            if(isPalindrome(s, index, i)) {\n                path.push_back(s.substr(index, i - index + 1));\n                dfs(i+1, s, path, ret);\n                path.pop_back();\n            }\n        }\n    }\n\n    bool isPalindrome(const string&amp; s, int start, int end) {\n        while(start &lt;= end) {\n            if(s[start++] != s[end--])\n                return false;\n        }\n        return true;\n    }\n};\n\n",
        "content": "&lt;-M 131&gt; Palindrome Partitioning\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        const int n = s.size();\n        bool p[n][n];\n        fill_n(&amp;p[0][0], n * n, false);\n        for(int i = n - 1; i &gt;= 0; i--)\n            for(int j = i; j &lt; n; j++)\n                p[i][j] = s[i] == s[j] &amp;&amp; ((j - i &lt; 2) || p[i + 1][j - 1]);\n\n        vector&lt;vector&lt;string&gt;&gt; sub_palins[n];\n        for(int i = n - 1; i &gt;= 0; i--)\n            for(int j = i; j &lt; n; j++)\n                if(p[i][j]) {\n                    const string plaindrome = s.substr(i, j - i + 1);\n                    if(j + 1 &lt; n)\n                        for(auto v : sub_palins[j + 1]) {\n                            v.insert(v.begin(), plaindrome);\n                            sub_palins[i].push_back(v);\n                        }\n                    else\n                         sub_palins[i].push_back(vector&lt;string&gt; {plaindrome});\n                }\n        return sub_palins[0];\n\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; partition(string s) {\n        vector&lt;vector&lt;string&gt; &gt; ret;\n        if(s.empty()) return ret;\n\n        vector&lt;string&gt; path;\n        dfs(0, s, path, ret);\n\n        return ret;\n    }\n\n    void dfs(int index, string&amp; s, vector&lt;string&gt;&amp; path, vector&lt;vector&lt;string&gt; &gt;&amp; ret) {\n        if(index == s.size()) {\n            ret.push_back(path);\n            return;\n        }\n        for(int i = index; i &lt; s.size(); ++i) {\n            if(isPalindrome(s, index, i)) {\n                path.push_back(s.substr(index, i - index + 1));\n                dfs(i+1, s, path, ret);\n                path.pop_back();\n            }\n        }\n    }\n\n    bool isPalindrome(const string&amp; s, int start, int end) {\n        while(start &lt;= end) {\n            if(s[start++] != s[end--])\n                return false;\n        }\n        return true;\n    }\n};\n\n",
        "url": "/2022/06/24/131-Palindrome-Partitioning/"
      },
    
      {
        "title": "Palindrome Partitioning II",
        "excerpt": "&lt;-H 132&gt; Palindrome Partitioning II\n\nclass Solution {\npublic:\n    int minCut(string s) {\n        const int n = s.size();\n        int f[n + 1];\n        bool p[n][n];\n\n        fill_n(&amp;p[0][0], n * n, false);\n\n        for(int i = 0; i &lt;= n; i++)\n            f[i] = n - 1 - i;\n\n        for(int i = n - 1; i &gt;= 0; i--) {\n            for(int j = i; j &lt; n; j++) {\n                if(s[i] == s[j] &amp;&amp; (j - i &lt; 2 || p[i + 1][j - 1])) {\n                    p[i][j] = true;\n                    f[i] = min(f[i], f[j + 1] + 1);\n                }\n            }\n        }\n        return f[0];\n    }\n};\n\n",
        "content": "&lt;-H 132&gt; Palindrome Partitioning II\n\nclass Solution {\npublic:\n    int minCut(string s) {\n        const int n = s.size();\n        int f[n + 1];\n        bool p[n][n];\n\n        fill_n(&amp;p[0][0], n * n, false);\n\n        for(int i = 0; i &lt;= n; i++)\n            f[i] = n - 1 - i;\n\n        for(int i = n - 1; i &gt;= 0; i--) {\n            for(int j = i; j &lt; n; j++) {\n                if(s[i] == s[j] &amp;&amp; (j - i &lt; 2 || p[i + 1][j - 1])) {\n                    p[i][j] = true;\n                    f[i] = min(f[i], f[j + 1] + 1);\n                }\n            }\n        }\n        return f[0];\n    }\n};\n\n",
        "url": "/2022/06/24/132-Palindrome-Partitioning-II/"
      },
    
      {
        "title": "Gas Station",
        "excerpt": "&lt;-M 134&gt; Gas Station\n\nclass Solution {\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int total = 0;\n        int check = -1;\n\n        for(int i = 0, sum = 0; i != gas.size(); i++) {\n            sum += gas[i] - cost[i];\n            total += gas[i] - cost[i];\n            if(sum &lt; 0) {\n                check = i;\n                sum = 0;\n            }\n        }\n        return total &gt;= 0 ? check + 1 : -1;\n    }\n};\n\n",
        "content": "&lt;-M 134&gt; Gas Station\n\nclass Solution {\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int total = 0;\n        int check = -1;\n\n        for(int i = 0, sum = 0; i != gas.size(); i++) {\n            sum += gas[i] - cost[i];\n            total += gas[i] - cost[i];\n            if(sum &lt; 0) {\n                check = i;\n                sum = 0;\n            }\n        }\n        return total &gt;= 0 ? check + 1 : -1;\n    }\n};\n\n",
        "url": "/2022/06/24/134-Gas-Station/"
      },
    
      {
        "title": "Candy",
        "excerpt": "&lt;-H 135&gt; Candy\n\nclass Solution {\npublic:\n    int candy(vector&lt;int&gt;&amp; ratings) {\n        const int n = ratings.size();\n        vector&lt;int&gt; candys(n);\n\n        for(int i = 1, increased_candy = 1; i != n; i++)\n            if(ratings[i] &gt; ratings[i - 1])\n                candys[i] = max(increased_candy++, candys[i]);\n            else\n                increased_candy = 1;\n\n        for(int i = n - 2, increased_candy = 1; i &gt;= 0; i--)\n            if(ratings[i] &gt; ratings[i + 1])\n                candys[i] = max(increased_candy++, candys[i]);\n            else\n                increased_candy = 1;\n\n        return accumulate(&amp;candys[0], &amp;candys[0] + n, n);\n    }\n};\n\n",
        "content": "&lt;-H 135&gt; Candy\n\nclass Solution {\npublic:\n    int candy(vector&lt;int&gt;&amp; ratings) {\n        const int n = ratings.size();\n        vector&lt;int&gt; candys(n);\n\n        for(int i = 1, increased_candy = 1; i != n; i++)\n            if(ratings[i] &gt; ratings[i - 1])\n                candys[i] = max(increased_candy++, candys[i]);\n            else\n                increased_candy = 1;\n\n        for(int i = n - 2, increased_candy = 1; i &gt;= 0; i--)\n            if(ratings[i] &gt; ratings[i + 1])\n                candys[i] = max(increased_candy++, candys[i]);\n            else\n                increased_candy = 1;\n\n        return accumulate(&amp;candys[0], &amp;candys[0] + n, n);\n    }\n};\n\n",
        "url": "/2022/06/24/135-Candy/"
      },
    
      {
        "title": "Single Number II",
        "excerpt": "&lt;-M 137&gt; Single Number II\n\n// Method 1\nclass Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int one = 0;\n        int two = 0;\n        int three = 0;\n\n        for(int i = 0; i != nums.size(); i++) {\n            two |= (one &amp; nums[i]);\n            one ^= nums[i];\n            three = ~(one &amp; two);\n            one &amp;= three;\n            two &amp;= three;\n        }\n        return one;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        const int size = sizeof(int) * 8;\n        int count[size] = {0};\n        for(int i = 0; i != nums.size(); i++)\n            for(int j = 0; j != size; j++) {\n                count[j] += (nums[i] &gt;&gt; j) &amp; 1;\n                count[j] %= 3;\n            }\n\n        int ans = 0;\n        for(int i = 0; i != size; i++)\n            ans += (count[i] &lt;&lt; i);\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 137&gt; Single Number II\n\n// Method 1\nclass Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int one = 0;\n        int two = 0;\n        int three = 0;\n\n        for(int i = 0; i != nums.size(); i++) {\n            two |= (one &amp; nums[i]);\n            one ^= nums[i];\n            three = ~(one &amp; two);\n            one &amp;= three;\n            two &amp;= three;\n        }\n        return one;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        const int size = sizeof(int) * 8;\n        int count[size] = {0};\n        for(int i = 0; i != nums.size(); i++)\n            for(int j = 0; j != size; j++) {\n                count[j] += (nums[i] &gt;&gt; j) &amp; 1;\n                count[j] %= 3;\n            }\n\n        int ans = 0;\n        for(int i = 0; i != size; i++)\n            ans += (count[i] &lt;&lt; i);\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/137-Single-Number-II/"
      },
    
      {
        "title": "Copy List with Random Pointer",
        "excerpt": "&lt;-M 138&gt; Copy List with Random Pointer\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n\n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        for(Node *cur = head; cur != nullptr;) {\n            Node *node = new Node(cur-&gt;val);\n            node-&gt;next = cur-&gt;next;\n            cur-&gt;next = node;\n            cur = node-&gt;next;\n        }\n\n        for(Node *cur = head; cur != nullptr;) {\n            if(cur-&gt;random != NULL)\n                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;\n            cur = cur-&gt;next-&gt;next;\n        }\n\n        Node temp(-1);\n        for(Node *cur = head, *new_cur = &amp;temp;\n           cur != nullptr; ) {\n            new_cur-&gt;next = cur-&gt;next;\n            new_cur = new_cur-&gt;next;\n            cur-&gt;next = cur-&gt;next-&gt;next;\n            cur = cur-&gt;next;\n        }\n        return temp.next;\n    }\n};\n\n",
        "content": "&lt;-M 138&gt; Copy List with Random Pointer\n\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n\n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        for(Node *cur = head; cur != nullptr;) {\n            Node *node = new Node(cur-&gt;val);\n            node-&gt;next = cur-&gt;next;\n            cur-&gt;next = node;\n            cur = node-&gt;next;\n        }\n\n        for(Node *cur = head; cur != nullptr;) {\n            if(cur-&gt;random != NULL)\n                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;\n            cur = cur-&gt;next-&gt;next;\n        }\n\n        Node temp(-1);\n        for(Node *cur = head, *new_cur = &amp;temp;\n           cur != nullptr; ) {\n            new_cur-&gt;next = cur-&gt;next;\n            new_cur = new_cur-&gt;next;\n            cur-&gt;next = cur-&gt;next-&gt;next;\n            cur = cur-&gt;next;\n        }\n        return temp.next;\n    }\n};\n\n",
        "url": "/2022/06/24/138-Copy-List-with-Random-Pointer/"
      },
    
      {
        "title": "Linked List Cycle II",
        "excerpt": "&lt;-M 142&gt; Linked List Cycle II\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while(fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n            if(slow == fast) {\n                ListNode *slow_temp = head;\n                while(slow_temp != slow) {\n                    slow_temp = slow_temp-&gt;next;\n                    slow = slow-&gt;next;\n                }\n                return slow_temp;\n            }\n        }\n        return nullptr;\n    }\n};\n\n",
        "content": "&lt;-M 142&gt; Linked List Cycle II\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while(fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n            if(slow == fast) {\n                ListNode *slow_temp = head;\n                while(slow_temp != slow) {\n                    slow_temp = slow_temp-&gt;next;\n                    slow = slow-&gt;next;\n                }\n                return slow_temp;\n            }\n        }\n        return nullptr;\n    }\n};\n\n",
        "url": "/2022/06/24/142-Linked-List-Cycle-II/"
      },
    
      {
        "title": "Reorder List",
        "excerpt": "&lt;-M 143&gt; Reorder List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if(head == nullptr || head-&gt;next == nullptr)\n            return;\n\n        ListNode * slow = head, *fast = head, *prev = nullptr;\n        while(fast &amp;&amp; fast-&gt;next) {\n            prev = slow;\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n        }\n        prev-&gt;next = nullptr;\n        slow = reverse(slow);\n\n        ListNode *cur = head;\n        while(cur-&gt;next) {\n            ListNode *temp = cur-&gt;next;\n            cur-&gt;next = slow;\n            slow = slow-&gt;next;\n            cur-&gt;next-&gt;next = temp;\n            cur = temp;\n        }\n        cur-&gt;next = slow;\n    }\nprivate:\n    ListNode *reverse(ListNode *head) {\n        if(head == nullptr || head-&gt;next == nullptr)\n            return head;\n\n        ListNode *prev = head;\n        for(ListNode *cur = head-&gt;next, *next = cur-&gt;next;\n           cur;\n           prev = cur, cur = next, next = next ? next-&gt;next : nullptr) {\n            cur-&gt;next = prev;\n        }\n\n        head-&gt;next = nullptr;\n        return prev;\n    }\n};\n\n",
        "content": "&lt;-M 143&gt; Reorder List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        if(head == nullptr || head-&gt;next == nullptr)\n            return;\n\n        ListNode * slow = head, *fast = head, *prev = nullptr;\n        while(fast &amp;&amp; fast-&gt;next) {\n            prev = slow;\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n        }\n        prev-&gt;next = nullptr;\n        slow = reverse(slow);\n\n        ListNode *cur = head;\n        while(cur-&gt;next) {\n            ListNode *temp = cur-&gt;next;\n            cur-&gt;next = slow;\n            slow = slow-&gt;next;\n            cur-&gt;next-&gt;next = temp;\n            cur = temp;\n        }\n        cur-&gt;next = slow;\n    }\nprivate:\n    ListNode *reverse(ListNode *head) {\n        if(head == nullptr || head-&gt;next == nullptr)\n            return head;\n\n        ListNode *prev = head;\n        for(ListNode *cur = head-&gt;next, *next = cur-&gt;next;\n           cur;\n           prev = cur, cur = next, next = next ? next-&gt;next : nullptr) {\n            cur-&gt;next = prev;\n        }\n\n        head-&gt;next = nullptr;\n        return prev;\n    }\n};\n\n",
        "url": "/2022/06/24/143-Reorder-List/"
      },
    
      {
        "title": "LRU Cache",
        "excerpt": "&lt;-M 146&gt; LRU Cache\n\nclass LRUCache {\nprivate:\n    struct CacheNode {\n        int key;\n        int value;\n        CacheNode(int k, int v) : key(k), value(v) {}\n    };\n    list&lt;CacheNode&gt; cacheList;\n    unordered_map&lt;int, list&lt;CacheNode&gt;::iterator&gt; cacheMap;\n    int capacity;\n\npublic:\n    LRUCache(int capacity) {\n        this-&gt;capacity = capacity;\n    }\n\n    int get(int key) {\n        if(cacheMap.find(key) == cacheMap.end())\n            return -1;\n        cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);\n        cacheMap[key] = cacheList.begin();\n        return cacheMap[key]-&gt;value;\n    }\n\n    void put(int key, int value) {\n        if(cacheMap.find(key) == cacheMap.end()) {\n            if(cacheList.size() == capacity) {\n                cacheMap.erase(cacheList.back().key);\n                cacheList.pop_back();\n            }\n            cacheList.push_front(CacheNode(key, value));\n            cacheMap[key] = cacheList.begin();\n        }\n        else {\n            cacheMap[key]-&gt;value = value;\n            cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);\n            cacheMap[key] = cacheList.begin();\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj-&gt;get(key);\n * obj-&gt;put(key,value);\n */\n\n",
        "content": "&lt;-M 146&gt; LRU Cache\n\nclass LRUCache {\nprivate:\n    struct CacheNode {\n        int key;\n        int value;\n        CacheNode(int k, int v) : key(k), value(v) {}\n    };\n    list&lt;CacheNode&gt; cacheList;\n    unordered_map&lt;int, list&lt;CacheNode&gt;::iterator&gt; cacheMap;\n    int capacity;\n\npublic:\n    LRUCache(int capacity) {\n        this-&gt;capacity = capacity;\n    }\n\n    int get(int key) {\n        if(cacheMap.find(key) == cacheMap.end())\n            return -1;\n        cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);\n        cacheMap[key] = cacheList.begin();\n        return cacheMap[key]-&gt;value;\n    }\n\n    void put(int key, int value) {\n        if(cacheMap.find(key) == cacheMap.end()) {\n            if(cacheList.size() == capacity) {\n                cacheMap.erase(cacheList.back().key);\n                cacheList.pop_back();\n            }\n            cacheList.push_front(CacheNode(key, value));\n            cacheMap[key] = cacheList.begin();\n        }\n        else {\n            cacheMap[key]-&gt;value = value;\n            cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);\n            cacheMap[key] = cacheList.begin();\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj-&gt;get(key);\n * obj-&gt;put(key,value);\n */\n\n",
        "url": "/2022/06/24/146-LRU-Cache/"
      },
    
      {
        "title": "Sort List",
        "excerpt": "&lt;-M 148&gt; Sort List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if(head == NULL || head-&gt;next == NULL)\n            return head;\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while(fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next !=  NULL ) {\n            fast = fast-&gt;next-&gt;next;\n            slow = slow-&gt;next;\n        }\n\n        fast = slow;\n        slow = slow-&gt;next;\n        fast-&gt;next = NULL;\n\n        ListNode *l1 = sortList(head);\n        ListNode *l2 = sortList(slow);\n        return mergeTwoList(l1, l2);\n    }\nprivate:\n    ListNode *mergeTwoList(ListNode *l1, ListNode *l2) {\n        ListNode check(-1);\n\n        for(ListNode *p = &amp;check; l1 != nullptr || l2 != nullptr; p = p-&gt;next) {\n            int val1 = l1 == nullptr ? INT_MAX : l1-&gt;val;\n            int val2 = l2 == nullptr ? INT_MAX : l2-&gt;val;\n            if(val1 &lt;= val2) {\n                p-&gt;next = l1;\n                l1 = l1-&gt;next;\n            }\n            else {\n                p-&gt;next = l2;\n                l2 = l2-&gt;next;\n            }\n        }\n        return check.next;\n    }\n};\n\n",
        "content": "&lt;-M 148&gt; Sort List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if(head == NULL || head-&gt;next == NULL)\n            return head;\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while(fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next !=  NULL ) {\n            fast = fast-&gt;next-&gt;next;\n            slow = slow-&gt;next;\n        }\n\n        fast = slow;\n        slow = slow-&gt;next;\n        fast-&gt;next = NULL;\n\n        ListNode *l1 = sortList(head);\n        ListNode *l2 = sortList(slow);\n        return mergeTwoList(l1, l2);\n    }\nprivate:\n    ListNode *mergeTwoList(ListNode *l1, ListNode *l2) {\n        ListNode check(-1);\n\n        for(ListNode *p = &amp;check; l1 != nullptr || l2 != nullptr; p = p-&gt;next) {\n            int val1 = l1 == nullptr ? INT_MAX : l1-&gt;val;\n            int val2 = l2 == nullptr ? INT_MAX : l2-&gt;val;\n            if(val1 &lt;= val2) {\n                p-&gt;next = l1;\n                l1 = l1-&gt;next;\n            }\n            else {\n                p-&gt;next = l2;\n                l2 = l2-&gt;next;\n            }\n        }\n        return check.next;\n    }\n};\n\n",
        "url": "/2022/06/24/148-Sort-List/"
      },
    
      {
        "title": "Evaluate Reverse Polish Notation",
        "excerpt": "&lt;-M 150&gt; Evaluate Reverse Polish Notation\n\nclass Solution {\npublic:\n    int evalRPN(vector&lt;string&gt;&amp; tokens) {\n        int n = tokens.size(), first, sec, third;\n        stack&lt;int&gt; stk;\n        for(int i = 0; i &lt; n; i++) {\n            if(tokens[i] == \"+\" || tokens[i] == \"-\" || tokens[i] == \"*\" || tokens[i] == \"/\" ) {\n                sec = stk.top();\n                stk.pop();\n                first = stk.top();\n                stk.pop();\n                switch(tokens[i][0]) {\n                    case '+':\n                        third = first + sec;\n                        break;\n                    case '-':\n                        third = first - sec;\n                        break;\n                    case '*':\n                        third = first * sec;\n                        break;\n                    case '/':\n                        third = first / sec;\n                        break;\n\n                }\n                stk.push(third);\n            }\n            else{\n                stk.push(stoi(tokens[i]));\n            }\n        }\n        return stk.top();\n    }\n};\n\n",
        "content": "&lt;-M 150&gt; Evaluate Reverse Polish Notation\n\nclass Solution {\npublic:\n    int evalRPN(vector&lt;string&gt;&amp; tokens) {\n        int n = tokens.size(), first, sec, third;\n        stack&lt;int&gt; stk;\n        for(int i = 0; i &lt; n; i++) {\n            if(tokens[i] == \"+\" || tokens[i] == \"-\" || tokens[i] == \"*\" || tokens[i] == \"/\" ) {\n                sec = stk.top();\n                stk.pop();\n                first = stk.top();\n                stk.pop();\n                switch(tokens[i][0]) {\n                    case '+':\n                        third = first + sec;\n                        break;\n                    case '-':\n                        third = first - sec;\n                        break;\n                    case '*':\n                        third = first * sec;\n                        break;\n                    case '/':\n                        third = first / sec;\n                        break;\n\n                }\n                stk.push(third);\n            }\n            else{\n                stk.push(stoi(tokens[i]));\n            }\n        }\n        return stk.top();\n    }\n};\n\n",
        "url": "/2022/06/24/150-Evaluate-Reverse-Polish-Notation/"
      },
    
      {
        "title": "3Sum Closest",
        "excerpt": "&lt;-M 16&gt; 3Sum Closest\n\nclass Solution {\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n\n        int ans = INT_MAX, min_diff = INT_MAX;\n        for (int i = 0; i &lt; n; i++) {\n            int target_temp = target - nums[i];\n\n            int j = i + 1, k = nums.size() - 1;\n            while (j &lt; k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                int diff = abs(target_temp - nums[j] - nums[k]);\n                if (nums[j] + nums[k] &lt;= target_temp) {\n                    if (min_diff &gt; diff) {\n                        min_diff = diff;\n                        ans = sum;\n                    }\n                    j++;\n                }\n                else if (nums[j] + nums[k] &gt; target_temp) {\n                    if (min_diff &gt; diff) {\n                        min_diff = diff;\n                        ans = sum;\n                    }\n                    k--;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 16&gt; 3Sum Closest\n\nclass Solution {\npublic:\n    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n\n        int ans = INT_MAX, min_diff = INT_MAX;\n        for (int i = 0; i &lt; n; i++) {\n            int target_temp = target - nums[i];\n\n            int j = i + 1, k = nums.size() - 1;\n            while (j &lt; k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                int diff = abs(target_temp - nums[j] - nums[k]);\n                if (nums[j] + nums[k] &lt;= target_temp) {\n                    if (min_diff &gt; diff) {\n                        min_diff = diff;\n                        ans = sum;\n                    }\n                    j++;\n                }\n                else if (nums[j] + nums[k] &gt; target_temp) {\n                    if (min_diff &gt; diff) {\n                        min_diff = diff;\n                        ans = sum;\n                    }\n                    k--;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/16-3Sum-Closest/"
      },
    
      {
        "title": "Letter Combinations of a Phone Number",
        "excerpt": "&lt;-M 17&gt; Letter Combinations of a Phone Number\n\nclass Solution {\npublic:\n    void getLetterCombinations(string digits, string c, vector&lt;string&gt;&amp; pad, vector&lt;string&gt;&amp; res) {\n        for(auto i : pad[digits[0] - '0']) {\n            string c2 = c + i;\n            string digits2 = digits;\n            digits2.erase(0, 1);\n            if(!digits2.size())\n                res.push_back(c2);\n            else\n                getLetterCombinations(digits2, c2, pad, res);\n        }\n    }\n\n    vector&lt;string&gt; letterCombinations(string digits) {\n        if(!digits.size()) return {};\n        vector&lt;string&gt; res;\n        vector&lt;string&gt; pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        string c = \"\";\n        getLetterCombinations(digits, c, pad, res);\n        return res;\n    }\n};\n\n",
        "content": "&lt;-M 17&gt; Letter Combinations of a Phone Number\n\nclass Solution {\npublic:\n    void getLetterCombinations(string digits, string c, vector&lt;string&gt;&amp; pad, vector&lt;string&gt;&amp; res) {\n        for(auto i : pad[digits[0] - '0']) {\n            string c2 = c + i;\n            string digits2 = digits;\n            digits2.erase(0, 1);\n            if(!digits2.size())\n                res.push_back(c2);\n            else\n                getLetterCombinations(digits2, c2, pad, res);\n        }\n    }\n\n    vector&lt;string&gt; letterCombinations(string digits) {\n        if(!digits.size()) return {};\n        vector&lt;string&gt; res;\n        vector&lt;string&gt; pad = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        string c = \"\";\n        getLetterCombinations(digits, c, pad, res);\n        return res;\n    }\n};\n\n",
        "url": "/2022/06/24/17-Letter-Combinations-of-a-Phone-Number/"
      },
    
      {
        "title": "4Sum",
        "excerpt": "&lt;-M 18&gt; 4Sum\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n        set&lt;vector&lt;int&gt;&gt;myList;\n        sort(nums.begin(), nums.end());\n        if(nums.size() &lt; 4){\n            return vector&lt;vector&lt;int&gt;&gt;();\n        }\n\n        for(int i = 0; i &lt; nums.size(); i++){\n            for(int j = i + 1; j &lt; nums.size(); j++){\n                int x = j + 1, y = nums.size() - 1;\n                long long findSum = target - (long)nums[i] - (long)nums[j];\n\n                while(x &lt; y){\n                    long long sum = nums[x] + nums[y];\n                    if(sum &gt; findSum)\n                        y--;\n                    else if(sum &lt; findSum)\n                        x++;\n                    else{\n                        myList.insert({nums[i], nums[j], nums[x], nums[y]});\n                        x++;\n                        y--;\n                    }\n                }\n            }\n        }\n\n    return vector&lt;vector&lt;int&gt;&gt; (myList.begin(), myList.end());\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n        vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n        int i,j , left, right, n = nums.size();\n        vector&lt;vector&lt;int&gt;&gt; result;\n        if(n&lt;4 || nums.empty())\n            return result;\n        sort(nums.begin(),nums.end());\n        for(i = 0;i &lt; n - 3; i++) {\n            long long int target_3 = target - nums[i];\n            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1])\n                continue;\n            int presentI, presentJ;\n            for(j = i + 1; j &lt; n - 2; j++) {\n                long long int target_2 = target_3  - nums[j];\n                if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])\n                    continue;\n                if(nums[j + 1] + nums[j + 2] &gt; target_2)\n                    break;\n                if(nums[n - 2] + nums[n - 1] &lt; target_2)\n                    continue;\n                left = j + 1;\n                right = n - 1;\n                while(left &lt; right) {\n                    int two_sum = nums[left] + nums[right];\n                    if(two_sum &lt; target_2)\n                        left++;\n                    else if(two_sum &gt; target_2)\n                        right--;\n                    else {\n                        result.push_back(vector&lt;int&gt;{nums[i], nums[j], nums[left], nums[right]});\n                        int presentLeft = nums[left], presentRight = nums[right];\n                        presentI=nums[i];\n                        presentJ=nums[j];\n                        do {\n                            left++;\n                        } while(nums[left] == presentLeft &amp;&amp; left &lt; right);\n                        do {\n                            right--;\n                        } while(nums[right] == presentRight &amp;&amp; left &lt; right);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n};\n\n",
        "content": "&lt;-M 18&gt; 4Sum\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n        set&lt;vector&lt;int&gt;&gt;myList;\n        sort(nums.begin(), nums.end());\n        if(nums.size() &lt; 4){\n            return vector&lt;vector&lt;int&gt;&gt;();\n        }\n\n        for(int i = 0; i &lt; nums.size(); i++){\n            for(int j = i + 1; j &lt; nums.size(); j++){\n                int x = j + 1, y = nums.size() - 1;\n                long long findSum = target - (long)nums[i] - (long)nums[j];\n\n                while(x &lt; y){\n                    long long sum = nums[x] + nums[y];\n                    if(sum &gt; findSum)\n                        y--;\n                    else if(sum &lt; findSum)\n                        x++;\n                    else{\n                        myList.insert({nums[i], nums[j], nums[x], nums[y]});\n                        x++;\n                        y--;\n                    }\n                }\n            }\n        }\n\n    return vector&lt;vector&lt;int&gt;&gt; (myList.begin(), myList.end());\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n        vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {\n        int i,j , left, right, n = nums.size();\n        vector&lt;vector&lt;int&gt;&gt; result;\n        if(n&lt;4 || nums.empty())\n            return result;\n        sort(nums.begin(),nums.end());\n        for(i = 0;i &lt; n - 3; i++) {\n            long long int target_3 = target - nums[i];\n            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1])\n                continue;\n            int presentI, presentJ;\n            for(j = i + 1; j &lt; n - 2; j++) {\n                long long int target_2 = target_3  - nums[j];\n                if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])\n                    continue;\n                if(nums[j + 1] + nums[j + 2] &gt; target_2)\n                    break;\n                if(nums[n - 2] + nums[n - 1] &lt; target_2)\n                    continue;\n                left = j + 1;\n                right = n - 1;\n                while(left &lt; right) {\n                    int two_sum = nums[left] + nums[right];\n                    if(two_sum &lt; target_2)\n                        left++;\n                    else if(two_sum &gt; target_2)\n                        right--;\n                    else {\n                        result.push_back(vector&lt;int&gt;{nums[i], nums[j], nums[left], nums[right]});\n                        int presentLeft = nums[left], presentRight = nums[right];\n                        presentI=nums[i];\n                        presentJ=nums[j];\n                        do {\n                            left++;\n                        } while(nums[left] == presentLeft &amp;&amp; left &lt; right);\n                        do {\n                            right--;\n                        } while(nums[right] == presentRight &amp;&amp; left &lt; right);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n};\n\n",
        "url": "/2022/06/24/18-4Sum/"
      },
    
      {
        "title": "Remove Nth Node From End of List",
        "excerpt": "&lt;-M 19&gt; Remove Nth Node From End of List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode temp{-1, head};\n        ListNode *p = &amp;temp;\n        ListNode *q = &amp;temp;\n\n        for(int i = 0; i &lt; n; i++)\n            q = q-&gt;next;\n\n        while(q-&gt;next) {\n            p = p-&gt;next;\n            q = q-&gt;next;\n        }\n\n        ListNode *check = p-&gt;next;\n        p-&gt;next = p-&gt;next-&gt;next;\n        delete check;\n\n        return temp.next;\n    }\n};\n\n\n",
        "content": "&lt;-M 19&gt; Remove Nth Node From End of List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode temp{-1, head};\n        ListNode *p = &amp;temp;\n        ListNode *q = &amp;temp;\n\n        for(int i = 0; i &lt; n; i++)\n            q = q-&gt;next;\n\n        while(q-&gt;next) {\n            p = p-&gt;next;\n            q = q-&gt;next;\n        }\n\n        ListNode *check = p-&gt;next;\n        p-&gt;next = p-&gt;next-&gt;next;\n        delete check;\n\n        return temp.next;\n    }\n};\n\n\n",
        "url": "/2022/06/24/19-Remove-Nth-Node-From-End-of-List/"
      },
    
      {
        "title": "Generate Parentheses",
        "excerpt": "&lt;-M 22&gt; Generate Parentheses\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) {\n        if(n == 0)\n            return vector&lt;string&gt;(1, \"\");\n        if(n == 1)\n            return vector&lt;string&gt;(1, \"()\");\n        vector&lt;string&gt; result;\n\n        for(int i = 0; i &lt; n; i++)\n            for(auto inner : generateParenthesis(i))\n                for(auto outer : generateParenthesis(n - 1 - i))\n                    result.push_back(\"(\" + inner + \")\" + outer);\n\n        return result;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void bt(int n, int open, int close, string&amp; comb, vector&lt;string&gt;&amp; ans) {\n        if (comb.size() == 2 * n ) {\n            ans.push_back(comb);\n            return;\n        }\n\n        if (open &lt; n) {\n            comb.push_back('(');\n            bt(n, open + 1, close, comb, ans);\n            comb.pop_back();\n        }\n\n        if (close &lt; open) {\n            comb.push_back(')');\n            bt(n, open, close+1, comb, ans);\n            comb.pop_back();\n        }\n    }\n\n    vector&lt;string&gt; generateParenthesis(int n) {\n        string comb;\n        vector&lt;string&gt; ans;\n        bt(n, 0, 0, comb, ans);\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 22&gt; Generate Parentheses\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) {\n        if(n == 0)\n            return vector&lt;string&gt;(1, \"\");\n        if(n == 1)\n            return vector&lt;string&gt;(1, \"()\");\n        vector&lt;string&gt; result;\n\n        for(int i = 0; i &lt; n; i++)\n            for(auto inner : generateParenthesis(i))\n                for(auto outer : generateParenthesis(n - 1 - i))\n                    result.push_back(\"(\" + inner + \")\" + outer);\n\n        return result;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void bt(int n, int open, int close, string&amp; comb, vector&lt;string&gt;&amp; ans) {\n        if (comb.size() == 2 * n ) {\n            ans.push_back(comb);\n            return;\n        }\n\n        if (open &lt; n) {\n            comb.push_back('(');\n            bt(n, open + 1, close, comb, ans);\n            comb.pop_back();\n        }\n\n        if (close &lt; open) {\n            comb.push_back(')');\n            bt(n, open, close+1, comb, ans);\n            comb.pop_back();\n        }\n    }\n\n    vector&lt;string&gt; generateParenthesis(int n) {\n        string comb;\n        vector&lt;string&gt; ans;\n        bt(n, 0, 0, comb, ans);\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/22-Generate-Parentheses/"
      },
    
      {
        "title": "Merge k Sorted Lists",
        "excerpt": "&lt;-M 23&gt; Merge k Sorted Lists\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        if(lists.size() == 0)\n            return nullptr;\n\n        ListNode *p = lists[0];\n        for(int i = 1; i &lt; lists.size(); i++)\n            p = mergeTwoLists(p, lists[i]);\n        return p;\n    }\nprivate:\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n        ListNode head(-1);\n        for(ListNode *p = &amp;head; l1 != nullptr || l2 != nullptr; p = p-&gt;next) {\n            int val1 = l1 == nullptr ? INT_MAX : l1-&gt;val;\n            int val2 = l2 == nullptr ? INT_MAX : l2-&gt;val;\n\n            if(val1 &lt;= val2) {\n                p-&gt;next = l1;\n                l1 = l1-&gt;next;\n            }\n            else {\n                p-&gt;next = l2;\n                l2 = l2-&gt;next;\n            }\n        }\n        return head.next;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; list) {\n        if(list.size() == 0)\n            return nullptr;\n        multimap&lt;int,ListNode*&gt; m;\n\n        for(int i = 0; i &lt; list.size(); i++) {\n            ListNode* temp = list[i];\n            while(temp != nullptr){\n                m.insert(make_pair(temp-&gt;val, temp));\n                temp = temp-&gt;next;\n            }\n        }\n        auto it = m.begin();\n        ListNode* head  = new ListNode(-1);\n        ListNode* temp = head;\n        for(auto it = m.begin(); it != m.end(); it++) {\n            temp-&gt;next = it-&gt;second;\n            temp = temp-&gt;next;\n        }\n\n        return head-&gt;next;\n    }\n};\n\n",
        "content": "&lt;-M 23&gt; Merge k Sorted Lists\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        if(lists.size() == 0)\n            return nullptr;\n\n        ListNode *p = lists[0];\n        for(int i = 1; i &lt; lists.size(); i++)\n            p = mergeTwoLists(p, lists[i]);\n        return p;\n    }\nprivate:\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n        ListNode head(-1);\n        for(ListNode *p = &amp;head; l1 != nullptr || l2 != nullptr; p = p-&gt;next) {\n            int val1 = l1 == nullptr ? INT_MAX : l1-&gt;val;\n            int val2 = l2 == nullptr ? INT_MAX : l2-&gt;val;\n\n            if(val1 &lt;= val2) {\n                p-&gt;next = l1;\n                l1 = l1-&gt;next;\n            }\n            else {\n                p-&gt;next = l2;\n                l2 = l2-&gt;next;\n            }\n        }\n        return head.next;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; list) {\n        if(list.size() == 0)\n            return nullptr;\n        multimap&lt;int,ListNode*&gt; m;\n\n        for(int i = 0; i &lt; list.size(); i++) {\n            ListNode* temp = list[i];\n            while(temp != nullptr){\n                m.insert(make_pair(temp-&gt;val, temp));\n                temp = temp-&gt;next;\n            }\n        }\n        auto it = m.begin();\n        ListNode* head  = new ListNode(-1);\n        ListNode* temp = head;\n        for(auto it = m.begin(); it != m.end(); it++) {\n            temp-&gt;next = it-&gt;second;\n            temp = temp-&gt;next;\n        }\n\n        return head-&gt;next;\n    }\n};\n\n",
        "url": "/2022/06/24/23-Merge-k-Sorted-Lists/"
      },
    
      {
        "title": "Swap Nodes in Pairs",
        "excerpt": "&lt;-M 24&gt; Swap Nodes in Pairs\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head-&gt;next == nullptr)\n            return head;\n        ListNode temp(-1);\n        temp.next = head;\n\n        for(ListNode *prev = &amp;temp, *cur = prev-&gt;next, *next = cur-&gt;next;\n           next;\n           prev = cur, cur = cur-&gt;next, next = cur ? cur-&gt;next : nullptr) {\n            prev-&gt;next = next;\n            cur-&gt;next = next-&gt;next;\n            next-&gt;next = cur;\n        }\n        return temp.next;\n    }\n};\n\n",
        "content": "&lt;-M 24&gt; Swap Nodes in Pairs\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head-&gt;next == nullptr)\n            return head;\n        ListNode temp(-1);\n        temp.next = head;\n\n        for(ListNode *prev = &amp;temp, *cur = prev-&gt;next, *next = cur-&gt;next;\n           next;\n           prev = cur, cur = cur-&gt;next, next = cur ? cur-&gt;next : nullptr) {\n            prev-&gt;next = next;\n            cur-&gt;next = next-&gt;next;\n            next-&gt;next = cur;\n        }\n        return temp.next;\n    }\n};\n\n",
        "url": "/2022/06/24/24-Swap-Nodes-in-Pairs/"
      },
    
      {
        "title": "Reverse Nodes in k-Group",
        "excerpt": "&lt;-H 25&gt; Reverse Nodes in k-Group\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(head == nullptr || head-&gt;next == nullptr || k &lt; 2)\n            return head;\n        ListNode temp(-1);\n        temp.next = head;\n        for(ListNode *prev = &amp;temp, *end = head;\n           end;\n           end = prev-&gt;next) {\n            for(int i = 1; i &lt; k &amp;&amp; end; i++)\n                end = end-&gt;next;\n            if(end == nullptr)\n                break;\n\n            prev = reverse(prev, prev-&gt;next, end);\n        }\n        return temp.next;\n    }\nprivate:\n    ListNode *reverse(ListNode *prev, ListNode *begin, ListNode *end) {\n        ListNode *end_next = end-&gt;next;\n        for(ListNode *p = begin, *cur = p-&gt;next, *next = cur-&gt;next;\n           cur != end_next;\n           p = cur, cur = next, next = next ? next-&gt;next : nullptr) {\n            cur-&gt;next = p;\n        }\n        begin-&gt;next = end_next;\n        prev-&gt;next = end;\n        return begin;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n       if(head == NULL)\n           return head;\n\n        ListNode* temp = head;\n        for(int i = 0; i &lt; k; i++) {\n            if(temp == NULL)\n                return head;\n            temp = temp-&gt;next;\n        }\n\n       ListNode *prev = NULL;\n       ListNode *curr = head;\n       ListNode *next;\n       int count = 0;\n\n       while(curr != NULL &amp;&amp; count &lt; k) {\n           next = curr-&gt;next;\n           curr-&gt;next = prev;\n           prev = curr;\n           curr = next;\n           count++;\n       }\n       if(next != NULL) {\n           head-&gt;next = reverseKGroup(next,k);\n       }\n       return prev;\n    }\n};\n\n",
        "content": "&lt;-H 25&gt; Reverse Nodes in k-Group\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(head == nullptr || head-&gt;next == nullptr || k &lt; 2)\n            return head;\n        ListNode temp(-1);\n        temp.next = head;\n        for(ListNode *prev = &amp;temp, *end = head;\n           end;\n           end = prev-&gt;next) {\n            for(int i = 1; i &lt; k &amp;&amp; end; i++)\n                end = end-&gt;next;\n            if(end == nullptr)\n                break;\n\n            prev = reverse(prev, prev-&gt;next, end);\n        }\n        return temp.next;\n    }\nprivate:\n    ListNode *reverse(ListNode *prev, ListNode *begin, ListNode *end) {\n        ListNode *end_next = end-&gt;next;\n        for(ListNode *p = begin, *cur = p-&gt;next, *next = cur-&gt;next;\n           cur != end_next;\n           p = cur, cur = next, next = next ? next-&gt;next : nullptr) {\n            cur-&gt;next = p;\n        }\n        begin-&gt;next = end_next;\n        prev-&gt;next = end;\n        return begin;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n\n       if(head == NULL)\n           return head;\n\n        ListNode* temp = head;\n        for(int i = 0; i &lt; k; i++) {\n            if(temp == NULL)\n                return head;\n            temp = temp-&gt;next;\n        }\n\n       ListNode *prev = NULL;\n       ListNode *curr = head;\n       ListNode *next;\n       int count = 0;\n\n       while(curr != NULL &amp;&amp; count &lt; k) {\n           next = curr-&gt;next;\n           curr-&gt;next = prev;\n           prev = curr;\n           curr = next;\n           count++;\n       }\n       if(next != NULL) {\n           head-&gt;next = reverseKGroup(next,k);\n       }\n       return prev;\n    }\n};\n\n",
        "url": "/2022/06/24/25-Reverse-Nodes-in-k-Group/"
      },
    
      {
        "title": "Next Permutation",
        "excerpt": "&lt;-M 31&gt; Next Permutation\n\n// Method 1\nclass Solution {\npublic:\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size(), k, l;\n    \tfor (k = n - 2; k &gt;= 0; k--) {\n            if (nums[k] &lt; nums[k + 1]) {\n                break;\n            }\n        }\n    \tif (k &lt; 0) {\n    \t    reverse(nums.begin(), nums.end());\n    \t} else {\n    \t    for (l = n - 1; l &gt; k; l--) {\n                if (nums[l] &gt; nums[k]) {\n                    break;\n                }\n            }\n    \t    swap(nums[k], nums[l]);\n    \t    reverse(nums.begin() + k + 1, nums.end());\n        }\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size() - 1;\n        int infpt = 0;\n        for(int i = n; i &gt; 0; i--) {\n            if(nums[i] &gt; nums[i - 1]) {\n                infpt = i;\n                break;\n            }\n        }\n        if(infpt == 0) {\n            sort(nums.begin(), nums.end());\n        }\n        else {\n            int toswap = nums[infpt - 1];\n            int min = INT_MAX;\n            for(int j = infpt; j &lt;= n; j++) {\n                if(nums[j] - toswap &gt; 0 and nums[j] - toswap &lt; min) {\n                    int temp = nums[j];\n                    nums[j] =  nums[infpt - 1];\n                    nums[infpt - 1] = temp;\n                }\n            }\n            sort(nums.begin()+infpt,nums.end());\n        }\n    }\n};\n\n",
        "content": "&lt;-M 31&gt; Next Permutation\n\n// Method 1\nclass Solution {\npublic:\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size(), k, l;\n    \tfor (k = n - 2; k &gt;= 0; k--) {\n            if (nums[k] &lt; nums[k + 1]) {\n                break;\n            }\n        }\n    \tif (k &lt; 0) {\n    \t    reverse(nums.begin(), nums.end());\n    \t} else {\n    \t    for (l = n - 1; l &gt; k; l--) {\n                if (nums[l] &gt; nums[k]) {\n                    break;\n                }\n            }\n    \t    swap(nums[k], nums[l]);\n    \t    reverse(nums.begin() + k + 1, nums.end());\n        }\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void nextPermutation(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size() - 1;\n        int infpt = 0;\n        for(int i = n; i &gt; 0; i--) {\n            if(nums[i] &gt; nums[i - 1]) {\n                infpt = i;\n                break;\n            }\n        }\n        if(infpt == 0) {\n            sort(nums.begin(), nums.end());\n        }\n        else {\n            int toswap = nums[infpt - 1];\n            int min = INT_MAX;\n            for(int j = infpt; j &lt;= n; j++) {\n                if(nums[j] - toswap &gt; 0 and nums[j] - toswap &lt; min) {\n                    int temp = nums[j];\n                    nums[j] =  nums[infpt - 1];\n                    nums[infpt - 1] = temp;\n                }\n            }\n            sort(nums.begin()+infpt,nums.end());\n        }\n    }\n};\n\n",
        "url": "/2022/06/24/31-Next-Permutation/"
      },
    
      {
        "title": "Longest Valid Parentheses",
        "excerpt": "&lt;-H 32&gt; Longest Valid Parentheses\n\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.length();\n        stack&lt;int&gt; st;\n        st.push(-1);\n        int maxans = 0;\n        for(int i = 0; i &lt; n; i++) {\n            if(s[i] == '(')\n                st.push(i);\n            else {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    maxans = max(maxans, i - st.top());\n            }\n        }\n        return maxans;\n\n    }\n};\n\n",
        "content": "&lt;-H 32&gt; Longest Valid Parentheses\n\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.length();\n        stack&lt;int&gt; st;\n        st.push(-1);\n        int maxans = 0;\n        for(int i = 0; i &lt; n; i++) {\n            if(s[i] == '(')\n                st.push(i);\n            else {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    maxans = max(maxans, i - st.top());\n            }\n        }\n        return maxans;\n\n    }\n};\n\n",
        "url": "/2022/06/24/32-Longest-Valid-Parentheses/"
      },
    
      {
        "title": "Search in Rotated Sorted Array",
        "excerpt": "&lt;-M 33&gt; Search in Rotated Sorted Array\n\nclass Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        int first = 0, last = nums.size();\n          while (first != last) {\n            const int mid = first  + (last - first) / 2;\n            if (nums[mid] == target)\n                return mid;\n            if (nums[first] &lt;= nums[mid]) {\n                if (nums[first] &lt;= target &amp;&amp; target &lt; nums[mid])\n                    last = mid;\n                else\n                    first = mid + 1;\n            } else {\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1])\n                    first = mid + 1;\n                else\n                    last = mid;\n            }\n        }\n        return -1;\n    }\n};\n\n",
        "content": "&lt;-M 33&gt; Search in Rotated Sorted Array\n\nclass Solution {\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        int first = 0, last = nums.size();\n          while (first != last) {\n            const int mid = first  + (last - first) / 2;\n            if (nums[mid] == target)\n                return mid;\n            if (nums[first] &lt;= nums[mid]) {\n                if (nums[first] &lt;= target &amp;&amp; target &lt; nums[mid])\n                    last = mid;\n                else\n                    first = mid + 1;\n            } else {\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1])\n                    first = mid + 1;\n                else\n                    last = mid;\n            }\n        }\n        return -1;\n    }\n};\n\n",
        "url": "/2022/06/24/33-Search-in-Rotated-Sorted-Array/"
      },
    
      {
        "title": "Valid Sudoku",
        "excerpt": "&lt;-M 36&gt; Valid Sudoku\n\n// Method 1\nclass Solution {\npublic:\n    bool used[9];\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\n        for(int i = 0; i &lt; 9; i++) {\n            fill(used, used + 9, false);\n            for(int j = 0; j &lt; 9; j++)\n                if(!check(board[i][j]))\n                    return false;\n\n            fill(used, used + 9, false);\n            for(int j = 0; j &lt; 9; j++)\n                if(!check(board[j][i]))\n                    return false;\n        }\n\n        for(int r = 0; r &lt; 3; r++) {\n            for(int c = 0; c &lt; 3; c++) {\n                fill(used, used + 9, false);\n                for(int i = r * 3; i &lt; r * 3 + 3; i++)\n                    for(int j = c * 3; j &lt; c * 3 + 3; j++)\n                        if(!check(board[i][j]))\n                            return false;\n            }\n        }\n        return true;\n    }\nprivate:\n    bool check(char c) {\n        if(c == '.')\n            return true;\n        if(used[c - '1'])\n            return false;\n\n        return used[c -'1'] = true;;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        bool row[9][9] = {false};\n        bool col[9][9] = {false};\n        bool box[9][9] = {false};\n        for(int i = 0; i &lt; 9; i++) {\n            for(int j = 0; j &lt; 9; j++) {\n                if(board[i][j] != '.') {\n                    int num = board[i][j] - '1';\n                    int k = i / 3 * 3 + j / 3;\n                    if(row[i][num] || col[j][num] || box[k][num])\n                        return false;\n                    row[i][num] = col[j][num] = box[k][num] = true;\n                }\n            }\n        }\n        return true;\n    }\n};\n\n// Method 3\nclass Solution {\npublic:\n    bool safe(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int n) {\n        int N = board.size();\n        for(int k = 0; k &lt; N; k++){\n            if(board[i][k] == n+'0' || board[k][j] == n + '0') {\n                return false;\n            }\n        }\n        int s = sqrt(N);\n        int x = i - i % s;\n        int y = j - j % s;\n        for(int p = 0; p &lt; s; p++) {\n            for(int q = 0; q &lt; s; q++) {\n                if(board[x + p][y + q] == n + '0') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    bool solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        int N = board.size();\n        int i, j, n;\n        for(i = 0; i &lt; N; i++) {\n            for(j = 0; j &lt; N; j++) {\n                if(board[i][j] != '.') {\n                    n=board[i][j] - '0';\n                    board[i][j] = '.';\n                    if(!safe(board, i, j, n)) {\n                        return false;\n                    }\n                    board[i][j] = n + '0';\n                }\n            }\n        }\n        return true;\n    }\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        return solve(board);\n    }\n};\n\n",
        "content": "&lt;-M 36&gt; Valid Sudoku\n\n// Method 1\nclass Solution {\npublic:\n    bool used[9];\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\n        for(int i = 0; i &lt; 9; i++) {\n            fill(used, used + 9, false);\n            for(int j = 0; j &lt; 9; j++)\n                if(!check(board[i][j]))\n                    return false;\n\n            fill(used, used + 9, false);\n            for(int j = 0; j &lt; 9; j++)\n                if(!check(board[j][i]))\n                    return false;\n        }\n\n        for(int r = 0; r &lt; 3; r++) {\n            for(int c = 0; c &lt; 3; c++) {\n                fill(used, used + 9, false);\n                for(int i = r * 3; i &lt; r * 3 + 3; i++)\n                    for(int j = c * 3; j &lt; c * 3 + 3; j++)\n                        if(!check(board[i][j]))\n                            return false;\n            }\n        }\n        return true;\n    }\nprivate:\n    bool check(char c) {\n        if(c == '.')\n            return true;\n        if(used[c - '1'])\n            return false;\n\n        return used[c -'1'] = true;;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        bool row[9][9] = {false};\n        bool col[9][9] = {false};\n        bool box[9][9] = {false};\n        for(int i = 0; i &lt; 9; i++) {\n            for(int j = 0; j &lt; 9; j++) {\n                if(board[i][j] != '.') {\n                    int num = board[i][j] - '1';\n                    int k = i / 3 * 3 + j / 3;\n                    if(row[i][num] || col[j][num] || box[k][num])\n                        return false;\n                    row[i][num] = col[j][num] = box[k][num] = true;\n                }\n            }\n        }\n        return true;\n    }\n};\n\n// Method 3\nclass Solution {\npublic:\n    bool safe(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int n) {\n        int N = board.size();\n        for(int k = 0; k &lt; N; k++){\n            if(board[i][k] == n+'0' || board[k][j] == n + '0') {\n                return false;\n            }\n        }\n        int s = sqrt(N);\n        int x = i - i % s;\n        int y = j - j % s;\n        for(int p = 0; p &lt; s; p++) {\n            for(int q = 0; q &lt; s; q++) {\n                if(board[x + p][y + q] == n + '0') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    bool solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        int N = board.size();\n        int i, j, n;\n        for(i = 0; i &lt; N; i++) {\n            for(j = 0; j &lt; N; j++) {\n                if(board[i][j] != '.') {\n                    n=board[i][j] - '0';\n                    board[i][j] = '.';\n                    if(!safe(board, i, j, n)) {\n                        return false;\n                    }\n                    board[i][j] = n + '0';\n                }\n            }\n        }\n        return true;\n    }\n    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        return solve(board);\n    }\n};\n\n",
        "url": "/2022/06/24/36-Valid-Sudoku/"
      },
    
      {
        "title": "Sudoku Solver",
        "excerpt": "&lt;-H 37&gt; Sudoku Solver\n\nclass Solution {\npublic:\n\tvoid solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\t\tsolve_suduko(board);\n\t}\n\n\tbool solve_suduko(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\t\tint n = board.size();\n\t\tint m = board[0].size();\n\t\tfor(int i = 0;i &lt; n; i++) {\n\t\t\tfor(int j = 0; j &lt; m; j++) {\n\t\t\t\tif(board[i][j] == '.') {\n\t\t\t\t\tfor(char ch = '1'; ch &lt;= '9'; ch++) {\n\t\t\t\t\t\tif(isvalid(board, ch, i, j)) {\n\t\t\t\t\t\t\tboard[i][j] = ch;\n\t\t\t\t\t\t\tif(solve_suduko(board))\n                                return true;\n\t\t\t\t\t\t\telse board[i][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isvalid(vector&lt;vector&lt;char&gt;&gt;&amp; board,char ch,int row,int col) {\n\t\tfor(int i = 0; i &lt; 9; i++) {\n\t\t\tif(board[row][i] == ch)\n                return false;\n\t\t\tif(board[i][col] == ch)\n                return false;\n\t\t\tif(board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch)\n                return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\n",
        "content": "&lt;-H 37&gt; Sudoku Solver\n\nclass Solution {\npublic:\n\tvoid solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\t\tsolve_suduko(board);\n\t}\n\n\tbool solve_suduko(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\t\tint n = board.size();\n\t\tint m = board[0].size();\n\t\tfor(int i = 0;i &lt; n; i++) {\n\t\t\tfor(int j = 0; j &lt; m; j++) {\n\t\t\t\tif(board[i][j] == '.') {\n\t\t\t\t\tfor(char ch = '1'; ch &lt;= '9'; ch++) {\n\t\t\t\t\t\tif(isvalid(board, ch, i, j)) {\n\t\t\t\t\t\t\tboard[i][j] = ch;\n\t\t\t\t\t\t\tif(solve_suduko(board))\n                                return true;\n\t\t\t\t\t\t\telse board[i][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool isvalid(vector&lt;vector&lt;char&gt;&gt;&amp; board,char ch,int row,int col) {\n\t\tfor(int i = 0; i &lt; 9; i++) {\n\t\t\tif(board[row][i] == ch)\n                return false;\n\t\t\tif(board[i][col] == ch)\n                return false;\n\t\t\tif(board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch)\n                return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\n",
        "url": "/2022/06/24/37-Sudoku-Solver/"
      },
    
      {
        "title": "Count and Say",
        "excerpt": "&lt;-M 38&gt; Count and Say\n\n// Method 1\nclass Solution {\npublic:\n\n    string countans(string curr, int on, int n) {\n        if (on == n)\n            return curr;\n        int l = curr.length();\n        int count = 1;\n        string retstr = \"\";\n        for (int i = 1; i &lt;= l; i++) {\n            while (i &lt; l &amp;&amp; curr[i] == curr[i - 1]) {\n                count++;\n                i++;\n            }\n            retstr += 48 + count;\n            retstr += curr[i - 1];\n            count = 1;\n        }\n        return countans(retstr, on + 1, n);\n    }\n\n    string countAndSay(int n) {\n        return countans (\"1\", 1, n);\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 0)\n            return \"\";\n        else if(n == 1)\n            return \"1\";\n        else if (n == 2)\n            return \"11\";\n        string ans = \"11\";\n        int counter = 0;\n\n        while(n &gt;= 3) {\n            string temp;\n\n            for(int i = 0; i != ans.size();) {\n                char curr = ans[i];\n\t\t\t\twhile (i &lt; ans.size() &amp;&amp; ans[i] == curr) {\n\t\t\t\t\ti++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\ttemp.append(to_string(counter) + curr);\n\t\t\t\tcounter = 0;\n\t\t\t}\n\t\t\tans = temp;\n            n--;\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 38&gt; Count and Say\n\n// Method 1\nclass Solution {\npublic:\n\n    string countans(string curr, int on, int n) {\n        if (on == n)\n            return curr;\n        int l = curr.length();\n        int count = 1;\n        string retstr = \"\";\n        for (int i = 1; i &lt;= l; i++) {\n            while (i &lt; l &amp;&amp; curr[i] == curr[i - 1]) {\n                count++;\n                i++;\n            }\n            retstr += 48 + count;\n            retstr += curr[i - 1];\n            count = 1;\n        }\n        return countans(retstr, on + 1, n);\n    }\n\n    string countAndSay(int n) {\n        return countans (\"1\", 1, n);\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 0)\n            return \"\";\n        else if(n == 1)\n            return \"1\";\n        else if (n == 2)\n            return \"11\";\n        string ans = \"11\";\n        int counter = 0;\n\n        while(n &gt;= 3) {\n            string temp;\n\n            for(int i = 0; i != ans.size();) {\n                char curr = ans[i];\n\t\t\t\twhile (i &lt; ans.size() &amp;&amp; ans[i] == curr) {\n\t\t\t\t\ti++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\ttemp.append(to_string(counter) + curr);\n\t\t\t\tcounter = 0;\n\t\t\t}\n\t\t\tans = temp;\n            n--;\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/38-Count-and-Say/"
      },
    
      {
        "title": "Median of Two Sorted Arrays",
        "excerpt": "&lt;-H 4&gt; Median of Two Sorted Arrays\n\n// Method 1\nclass Solution {\npublic:\ndouble findMedianSortedArrays(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {\n    int n = A.size();\n    int m = B.size();\n    if (n &gt; m)\n        return findMedianSortedArrays(B, A); // Swapping to make A smaller\n\n    int start = 0;\n    int end = n;\n    int realmidinmergedarray = (n + m + 1) / 2;\n\n    while (start &lt;= end) {\n        int mid = (start + end) / 2;\n        int leftAsize = mid;\n        int leftBsize = realmidinmergedarray - mid;\n        int leftA\n            = (leftAsize &gt; 0)\n                  ? A[leftAsize - 1]\n                  : INT_MIN;\n        int leftB\n            = (leftBsize &gt; 0) ? B[leftBsize - 1] : INT_MIN;\n        int rightA\n            = (leftAsize &lt; n) ? A[leftAsize] : INT_MAX;\n        int rightB\n            = (leftBsize &lt; m) ? B[leftBsize] : INT_MAX;\n        if (leftA &lt;= rightB and leftB &lt;= rightA) {\n            if ((m + n) % 2 == 0)\n                return (max(leftA, leftB)\n                        + min(rightA, rightB))\n                       / 2.0;\n            return max(leftA, leftB);\n        }\n        else if (leftA &gt; rightB) {\n            end = mid - 1;\n        }\n        else\n            start = mid + 1;\n    }\n    return 0.0;\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        vector&lt;int&gt; Temp;\n        Temp.reserve(nums1.size() + nums1.size() );\n        Temp.insert(Temp.end(), nums1.begin(), nums1.end());\n        Temp.insert(Temp.end(), nums2.begin(), nums2.end());\n\t\tsort(Temp.begin(), Temp.end());\n\t\tif (Temp.size() % 2 == 0)\n\t\t\treturn (Temp[Temp.size() / 2 - 1] + Temp[Temp.size() / 2]) / 2.0;\n\t\telse\n\t\t\treturn  Temp[Temp.size() / 2];\n    }\n};\n\n",
        "content": "&lt;-H 4&gt; Median of Two Sorted Arrays\n\n// Method 1\nclass Solution {\npublic:\ndouble findMedianSortedArrays(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {\n    int n = A.size();\n    int m = B.size();\n    if (n &gt; m)\n        return findMedianSortedArrays(B, A); // Swapping to make A smaller\n\n    int start = 0;\n    int end = n;\n    int realmidinmergedarray = (n + m + 1) / 2;\n\n    while (start &lt;= end) {\n        int mid = (start + end) / 2;\n        int leftAsize = mid;\n        int leftBsize = realmidinmergedarray - mid;\n        int leftA\n            = (leftAsize &gt; 0)\n                  ? A[leftAsize - 1]\n                  : INT_MIN;\n        int leftB\n            = (leftBsize &gt; 0) ? B[leftBsize - 1] : INT_MIN;\n        int rightA\n            = (leftAsize &lt; n) ? A[leftAsize] : INT_MAX;\n        int rightB\n            = (leftBsize &lt; m) ? B[leftBsize] : INT_MAX;\n        if (leftA &lt;= rightB and leftB &lt;= rightA) {\n            if ((m + n) % 2 == 0)\n                return (max(leftA, leftB)\n                        + min(rightA, rightB))\n                       / 2.0;\n            return max(leftA, leftB);\n        }\n        else if (leftA &gt; rightB) {\n            end = mid - 1;\n        }\n        else\n            start = mid + 1;\n    }\n    return 0.0;\n    }\n};\n// Method 2\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        vector&lt;int&gt; Temp;\n        Temp.reserve(nums1.size() + nums1.size() );\n        Temp.insert(Temp.end(), nums1.begin(), nums1.end());\n        Temp.insert(Temp.end(), nums2.begin(), nums2.end());\n\t\tsort(Temp.begin(), Temp.end());\n\t\tif (Temp.size() % 2 == 0)\n\t\t\treturn (Temp[Temp.size() / 2 - 1] + Temp[Temp.size() / 2]) / 2.0;\n\t\telse\n\t\t\treturn  Temp[Temp.size() / 2];\n    }\n};\n\n",
        "url": "/2022/06/24/4-Median-of-Two-Sorted-Arrays/"
      },
    
      {
        "title": "Combination Sum II",
        "excerpt": "&lt;-M 40&gt; Combination Sum II\n\n// Method 1\nclass Solution {\npublic:\n    void recur(int ind, int tar, vector&lt;int&gt;&amp; c, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; ds){\n        if(tar == 0){\n            ans.push_back(ds);\n            return;\n        }\n        for(int i = ind; i &lt; c.size(); i++){\n            if(i &gt; ind &amp;&amp; c[i] == c[i - 1])\n                continue;\n            if(c[i] &gt; tar)\n                break;\n\n            ds.push_back(c[i]);\n            recur(i + 1, tar - c[i], c, ans, ds);\n            ds.pop_back();\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; c, int target) {\n        sort(c.begin(), c.end());\n        int n = c.size();\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; ds;\n        recur(0, target, c, ans, ds);\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {\n        vector&lt;int&gt; combination;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        sort(candidates.begin(), candidates.end());\n        DFS(candidates, target, combination, 0, 0, result);\n        return result;\n    }\n\n    void DFS(vector&lt;int&gt;&amp; candidates, int target, vector&lt;int&gt;&amp; combination, int start_idx, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n\n        if (sum == target) {\n            result.push_back(combination);\n        }\n\n        for (int i = start_idx; i &lt; candidates.size(); i++) {\n            if (i != start_idx &amp;&amp; candidates[i] ==\n            candidates[i - 1])\n                continue;\n\n            sum += candidates[i];\n\n            if (sum &gt; target)\n                break;\n\n            combination.push_back(candidates[i]);\n            DFS(candidates, target, combination, i + 1, sum, result);\n\n            combination.pop_back();\n            sum -= candidates[i];\n        }\n    }\n};\n\n",
        "content": "&lt;-M 40&gt; Combination Sum II\n\n// Method 1\nclass Solution {\npublic:\n    void recur(int ind, int tar, vector&lt;int&gt;&amp; c, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; ds){\n        if(tar == 0){\n            ans.push_back(ds);\n            return;\n        }\n        for(int i = ind; i &lt; c.size(); i++){\n            if(i &gt; ind &amp;&amp; c[i] == c[i - 1])\n                continue;\n            if(c[i] &gt; tar)\n                break;\n\n            ds.push_back(c[i]);\n            recur(i + 1, tar - c[i], c, ans, ds);\n            ds.pop_back();\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; c, int target) {\n        sort(c.begin(), c.end());\n        int n = c.size();\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; ds;\n        recur(0, target, c, ans, ds);\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {\n        vector&lt;int&gt; combination;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        sort(candidates.begin(), candidates.end());\n        DFS(candidates, target, combination, 0, 0, result);\n        return result;\n    }\n\n    void DFS(vector&lt;int&gt;&amp; candidates, int target, vector&lt;int&gt;&amp; combination, int start_idx, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n\n        if (sum == target) {\n            result.push_back(combination);\n        }\n\n        for (int i = start_idx; i &lt; candidates.size(); i++) {\n            if (i != start_idx &amp;&amp; candidates[i] ==\n            candidates[i - 1])\n                continue;\n\n            sum += candidates[i];\n\n            if (sum &gt; target)\n                break;\n\n            combination.push_back(candidates[i]);\n            DFS(candidates, target, combination, i + 1, sum, result);\n\n            combination.pop_back();\n            sum -= candidates[i];\n        }\n    }\n};\n\n",
        "url": "/2022/06/24/40-Combination-Sum-II/"
      },
    
      {
        "title": "First Missing Positive",
        "excerpt": "&lt;-H 41&gt; First Missing Positive\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {\n        for(int i = 0; i != nums.size(); i++) {\n            while(nums[i] != (i + 1)) {\n                if (nums[i] &lt;= 0 || nums[i] &gt; nums.size() || nums[i] == nums[nums[i] - 1])\n                    break;\n                swap(nums[i], nums[nums[i] - 1]);\n            }\n        }\n\n        for(int i = 0; i != nums.size(); i++)\n            if(nums[i] != (i + 1))\n                return i + 1;\n        return nums.size() + 1;\n    }\n};\n\n",
        "content": "&lt;-H 41&gt; First Missing Positive\n\nclass Solution {\npublic:\n    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {\n        for(int i = 0; i != nums.size(); i++) {\n            while(nums[i] != (i + 1)) {\n                if (nums[i] &lt;= 0 || nums[i] &gt; nums.size() || nums[i] == nums[nums[i] - 1])\n                    break;\n                swap(nums[i], nums[nums[i] - 1]);\n            }\n        }\n\n        for(int i = 0; i != nums.size(); i++)\n            if(nums[i] != (i + 1))\n                return i + 1;\n        return nums.size() + 1;\n    }\n};\n\n",
        "url": "/2022/06/24/41-First-Missing-Positive/"
      },
    
      {
        "title": "Trapping Rain Water",
        "excerpt": "&lt;-H 42&gt; Trapping Rain Water\n\n// Method 1\nclass Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        int max = 0;\n        for(int i = 0; i != height.size(); i++) {\n            if(height[i] &gt; height[max])\n                max = i;\n        }\n\n        int water = 0;\n        int diff = 0;\n        for(int i = 0; i &lt; max; i++) {\n            if(height[i] &gt; diff)\n                diff = height[i];\n            else\n                water += diff - height[i];\n        }\n        diff = 0;\n        for(int i = height.size() - 1; i &gt; max; i--) {\n            if(height[i] &gt; diff)\n                diff = height[i];\n            else\n                water += diff - height[i];\n        }\n        return water;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        stack&lt;pair&lt;int, int&gt;&gt; s;\n        int water = 0;\n\n        for(int i = 0; i != height.size(); i++) {\n            int h = 0;\n            while(!s.empty()) {\n                int bar = s.top().first;\n                int pos = s.top().second;\n\n                water += (min(bar, height[i]) - h) * (i - pos - 1);\n                h = bar;\n                if(height[i] &lt; bar)\n                    break;\n                else\n                    s.pop();\n            }\n            s.push(make_pair(height[i], i));\n        }\n        return water;\n    }\n};\n\n\n",
        "content": "&lt;-H 42&gt; Trapping Rain Water\n\n// Method 1\nclass Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        int max = 0;\n        for(int i = 0; i != height.size(); i++) {\n            if(height[i] &gt; height[max])\n                max = i;\n        }\n\n        int water = 0;\n        int diff = 0;\n        for(int i = 0; i &lt; max; i++) {\n            if(height[i] &gt; diff)\n                diff = height[i];\n            else\n                water += diff - height[i];\n        }\n        diff = 0;\n        for(int i = height.size() - 1; i &gt; max; i--) {\n            if(height[i] &gt; diff)\n                diff = height[i];\n            else\n                water += diff - height[i];\n        }\n        return water;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        stack&lt;pair&lt;int, int&gt;&gt; s;\n        int water = 0;\n\n        for(int i = 0; i != height.size(); i++) {\n            int h = 0;\n            while(!s.empty()) {\n                int bar = s.top().first;\n                int pos = s.top().second;\n\n                water += (min(bar, height[i]) - h) * (i - pos - 1);\n                h = bar;\n                if(height[i] &lt; bar)\n                    break;\n                else\n                    s.pop();\n            }\n            s.push(make_pair(height[i], i));\n        }\n        return water;\n    }\n};\n\n\n",
        "url": "/2022/06/24/42-Trapping-Rain-Water/"
      },
    
      {
        "title": "Wildcard Matching",
        "excerpt": "&lt;-H 44&gt; Wildcard Matching\n\n// Method 1\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        char char_s[s.size() + 1];\n        char char_p[p.size() + 1];\n        strcpy(char_s, s.c_str());\n        strcpy(char_p, p.c_str());\n        return isMatch(char_s, char_p);\n    }\nprivate:\n    bool isMatch(const char *s, const char *p) {\n        bool star = false;\n        const char *str, *ptr;\n        for(str = s, ptr = p; *str != '\\0'; str++, ptr++) {\n            switch(*ptr) {\n                case '?':\n                    break;\n                case '*':\n                    star = true;\n                    s = str, p = ptr;\n                    while(*p == '*')\n                        p++;\n                    if(*p == '\\0')\n                        return true;\n                    str = s - 1;\n                    ptr = p - 1;\n                    break;\n                default:\n                    if(*str != *ptr) {\n                        if(!star)\n                            return false;\n                        s++;\n                        str = s - 1;\n                        ptr = p - 1;\n                    }\n            }\n        }\n        while (*ptr == '*')\n                ptr++;\n            return (*ptr == '\\0');\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int pi = 0, si = 0, star = -1, count = 0;\n\n        while (si &lt; s.size()) {\n            if (p[pi] == '*') {\n                count = si;\n                star = pi++;\n            }\n\n            else if (p[pi] == s[si] || p[pi] == '?') {\n                pi++, si++;\n            }\n            else if (star &gt;= 0){\n                pi = star+1;\n                si = ++count;\n            }\n            else return false;\n        }\n\n        while (pi &lt; p.size() &amp;&amp; p[pi] == '*')\n            pi++;\n        return pi == p.size();\n\n    }\n};\n\n",
        "content": "&lt;-H 44&gt; Wildcard Matching\n\n// Method 1\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        char char_s[s.size() + 1];\n        char char_p[p.size() + 1];\n        strcpy(char_s, s.c_str());\n        strcpy(char_p, p.c_str());\n        return isMatch(char_s, char_p);\n    }\nprivate:\n    bool isMatch(const char *s, const char *p) {\n        bool star = false;\n        const char *str, *ptr;\n        for(str = s, ptr = p; *str != '\\0'; str++, ptr++) {\n            switch(*ptr) {\n                case '?':\n                    break;\n                case '*':\n                    star = true;\n                    s = str, p = ptr;\n                    while(*p == '*')\n                        p++;\n                    if(*p == '\\0')\n                        return true;\n                    str = s - 1;\n                    ptr = p - 1;\n                    break;\n                default:\n                    if(*str != *ptr) {\n                        if(!star)\n                            return false;\n                        s++;\n                        str = s - 1;\n                        ptr = p - 1;\n                    }\n            }\n        }\n        while (*ptr == '*')\n                ptr++;\n            return (*ptr == '\\0');\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int pi = 0, si = 0, star = -1, count = 0;\n\n        while (si &lt; s.size()) {\n            if (p[pi] == '*') {\n                count = si;\n                star = pi++;\n            }\n\n            else if (p[pi] == s[si] || p[pi] == '?') {\n                pi++, si++;\n            }\n            else if (star &gt;= 0){\n                pi = star+1;\n                si = ++count;\n            }\n            else return false;\n        }\n\n        while (pi &lt; p.size() &amp;&amp; p[pi] == '*')\n            pi++;\n        return pi == p.size();\n\n    }\n};\n\n",
        "url": "/2022/06/24/44-Wildcard-Matching/"
      },
    
      {
        "title": "Jump Game II",
        "excerpt": "&lt;-M 45&gt; Jump Game II\n\n// Method 1\nclass Solution {\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        int step = 0;\n        int left = 0;\n        int right = 0;\n        \n        if(n == 1)\n            return 0;\n        \n        while(left &lt;= right) {\n            step++;\n            const int old_right = right;\n            for(int i = left; i &lt;= old_right; i++) {\n                int new_right = i + nums[i];\n                if(new_right &gt;= n - 1)\n                    return step;\n                \n                if(new_right &gt; right)\n                    right = new_right;\n            }\n            left = old_right + 1;\n        }\n        return 0;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if(n == 1 )\n            return 0;       \n        int maxi = 0;\n        int curr = 0;\n        int ans = 0;\n        \n        for(int i = 0; i &lt; n - 1; i++) {\n            maxi = max(maxi, nums[i] + i);\n            if(maxi == n - 1) {\n                return ans + 1;\n            }\n            if(i == curr) {\n                curr = maxi;\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 45&gt; Jump Game II\n\n// Method 1\nclass Solution {\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        int step = 0;\n        int left = 0;\n        int right = 0;\n        \n        if(n == 1)\n            return 0;\n        \n        while(left &lt;= right) {\n            step++;\n            const int old_right = right;\n            for(int i = left; i &lt;= old_right; i++) {\n                int new_right = i + nums[i];\n                if(new_right &gt;= n - 1)\n                    return step;\n                \n                if(new_right &gt; right)\n                    right = new_right;\n            }\n            left = old_right + 1;\n        }\n        return 0;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if(n == 1 )\n            return 0;       \n        int maxi = 0;\n        int curr = 0;\n        int ans = 0;\n        \n        for(int i = 0; i &lt; n - 1; i++) {\n            maxi = max(maxi, nums[i] + i);\n            if(maxi == n - 1) {\n                return ans + 1;\n            }\n            if(i == curr) {\n                curr = maxi;\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/45-Jump-Game-II/"
      },
    
      {
        "title": "Permutations",
        "excerpt": "&lt;-M 46&gt; Permutations\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;int&gt; path;\n\n        dfs(nums, path, result);\n        return result;\n    }\nprivate:\n    void dfs(const vector&lt;int&gt;&amp; nums, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result) {\n        if(path.size() == nums.size()) {\n            result.push_back(path);\n            return;\n        }\n        for(auto i : nums) {\n            auto pos = find(path.begin(), path.end(), i);\n            if(pos == path.end()) {\n                path.push_back(i);\n                dfs(nums, path, result);\n                path.pop_back();\n            }\n        }\n    }\n};\n\n",
        "content": "&lt;-M 46&gt; Permutations\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;int&gt; path;\n\n        dfs(nums, path, result);\n        return result;\n    }\nprivate:\n    void dfs(const vector&lt;int&gt;&amp; nums, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result) {\n        if(path.size() == nums.size()) {\n            result.push_back(path);\n            return;\n        }\n        for(auto i : nums) {\n            auto pos = find(path.begin(), path.end(), i);\n            if(pos == path.end()) {\n                path.push_back(i);\n                dfs(nums, path, result);\n                path.pop_back();\n            }\n        }\n    }\n};\n\n",
        "url": "/2022/06/24/46-Permutations/"
      },
    
      {
        "title": "Permutations II",
        "excerpt": "&lt;-M 47&gt; Permutations II\n\n// Method 1\nclass Solution {\nprivate:\n    void permute(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp;ans, int l) {\n        int r = nums.size() - 1;\n        unordered_set&lt;int&gt; s;\n        if(l == r) {\n            ans.push_back(nums);\n            return;\n        }\n        else {\n            for(int i = l; i &lt;= r; i++){\n                if(s.find(nums[i]) != s.end())\n                    continue;\n                else {\n                    s.insert(nums[i]);\n                    swap(nums[i], nums[l]);\n                    permute(nums, ans, l + 1);\n                    swap(nums[i], nums[l]);\n                }\n            }\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        int l = 0;\n        permute(nums, ans, l);\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n\n      void solve(int n, vector&lt;int&gt;&amp; v, vector&lt;vector&lt;int&gt;&gt;&amp; ans,\n                 vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; mp) {\n        if(v.size() == nums.size()){\n            ans.push_back(v);\n            return;\n        }\n       for(int i = 0; i &lt; n; i++) {\n           if(mp[i] == 1)continue;\n\n            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !mp[i - 1])\n                continue;\n            v.push_back(nums[i]);\n            mp[i] = 1;\n            solve(n, v, ans, nums, mp);\n            mp[i] = 0;\n            v.pop_back();\n        }\n\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; v;\n        int n = nums.size();\n        vector&lt;int&gt;mp (n, 0);\n        sort(nums.begin(), nums.end());\n        solve(n, v, ans, nums, mp);\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 47&gt; Permutations II\n\n// Method 1\nclass Solution {\nprivate:\n    void permute(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp;ans, int l) {\n        int r = nums.size() - 1;\n        unordered_set&lt;int&gt; s;\n        if(l == r) {\n            ans.push_back(nums);\n            return;\n        }\n        else {\n            for(int i = l; i &lt;= r; i++){\n                if(s.find(nums[i]) != s.end())\n                    continue;\n                else {\n                    s.insert(nums[i]);\n                    swap(nums[i], nums[l]);\n                    permute(nums, ans, l + 1);\n                    swap(nums[i], nums[l]);\n                }\n            }\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        int l = 0;\n        permute(nums, ans, l);\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n\n      void solve(int n, vector&lt;int&gt;&amp; v, vector&lt;vector&lt;int&gt;&gt;&amp; ans,\n                 vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; mp) {\n        if(v.size() == nums.size()){\n            ans.push_back(v);\n            return;\n        }\n       for(int i = 0; i &lt; n; i++) {\n           if(mp[i] == 1)continue;\n\n            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !mp[i - 1])\n                continue;\n            v.push_back(nums[i]);\n            mp[i] = 1;\n            solve(n, v, ans, nums, mp);\n            mp[i] = 0;\n            v.pop_back();\n        }\n\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; v;\n        int n = nums.size();\n        vector&lt;int&gt;mp (n, 0);\n        sort(nums.begin(), nums.end());\n        solve(n, v, ans, nums, mp);\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/47-Permutations-II/"
      },
    
      {
        "title": "Rotate Image",
        "excerpt": "&lt;-M 48&gt; Rotate Image\n\nclass Solution {\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        for(int i = 0; i != matrix.size(); i++)\n            for(int j = 0; j &lt; matrix.size() - i; j++)\n                swap(matrix[i][j], matrix[matrix.size() - 1 - j][matrix.size() - 1 - i]);\n        for(int i = 0; i != matrix.size() / 2; i++)\n            for(int j = 0; j &lt; matrix.size(); j++)\n                swap(matrix[i][j], matrix[matrix.size() - 1 - i][j]);\n    }\n};\n\n",
        "content": "&lt;-M 48&gt; Rotate Image\n\nclass Solution {\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        for(int i = 0; i != matrix.size(); i++)\n            for(int j = 0; j &lt; matrix.size() - i; j++)\n                swap(matrix[i][j], matrix[matrix.size() - 1 - j][matrix.size() - 1 - i]);\n        for(int i = 0; i != matrix.size() / 2; i++)\n            for(int j = 0; j &lt; matrix.size(); j++)\n                swap(matrix[i][j], matrix[matrix.size() - 1 - i][j]);\n    }\n};\n\n",
        "url": "/2022/06/24/48-Rotate-Image/"
      },
    
      {
        "title": "Longest Palindromic Substring",
        "excerpt": "&lt;-M 5&gt; Longest Palindromic Substring\n\nclass Solution {\npublic:\n\n\tstring longestPalindrome(string s) {\n        if (s.empty())\n            return \"\";\n        if (s.size() == 1)\n            return s;\n        int min_start = 0, max_len = 1;\n        for (int i = 0; i &lt; s.size();) {\n            if (s.size() - i &lt;= max_len / 2)\n                break;\n            int j = i, k = i;\n            while (k &lt; s.size() - 1 &amp;&amp; s[k+1] == s[k])\n                ++k; // Skip duplicate characters.\n            i = k + 1;\n            while (k &lt; s.size() - 1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) {\n                ++k;\n                --j;\n            } // Expand.\n            int new_len = k - j + 1;\n            if (new_len &gt; max_len) {\n                min_start = j;\n                max_len = new_len;\n            }\n        }\n        return s.substr(min_start, max_len);\n    }\n};\n\n",
        "content": "&lt;-M 5&gt; Longest Palindromic Substring\n\nclass Solution {\npublic:\n\n\tstring longestPalindrome(string s) {\n        if (s.empty())\n            return \"\";\n        if (s.size() == 1)\n            return s;\n        int min_start = 0, max_len = 1;\n        for (int i = 0; i &lt; s.size();) {\n            if (s.size() - i &lt;= max_len / 2)\n                break;\n            int j = i, k = i;\n            while (k &lt; s.size() - 1 &amp;&amp; s[k+1] == s[k])\n                ++k; // Skip duplicate characters.\n            i = k + 1;\n            while (k &lt; s.size() - 1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) {\n                ++k;\n                --j;\n            } // Expand.\n            int new_len = k - j + 1;\n            if (new_len &gt; max_len) {\n                min_start = j;\n                max_len = new_len;\n            }\n        }\n        return s.substr(min_start, max_len);\n    }\n};\n\n",
        "url": "/2022/06/24/5-Longest-Palindromic-Substring/"
      },
    
      {
        "title": "N-Queens",
        "excerpt": "&lt;-H 51&gt; N-Queens\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        this-&gt;columns = vector&lt;int&gt; (n, 0);\n        this-&gt;main_diag = vector&lt;int&gt; (2 * n, 0);\n        this-&gt;anti_diag  = vector&lt;int&gt; (2 * n, 0);\n\n\n        vector&lt;vector&lt;string&gt;&gt; result;\n        vector&lt;int&gt; count(n, 0);\n        dfs(count, result, 0);\n        return result;\n    }\n\nprivate:\n    vector&lt;int&gt; columns;\n    vector&lt;int&gt; main_diag;\n    vector&lt;int&gt; anti_diag;\n\n    void dfs(vector&lt;int&gt; &amp;count, vector&lt;vector&lt;string&gt;&gt; &amp;result, int row) {\n        const int num = count.size();\n        if(row == num) {\n            vector&lt;string&gt; solution;\n            for(int i = 0; i &lt; num; i++) {\n                string s(num, '.');\n                for(int j = 0; j &lt; num; j++)\n                    if(j == count[i])\n                        s[j] = 'Q';\n                solution.push_back(s);\n            }\n            result.push_back(solution);\n            return;\n        }\n\n        for(int j = 0; j &lt; num; j++) {\n            bool ok = columns[j] == 0 &amp;&amp; main_diag[row + j] == 0 &amp;&amp;\n                anti_diag[row - j + num] == 0;\n\n            if(!ok)\n                continue;\n            count[row] = j;\n            columns[j] = main_diag[row + j] = anti_diag[row - j + num] = 1;\n            dfs(count, result, row + 1);\n\n            count[row] = 0;\n            columns[j] = main_diag[row + j] = anti_diag[row - j + num] = 0;\n        }\n    }\n};\n\n// Method 2\nclass Solution {\nprivate:\n\nvoid fun(vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; &amp;board, vector&lt;int&gt; &amp;leftrow,\n         vector&lt;int&gt; &amp;upper, vector&lt;int&gt; &amp;lower, int col) {\n        if(col == board.size()) {\n            ans.push_back(board);\n            return;\n        }\n        for(int i = 0; i &lt; board.size(); i++) {\n            if(leftrow[i] == 0 &amp;&amp; upper[board.size() - 1 + col - i] == 0 &amp;&amp;\n               lower[i + col] == 0) {\n                board[i][col] = 'Q';\n                leftrow[i] = 1;\n                upper[board.size() - 1 + col - i] = 1;\n                lower[i + col] = 1;\n                fun(ans, board, leftrow, upper, lower, col + 1);\n                board[i][col] = '.';\n                leftrow[i] = 0;\n                upper[board.size() - 1 + col - i] = 0;\n                lower[i + col] = 0;\n            }\n        }\n    }\npublic:\n\tvector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n\t\tvector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; board;\n        string x(n, '.');\n        for(int i = 0; i &lt; n; i++)\n            board.push_back(x);\n        vector&lt;int&gt; leftrow(n, 0);\n        vector&lt;int&gt; upper(2 * n - 1, 0);\n        vector&lt;int&gt; lower(2 * n - 1, 0);\n        fun(ans, board, leftrow, upper, lower,0);\n        return ans;\n\t}\n};\n\n",
        "content": "&lt;-H 51&gt; N-Queens\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n        this-&gt;columns = vector&lt;int&gt; (n, 0);\n        this-&gt;main_diag = vector&lt;int&gt; (2 * n, 0);\n        this-&gt;anti_diag  = vector&lt;int&gt; (2 * n, 0);\n\n\n        vector&lt;vector&lt;string&gt;&gt; result;\n        vector&lt;int&gt; count(n, 0);\n        dfs(count, result, 0);\n        return result;\n    }\n\nprivate:\n    vector&lt;int&gt; columns;\n    vector&lt;int&gt; main_diag;\n    vector&lt;int&gt; anti_diag;\n\n    void dfs(vector&lt;int&gt; &amp;count, vector&lt;vector&lt;string&gt;&gt; &amp;result, int row) {\n        const int num = count.size();\n        if(row == num) {\n            vector&lt;string&gt; solution;\n            for(int i = 0; i &lt; num; i++) {\n                string s(num, '.');\n                for(int j = 0; j &lt; num; j++)\n                    if(j == count[i])\n                        s[j] = 'Q';\n                solution.push_back(s);\n            }\n            result.push_back(solution);\n            return;\n        }\n\n        for(int j = 0; j &lt; num; j++) {\n            bool ok = columns[j] == 0 &amp;&amp; main_diag[row + j] == 0 &amp;&amp;\n                anti_diag[row - j + num] == 0;\n\n            if(!ok)\n                continue;\n            count[row] = j;\n            columns[j] = main_diag[row + j] = anti_diag[row - j + num] = 1;\n            dfs(count, result, row + 1);\n\n            count[row] = 0;\n            columns[j] = main_diag[row + j] = anti_diag[row - j + num] = 0;\n        }\n    }\n};\n\n// Method 2\nclass Solution {\nprivate:\n\nvoid fun(vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; &amp;board, vector&lt;int&gt; &amp;leftrow,\n         vector&lt;int&gt; &amp;upper, vector&lt;int&gt; &amp;lower, int col) {\n        if(col == board.size()) {\n            ans.push_back(board);\n            return;\n        }\n        for(int i = 0; i &lt; board.size(); i++) {\n            if(leftrow[i] == 0 &amp;&amp; upper[board.size() - 1 + col - i] == 0 &amp;&amp;\n               lower[i + col] == 0) {\n                board[i][col] = 'Q';\n                leftrow[i] = 1;\n                upper[board.size() - 1 + col - i] = 1;\n                lower[i + col] = 1;\n                fun(ans, board, leftrow, upper, lower, col + 1);\n                board[i][col] = '.';\n                leftrow[i] = 0;\n                upper[board.size() - 1 + col - i] = 0;\n                lower[i + col] = 0;\n            }\n        }\n    }\npublic:\n\tvector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {\n\t\tvector&lt;vector&lt;string&gt;&gt; ans;\n        vector&lt;string&gt; board;\n        string x(n, '.');\n        for(int i = 0; i &lt; n; i++)\n            board.push_back(x);\n        vector&lt;int&gt; leftrow(n, 0);\n        vector&lt;int&gt; upper(2 * n - 1, 0);\n        vector&lt;int&gt; lower(2 * n - 1, 0);\n        fun(ans, board, leftrow, upper, lower,0);\n        return ans;\n\t}\n};\n\n",
        "url": "/2022/06/24/51-N-Queens/"
      },
    
      {
        "title": "N-Queens II",
        "excerpt": "&lt;-H 52&gt; N-Queens II\n\nclass Solution {\n\nprivate:\n    vector&lt;int&gt; columns;\n    vector&lt;int&gt; main_diag;\n    vector&lt;int&gt; anti_diag;\n    int ans_count;\n\n    void dfs(vector&lt;int&gt; &amp;count, int row) {\n        const int num = count.size();\n        if(row == num) {\n            this-&gt;ans_count++;\n            return;\n        }\n\n        for(int j = 0; j &lt; num; j++) {\n            bool ok = columns[j] == 0 &amp;&amp; main_diag[row + j] == 0 &amp;&amp;\n                anti_diag[row - j + num] == 0;\n\n            if(!ok)\n                continue;\n            count[row] = j;\n            columns[j] = main_diag[row + j] = anti_diag[row - j + num] = 1;\n            dfs(count, row + 1);\n\n            count[row] = 0;\n            columns[j] = main_diag[row + j] = anti_diag[row - j + num] = 0;\n        }\n    }\npublic:\n    int totalNQueens(int n) {\n        this-&gt;columns = vector&lt;int&gt; (n, 0);\n        this-&gt;main_diag = vector&lt;int&gt; (2 * n, 0);\n        this-&gt;anti_diag  = vector&lt;int&gt; (2 * n, 0);\n        this-&gt;ans_count = 0;\n\n        vector&lt;int&gt; count(n, 0);\n        dfs(count, 0);\n        return this-&gt;ans_count;\n    }\n};\n\n\n",
        "content": "&lt;-H 52&gt; N-Queens II\n\nclass Solution {\n\nprivate:\n    vector&lt;int&gt; columns;\n    vector&lt;int&gt; main_diag;\n    vector&lt;int&gt; anti_diag;\n    int ans_count;\n\n    void dfs(vector&lt;int&gt; &amp;count, int row) {\n        const int num = count.size();\n        if(row == num) {\n            this-&gt;ans_count++;\n            return;\n        }\n\n        for(int j = 0; j &lt; num; j++) {\n            bool ok = columns[j] == 0 &amp;&amp; main_diag[row + j] == 0 &amp;&amp;\n                anti_diag[row - j + num] == 0;\n\n            if(!ok)\n                continue;\n            count[row] = j;\n            columns[j] = main_diag[row + j] = anti_diag[row - j + num] = 1;\n            dfs(count, row + 1);\n\n            count[row] = 0;\n            columns[j] = main_diag[row + j] = anti_diag[row - j + num] = 0;\n        }\n    }\npublic:\n    int totalNQueens(int n) {\n        this-&gt;columns = vector&lt;int&gt; (n, 0);\n        this-&gt;main_diag = vector&lt;int&gt; (2 * n, 0);\n        this-&gt;anti_diag  = vector&lt;int&gt; (2 * n, 0);\n        this-&gt;ans_count = 0;\n\n        vector&lt;int&gt; count(n, 0);\n        dfs(count, 0);\n        return this-&gt;ans_count;\n    }\n};\n\n\n",
        "url": "/2022/06/24/52-N-Queens-II/"
      },
    
      {
        "title": "Jump Game",
        "excerpt": "&lt;-M 55&gt; Jump Game\n\nclass Solution {\npublic:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if(n == 0)\n            return true;\n        int left_most = n - 1;\n\n        for(int i = n - 2; i &gt;= 0; i--)\n            if(i + nums[i] &gt;= left_most)\n                left_most = i;\n\n        return left_most == 0;\n    }\n};\n\n",
        "content": "&lt;-M 55&gt; Jump Game\n\nclass Solution {\npublic:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if(n == 0)\n            return true;\n        int left_most = n - 1;\n\n        for(int i = n - 2; i &gt;= 0; i--)\n            if(i + nums[i] &gt;= left_most)\n                left_most = i;\n\n        return left_most == 0;\n    }\n};\n\n",
        "url": "/2022/06/24/55-Jump-Game/"
      },
    
      {
        "title": "Permutation Sequence",
        "excerpt": "&lt;-M 60&gt; Permutation Sequence\n\n// Method 1\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        string s(n, '0');\n        string ans;\n        for(int i = 0; i &lt; n; i++) {\n            s[i] += i + 1;\n        }\n        return kthPermutation(s, k);\n    }\n\nprivate:\n    int factorial(int n) {\n        int result = 1;\n        for(int i = 1; i &lt;= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    string kthPermutation(string seq, int k) {\n        const int n = seq.size();\n        string ans;\n\n        int base = factorial(n - 1);\n        --k;\n\n        for(int i = n - 1; i &gt; 0; k %= base, base /= i, i--) {\n            auto index = next(seq.begin(), k / base);\n            ans.push_back(*index);\n            seq.erase(index);\n        }\n        ans.push_back(seq[0]);\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n\n        int fact =  1;\n        vector&lt;int&gt; nums;\n        for(int i = 1; i &lt; n; i++) {\n            fact = fact * i;\n            nums.push_back(i);\n        }\n\n        nums.push_back(n);\n        string result = \"\";\n        k = k - 1;\n        while(true) {\n            result.push_back(nums[k / fact] + '0');\n            nums.erase(nums.begin() + k / fact);\n\n            if(nums.size() == 0)\n                break;\n            k = k % fact;\n            fact = fact / nums.size();\n        }\n\n        return result;\n    }\n};\n\n",
        "content": "&lt;-M 60&gt; Permutation Sequence\n\n// Method 1\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n        string s(n, '0');\n        string ans;\n        for(int i = 0; i &lt; n; i++) {\n            s[i] += i + 1;\n        }\n        return kthPermutation(s, k);\n    }\n\nprivate:\n    int factorial(int n) {\n        int result = 1;\n        for(int i = 1; i &lt;= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    string kthPermutation(string seq, int k) {\n        const int n = seq.size();\n        string ans;\n\n        int base = factorial(n - 1);\n        --k;\n\n        for(int i = n - 1; i &gt; 0; k %= base, base /= i, i--) {\n            auto index = next(seq.begin(), k / base);\n            ans.push_back(*index);\n            seq.erase(index);\n        }\n        ans.push_back(seq[0]);\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string getPermutation(int n, int k) {\n\n        int fact =  1;\n        vector&lt;int&gt; nums;\n        for(int i = 1; i &lt; n; i++) {\n            fact = fact * i;\n            nums.push_back(i);\n        }\n\n        nums.push_back(n);\n        string result = \"\";\n        k = k - 1;\n        while(true) {\n            result.push_back(nums[k / fact] + '0');\n            nums.erase(nums.begin() + k / fact);\n\n            if(nums.size() == 0)\n                break;\n            k = k % fact;\n            fact = fact / nums.size();\n        }\n\n        return result;\n    }\n};\n\n",
        "url": "/2022/06/24/60-Permutation-Sequence/"
      },
    
      {
        "title": "Rotate List",
        "excerpt": "&lt;-M 61&gt; Rotate List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || k == 0)\n            return head;\n\n        int len = 1;\n        ListNode *p = head;\n\n        while(p-&gt;next) {\n            len++;\n            p = p-&gt;next;\n        }\n\n        k = len - k % len;\n\n        p-&gt;next = head;\n        for(int i = 0; i &lt; k; i++)\n            p = p-&gt;next;\n\n        head = p-&gt;next;\n        p-&gt;next = nullptr;\n\n        return head;\n    }\n};\n\n",
        "content": "&lt;-M 61&gt; Rotate List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || k == 0)\n            return head;\n\n        int len = 1;\n        ListNode *p = head;\n\n        while(p-&gt;next) {\n            len++;\n            p = p-&gt;next;\n        }\n\n        k = len - k % len;\n\n        p-&gt;next = head;\n        for(int i = 0; i &lt; k; i++)\n            p = p-&gt;next;\n\n        head = p-&gt;next;\n        p-&gt;next = nullptr;\n\n        return head;\n    }\n};\n\n",
        "url": "/2022/06/24/61-Rotate-List/"
      },
    
      {
        "title": "Unique Paths",
        "excerpt": "&lt;-M 62&gt; Unique Paths\n\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector&lt;int&gt; f(n, 0);\n        f[0] = 1;\n        for(int i = 0; i &lt; m; i++)\n            for(int j = 1; j &lt; n; j++)\n                f[j] = f[j - 1] + f[j];\n        return f[n - 1];\n    }\n};\n\n",
        "content": "&lt;-M 62&gt; Unique Paths\n\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector&lt;int&gt; f(n, 0);\n        f[0] = 1;\n        for(int i = 0; i &lt; m; i++)\n            for(int j = 1; j &lt; n; j++)\n                f[j] = f[j - 1] + f[j];\n        return f[n - 1];\n    }\n};\n\n",
        "url": "/2022/06/24/62-Unique-Paths/"
      },
    
      {
        "title": "Unique Paths II",
        "excerpt": "&lt;-M 63&gt; Unique Paths II\n\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n        const int m = obstacleGrid.size();\n        const int n = obstacleGrid.front().size();\n\n        if(obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1])\n            return 0;\n\n        vector&lt;int&gt; f(n, 0);\n        f[0] = obstacleGrid[0][0] ? 0 : 1;\n\n        for(int i = 0; i &lt; m; i++)\n            for(int j = 0; j &lt; n; j++)\n                f[j] = obstacleGrid[i][j] ? 0 : (j == 0 ? 0 : f[j - 1]) + f[j];\n\n        return f[n - 1];\n    }\n};\n\n",
        "content": "&lt;-M 63&gt; Unique Paths II\n\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n        const int m = obstacleGrid.size();\n        const int n = obstacleGrid.front().size();\n\n        if(obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1])\n            return 0;\n\n        vector&lt;int&gt; f(n, 0);\n        f[0] = obstacleGrid[0][0] ? 0 : 1;\n\n        for(int i = 0; i &lt; m; i++)\n            for(int j = 0; j &lt; n; j++)\n                f[j] = obstacleGrid[i][j] ? 0 : (j == 0 ? 0 : f[j - 1]) + f[j];\n\n        return f[n - 1];\n    }\n};\n\n",
        "url": "/2022/06/24/63-Unique-Paths-II/"
      },
    
      {
        "title": "Minimum Path Sum",
        "excerpt": "&lt;-M 64&gt; Minimum Path Sum\n\nclass Solution {\npublic:\n    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        const int m = grid.size();\n        const int n = grid[0].size();\n\n        int f[n];\n        fill(f, f + n, INT_MAX);\n\n        f[0] = 0;\n\n        for(int i = 0; i &lt; m; i++) {\n            f[0] += grid[i][0];\n            for(int j = 1; j &lt; n; j++) {\n                f[j] = min(f[j -1], f[j]) + grid[i][j];\n            }\n        }\n        return f[n -1];\n    }\n};\n\n\n",
        "content": "&lt;-M 64&gt; Minimum Path Sum\n\nclass Solution {\npublic:\n    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        const int m = grid.size();\n        const int n = grid[0].size();\n\n        int f[n];\n        fill(f, f + n, INT_MAX);\n\n        f[0] = 0;\n\n        for(int i = 0; i &lt; m; i++) {\n            f[0] += grid[i][0];\n            for(int j = 1; j &lt; n; j++) {\n                f[j] = min(f[j -1], f[j]) + grid[i][j];\n            }\n        }\n        return f[n -1];\n    }\n};\n\n\n",
        "url": "/2022/06/24/64-Minimum-Path-Sum/"
      },
    
      {
        "title": "Valid Number",
        "excerpt": "&lt;-H 65&gt; Valid Number\n\n// Method 1\nclass Solution {\nprivate:\n    enum InputType {\n            INVALID,  // 0\n            SPACE,    // 1\n            SIGN,     // 2\n            DIGIT,    // 3\n            DOT,      // 4\n            EXPONENT, // 5\n            NUM_INPUTS// 6\n        };\n\npublic:\n    bool isNumber(string s) {\n        const int transitionTable[][NUM_INPUTS] = {\n        -1,  0,  3,  1,  2, -1,\n        -1,  8, -1,  1,  4,  5,\n        -1, -1, -1,  4, -1, -1,\n        -1, -1, -1,  1,  2, -1,\n        -1,  8, -1,  4, -1,  5,\n        -1, -1,  6,  7, -1, -1,\n        -1, -1, -1,  7, -1, -1,\n        -1,  8, -1,  7, -1, -1,\n        -1,  8, -1, -1, -1, -1,\n    };\n        int state = 0;\n        for(auto i : s) {\n            InputType inputType = INVALID;\n            if(isspace(i))\n                inputType = SPACE;\n            else if(i == '+' || i == '-')\n                inputType = SIGN;\n            else if(isdigit(i))\n                inputType = DIGIT;\n            else if(i == '.')\n                inputType = DOT;\n            else if(i == 'e' || i == 'E')\n                inputType = EXPONENT;\n\n            state = transitionTable[state][inputType];\n\n            if(state == -1)\n                return false;\n        }\n\n        return state == 1 || state == 4 || state == 7 || state == 8;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isNumber(string s) {\n        bool sign = alse, dot = false, exp = false;\n        bool num = false, numAfterE = true;\n        for (int i = 0; i &lt; s.size(); i++) {\n            if (isspace(s[i])) {\n                if (sign || dot || exp || num)\n                    return false;\n            } else if (s[i] == '+' || s[i] == '-') {\n                if (i &gt; 0 &amp;&amp; s[i - 1]!=' ' &amp;&amp; s[i - 1]!='e')\n                    return false;\n                sign = true;\n            } else if (s[i] == '.') {\n                if (dot || exp)\n                    return false;\n                dot = true;\n            } else if (s[i] == 'e' || s[i] == 'E') {\n                if (!num || exp)\n                    return false;\n                exp = true;\n                numAfterE = false;\n            } else if (isdigit(s[i])) {\n                num = true;\n                numAfterE = true;\n            } else return false;\n        }\n\n        return num &amp;&amp; numAfterE;\n    }\n};\n\n",
        "content": "&lt;-H 65&gt; Valid Number\n\n// Method 1\nclass Solution {\nprivate:\n    enum InputType {\n            INVALID,  // 0\n            SPACE,    // 1\n            SIGN,     // 2\n            DIGIT,    // 3\n            DOT,      // 4\n            EXPONENT, // 5\n            NUM_INPUTS// 6\n        };\n\npublic:\n    bool isNumber(string s) {\n        const int transitionTable[][NUM_INPUTS] = {\n        -1,  0,  3,  1,  2, -1,\n        -1,  8, -1,  1,  4,  5,\n        -1, -1, -1,  4, -1, -1,\n        -1, -1, -1,  1,  2, -1,\n        -1,  8, -1,  4, -1,  5,\n        -1, -1,  6,  7, -1, -1,\n        -1, -1, -1,  7, -1, -1,\n        -1,  8, -1,  7, -1, -1,\n        -1,  8, -1, -1, -1, -1,\n    };\n        int state = 0;\n        for(auto i : s) {\n            InputType inputType = INVALID;\n            if(isspace(i))\n                inputType = SPACE;\n            else if(i == '+' || i == '-')\n                inputType = SIGN;\n            else if(isdigit(i))\n                inputType = DIGIT;\n            else if(i == '.')\n                inputType = DOT;\n            else if(i == 'e' || i == 'E')\n                inputType = EXPONENT;\n\n            state = transitionTable[state][inputType];\n\n            if(state == -1)\n                return false;\n        }\n\n        return state == 1 || state == 4 || state == 7 || state == 8;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isNumber(string s) {\n        bool sign = alse, dot = false, exp = false;\n        bool num = false, numAfterE = true;\n        for (int i = 0; i &lt; s.size(); i++) {\n            if (isspace(s[i])) {\n                if (sign || dot || exp || num)\n                    return false;\n            } else if (s[i] == '+' || s[i] == '-') {\n                if (i &gt; 0 &amp;&amp; s[i - 1]!=' ' &amp;&amp; s[i - 1]!='e')\n                    return false;\n                sign = true;\n            } else if (s[i] == '.') {\n                if (dot || exp)\n                    return false;\n                dot = true;\n            } else if (s[i] == 'e' || s[i] == 'E') {\n                if (!num || exp)\n                    return false;\n                exp = true;\n                numAfterE = false;\n            } else if (isdigit(s[i])) {\n                num = true;\n                numAfterE = true;\n            } else return false;\n        }\n\n        return num &amp;&amp; numAfterE;\n    }\n};\n\n",
        "url": "/2022/06/24/65-Valid-Number/"
      },
    
      {
        "title": "Simplify Path",
        "excerpt": "&lt;-M 71&gt; Simplify Path\n\n// Method 1\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        vector&lt;string&gt; dirs;\n        for(auto i = path.begin(); i != path.end();) {\n            ++i;\n\n            auto j = find(i, path.end(), '/');\n            auto dir = string(i, j);\n\n            if(!dir.empty() &amp;&amp; dir != \".\") {\n                if(dir == \"..\") {\n                    if(!dirs.empty())\n                        dirs.pop_back();\n                }\n                else\n                    dirs.push_back(dir);\n            }\n            i = j;\n        }\n\n        stringstream out;\n        if(dirs.empty())\n            out &lt;&lt; \"/\";\n        else\n            for(auto dir : dirs)\n                out &lt;&lt; '/' &lt;&lt; dir;\n\n        return out.str();\n\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n\n        stack&lt;string&gt; st;\n        string res;\n\n        for(int i = 0;  i &lt; path.size(); ++i) {\n            if(path[i] == '/')\n                continue;\n            string temp;\n            while(i &lt; path.size() &amp;&amp; path[i] != '/') {\n                temp += path[i];\n                ++i;\n            }\n            if(temp == \".\")\n                continue;\n            else if(temp == \"..\") {\n                if(!st.empty())\n                    st.pop();\n            }\n            else\n                st.push(temp);\n        }\n\n        while(!st.empty()) {\n            res = \"/\" + st.top() + res;\n            st.pop();\n        }\n\n        if(res.size() == 0)\n            return \"/\";\n\n        return res;\n    }\n};\n\n",
        "content": "&lt;-M 71&gt; Simplify Path\n\n// Method 1\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        vector&lt;string&gt; dirs;\n        for(auto i = path.begin(); i != path.end();) {\n            ++i;\n\n            auto j = find(i, path.end(), '/');\n            auto dir = string(i, j);\n\n            if(!dir.empty() &amp;&amp; dir != \".\") {\n                if(dir == \"..\") {\n                    if(!dirs.empty())\n                        dirs.pop_back();\n                }\n                else\n                    dirs.push_back(dir);\n            }\n            i = j;\n        }\n\n        stringstream out;\n        if(dirs.empty())\n            out &lt;&lt; \"/\";\n        else\n            for(auto dir : dirs)\n                out &lt;&lt; '/' &lt;&lt; dir;\n\n        return out.str();\n\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n\n        stack&lt;string&gt; st;\n        string res;\n\n        for(int i = 0;  i &lt; path.size(); ++i) {\n            if(path[i] == '/')\n                continue;\n            string temp;\n            while(i &lt; path.size() &amp;&amp; path[i] != '/') {\n                temp += path[i];\n                ++i;\n            }\n            if(temp == \".\")\n                continue;\n            else if(temp == \"..\") {\n                if(!st.empty())\n                    st.pop();\n            }\n            else\n                st.push(temp);\n        }\n\n        while(!st.empty()) {\n            res = \"/\" + st.top() + res;\n            st.pop();\n        }\n\n        if(res.size() == 0)\n            return \"/\";\n\n        return res;\n    }\n};\n\n",
        "url": "/2022/06/24/71-Simplify-Path/"
      },
    
      {
        "title": "Set Matrix Zeroes",
        "excerpt": "&lt;-M 73&gt; Set Matrix Zeroes\n\nclass Solution {\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        const int m = matrix.size();\n        const int n = matrix[0].size();\n\n        vector&lt;int&gt; row(m, false);\n        vector&lt;int&gt; col(n, false);\n\n        for(int i = 0; i != m; i++)\n            for(int j = 0; j != n; j++)\n                if(matrix[i][j] == 0)\n                    row[i] = col[j] = true;\n\n        for(int i = 0; i != m; i++)\n            if(row[i])\n                fill(&amp;matrix[i][0], &amp;matrix[i][0] + n, 0);\n\n        for(int i = 0; i != n; i++)\n            if(col[i])\n                for(int j = 0; j != m; j++)\n                    matrix[j][i] = 0;\n\n    }\n};\n\n",
        "content": "&lt;-M 73&gt; Set Matrix Zeroes\n\nclass Solution {\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        const int m = matrix.size();\n        const int n = matrix[0].size();\n\n        vector&lt;int&gt; row(m, false);\n        vector&lt;int&gt; col(n, false);\n\n        for(int i = 0; i != m; i++)\n            for(int j = 0; j != n; j++)\n                if(matrix[i][j] == 0)\n                    row[i] = col[j] = true;\n\n        for(int i = 0; i != m; i++)\n            if(row[i])\n                fill(&amp;matrix[i][0], &amp;matrix[i][0] + n, 0);\n\n        for(int i = 0; i != n; i++)\n            if(col[i])\n                for(int j = 0; j != m; j++)\n                    matrix[j][i] = 0;\n\n    }\n};\n\n",
        "url": "/2022/06/24/73-Set-Matrix-Zeroes/"
      },
    
      {
        "title": "Search a 2D Matrix",
        "excerpt": "&lt;-M 74&gt; Search a 2D Matrix\n\nclass Solution {\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        if(matrix.size() == 0)\n            return false;\n\n        const int m = matrix.size();\n        const int n = matrix[0].size();\n\n\n        int first = 0;\n        int last = m * n;\n\n        while(first &lt; last) {\n            int mid = first + (last - first) / 2;\n            int value = matrix[mid / n][mid % n];\n\n            if(value == target)\n                return true;\n            else if(value &lt; target)\n                first = mid + 1;\n            else\n                last = mid;\n        }\n        return false;\n    }\n};\n\n",
        "content": "&lt;-M 74&gt; Search a 2D Matrix\n\nclass Solution {\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {\n        if(matrix.size() == 0)\n            return false;\n\n        const int m = matrix.size();\n        const int n = matrix[0].size();\n\n\n        int first = 0;\n        int last = m * n;\n\n        while(first &lt; last) {\n            int mid = first + (last - first) / 2;\n            int value = matrix[mid / n][mid % n];\n\n            if(value == target)\n                return true;\n            else if(value &lt; target)\n                first = mid + 1;\n            else\n                last = mid;\n        }\n        return false;\n    }\n};\n\n",
        "url": "/2022/06/24/74-Search-a-2D-Matrix/"
      },
    
      {
        "title": "Sort Colors",
        "excerpt": "&lt;-M 75&gt; Sort Colors\n\n// Method 1\nclass Solution {\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) {\n        int red = 0, blue = nums.size() - 1;\n\n        for (int i = 0; i &lt; blue + 1;) {\n            switch(nums[i]) {\n                 case 0:\n                    swap(nums[i++], nums[red++]);\n                    break;\n                default:\n                    i++;\n                    break;\n                case 2:\n                    swap(nums[i], nums[blue--]);\n                    break;\n            }\n        }\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) {\n        int check[3] = {0};\n\n        for(auto i : nums)\n            check[i]++;\n\n        int index = 0;\n        for(int i = 0; i != 3; i++) {\n            for(int j = check[i]; j != 0; j--)\n                nums[index++] = i;\n        }\n    }\n};\n\n",
        "content": "&lt;-M 75&gt; Sort Colors\n\n// Method 1\nclass Solution {\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) {\n        int red = 0, blue = nums.size() - 1;\n\n        for (int i = 0; i &lt; blue + 1;) {\n            switch(nums[i]) {\n                 case 0:\n                    swap(nums[i++], nums[red++]);\n                    break;\n                default:\n                    i++;\n                    break;\n                case 2:\n                    swap(nums[i], nums[blue--]);\n                    break;\n            }\n        }\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) {\n        int check[3] = {0};\n\n        for(auto i : nums)\n            check[i]++;\n\n        int index = 0;\n        for(int i = 0; i != 3; i++) {\n            for(int j = check[i]; j != 0; j--)\n                nums[index++] = i;\n        }\n    }\n};\n\n",
        "url": "/2022/06/24/75-Sort-Colors/"
      },
    
      {
        "title": "Combinations",
        "excerpt": "&lt;-M 77&gt; Combinations\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        vector&lt;int&gt; path;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        dfs(n, k, 1, 0, path, result);\n        return result;\n    }\nprivate:\n    void dfs(int n, int k, int start, int curr,\n            vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n        if(curr == k)\n            result.push_back(path);\n        for(int i = start; i &lt;= n; i++) {\n            path.push_back(i);\n            dfs(n, k, i + 1, curr + 1, path, result);\n            path.pop_back();\n        }\n    }\n};\n\n",
        "content": "&lt;-M 77&gt; Combinations\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        vector&lt;int&gt; path;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        dfs(n, k, 1, 0, path, result);\n        return result;\n    }\nprivate:\n    void dfs(int n, int k, int start, int curr,\n            vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n        if(curr == k)\n            result.push_back(path);\n        for(int i = start; i &lt;= n; i++) {\n            path.push_back(i);\n            dfs(n, k, i + 1, curr + 1, path, result);\n            path.pop_back();\n        }\n    }\n};\n\n",
        "url": "/2022/06/24/77-Combinations/"
      },
    
      {
        "title": "Subsets",
        "excerpt": "&lt;-M 78&gt; Subsets\n\nclass Solution {\npublic:\n    void helper(vector&lt;int&gt;&amp; nums, int i, vector&lt;int&gt;&amp; subset, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if(i==nums.size()){\n            ans.push_back(subset);\n            return;\n        }\n\n        subset.push_back(nums[i]);\n        helper(nums, i + 1, subset, ans);\n\n        subset.pop_back();\n        helper(nums, i + 1, subset, ans);\n\n    }\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; x;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        helper(nums, 0, x, ans);\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 78&gt; Subsets\n\nclass Solution {\npublic:\n    void helper(vector&lt;int&gt;&amp; nums, int i, vector&lt;int&gt;&amp; subset, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {\n        if(i==nums.size()){\n            ans.push_back(subset);\n            return;\n        }\n\n        subset.push_back(nums[i]);\n        helper(nums, i + 1, subset, ans);\n\n        subset.pop_back();\n        helper(nums, i + 1, subset, ans);\n\n    }\n    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {\n        vector&lt;int&gt; x;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        helper(nums, 0, x, ans);\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/78-Subsets/"
      },
    
      {
        "title": "Word Search",
        "excerpt": "&lt;-M 79&gt; Word Search\n\n// Method 1\nclass Solution {\npublic:\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {\n        const int m = board.size();\n        const int n = board[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));\n\n        for(int i = 0; i &lt; m; i++)\n            for(int j = 0; j &lt; n; j++)\n                if(dfs(board, word, 0, i, j, visited))\n                    return true;\n        return false;\n    }\nprivate:\n    bool dfs(const vector&lt;vector&lt;char&gt;&gt;&amp; board, const string word,\n             int index, int x, int y, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) {\n        if(index == word.size())\n            return true;\n        if(x &lt; 0 || y &lt; 0 || x &gt;= board.size() || y &gt;= board[0].size())\n            return false;\n\n        if(visited[x][y])\n            return false;\n\n        if(board[x][y] != word[index])\n            return false;\n\n        visited[x][y] = true;\n        bool ret = dfs(board, word, index + 1, x - 1, y, visited) ||\n                    dfs(board, word, index + 1, x + 1, y, visited) ||\n                    dfs(board, word, index + 1, x, y + 1, visited) ||\n                    dfs(board, word, index + 1, x, y - 1, visited);\n        visited[x][y] = false;\n        return ret;\n    }\n};\n\n// Method 2\nclass Solution {\n    bool find(vector&lt;vector&lt;char&gt;&gt;&amp; board, std::string const&amp; word, int row, int col, std::string prefix) {\n        if (row &lt; 0 || row &gt;= board.size())\n            return false;\n\n        if (col &lt; 0 || col &gt;= board[0].size())\n            return false;\n\n        constexpr char VISITED_CELL = '#';\n\n        char&amp; cell = board[row][col];\n\n        char const ch = cell;\n\n        if (ch == VISITED_CELL)\n            return false;\n\n        if (word.compare(0, prefix.length(), prefix) != 0)\n            return false;\n\n        prefix.push_back(ch);\n\n        if (prefix.length() == word.length())\n            return prefix == word;\n\n        cell = VISITED_CELL;\n\n        if (find(board, word, row - 1, col, prefix)) return true;\n        if (find(board, word, row, col + 1, prefix)) return true;\n        if (find(board, word, row + 1, col, prefix)) return true;\n        if (find(board, word, row, col - 1, prefix)) return true;\n\n        cell = ch;\n\n        prefix.pop_back();\n\n        return false;\n    }\n\npublic:\n\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {\n        if (word.empty())\n            return true;\n\n        std::unordered_map&lt;char, int&gt; charCount;\n        for (char ch : word)\n            charCount[ch]++;\n\n        char const firstChar = word.front();\n        char const lastChar = word.back();\n\n        std::vector&lt;std::pair&lt;int, int&gt;&gt; startingLocations, startingLocationsReverse;\n        for (int row = 0; row &lt; board.size(); ++row) {\n            for (int col = 0; col &lt; board[0].size(); ++col) {\n                char const ch = board[row][col];\n\n                auto it = charCount.find(ch);\n                if (it != std::end(charCount))\n                    it-&gt;second--;\n\n                if (firstChar == ch)\n                    startingLocations.emplace_back(row, col);\n\n                if (lastChar == ch)\n                    startingLocationsReverse.emplace_back(row, col);\n            }\n        }\n\n        for (auto const&amp; [ch, count] : charCount) {\n            if (count &gt; 0)\n                return false;\n        }\n\n        auto&amp; locations = startingLocations;\n\n        if (startingLocationsReverse.size() &lt; startingLocations.size()) {\n            std::reverse(std::begin(word), std::end(word));\n            locations = startingLocationsReverse;\n        }\n\n        for (auto const&amp; [row, col] : locations) {\n            if (find(board, word, row, col, \"\"))\n                return true;\n        }\n\n        return false;\n    }\n};\n\n",
        "content": "&lt;-M 79&gt; Word Search\n\n// Method 1\nclass Solution {\npublic:\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {\n        const int m = board.size();\n        const int n = board[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));\n\n        for(int i = 0; i &lt; m; i++)\n            for(int j = 0; j &lt; n; j++)\n                if(dfs(board, word, 0, i, j, visited))\n                    return true;\n        return false;\n    }\nprivate:\n    bool dfs(const vector&lt;vector&lt;char&gt;&gt;&amp; board, const string word,\n             int index, int x, int y, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) {\n        if(index == word.size())\n            return true;\n        if(x &lt; 0 || y &lt; 0 || x &gt;= board.size() || y &gt;= board[0].size())\n            return false;\n\n        if(visited[x][y])\n            return false;\n\n        if(board[x][y] != word[index])\n            return false;\n\n        visited[x][y] = true;\n        bool ret = dfs(board, word, index + 1, x - 1, y, visited) ||\n                    dfs(board, word, index + 1, x + 1, y, visited) ||\n                    dfs(board, word, index + 1, x, y + 1, visited) ||\n                    dfs(board, word, index + 1, x, y - 1, visited);\n        visited[x][y] = false;\n        return ret;\n    }\n};\n\n// Method 2\nclass Solution {\n    bool find(vector&lt;vector&lt;char&gt;&gt;&amp; board, std::string const&amp; word, int row, int col, std::string prefix) {\n        if (row &lt; 0 || row &gt;= board.size())\n            return false;\n\n        if (col &lt; 0 || col &gt;= board[0].size())\n            return false;\n\n        constexpr char VISITED_CELL = '#';\n\n        char&amp; cell = board[row][col];\n\n        char const ch = cell;\n\n        if (ch == VISITED_CELL)\n            return false;\n\n        if (word.compare(0, prefix.length(), prefix) != 0)\n            return false;\n\n        prefix.push_back(ch);\n\n        if (prefix.length() == word.length())\n            return prefix == word;\n\n        cell = VISITED_CELL;\n\n        if (find(board, word, row - 1, col, prefix)) return true;\n        if (find(board, word, row, col + 1, prefix)) return true;\n        if (find(board, word, row + 1, col, prefix)) return true;\n        if (find(board, word, row, col - 1, prefix)) return true;\n\n        cell = ch;\n\n        prefix.pop_back();\n\n        return false;\n    }\n\npublic:\n\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {\n        if (word.empty())\n            return true;\n\n        std::unordered_map&lt;char, int&gt; charCount;\n        for (char ch : word)\n            charCount[ch]++;\n\n        char const firstChar = word.front();\n        char const lastChar = word.back();\n\n        std::vector&lt;std::pair&lt;int, int&gt;&gt; startingLocations, startingLocationsReverse;\n        for (int row = 0; row &lt; board.size(); ++row) {\n            for (int col = 0; col &lt; board[0].size(); ++col) {\n                char const ch = board[row][col];\n\n                auto it = charCount.find(ch);\n                if (it != std::end(charCount))\n                    it-&gt;second--;\n\n                if (firstChar == ch)\n                    startingLocations.emplace_back(row, col);\n\n                if (lastChar == ch)\n                    startingLocationsReverse.emplace_back(row, col);\n            }\n        }\n\n        for (auto const&amp; [ch, count] : charCount) {\n            if (count &gt; 0)\n                return false;\n        }\n\n        auto&amp; locations = startingLocations;\n\n        if (startingLocationsReverse.size() &lt; startingLocations.size()) {\n            std::reverse(std::begin(word), std::end(word));\n            locations = startingLocationsReverse;\n        }\n\n        for (auto const&amp; [row, col] : locations) {\n            if (find(board, word, row, col, \"\"))\n                return true;\n        }\n\n        return false;\n    }\n};\n\n",
        "url": "/2022/06/24/79-Word-Search/"
      },
    
      {
        "title": "Remove Duplicates from Sorted Array II",
        "excerpt": "&lt;-M 80&gt; Remove Duplicates from Sorted Array II\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() &lt;= 2)\n            return nums.size();\n        int index = 2;\n        for(int i = 2; i &lt; nums.size(); i++) {\n            if(nums[i] != nums[index - 2])\n                nums[index++] = nums[i];\n        }\n        return index;\n    }\n};\n\n",
        "content": "&lt;-M 80&gt; Remove Duplicates from Sorted Array II\n\nclass Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        if(nums.size() &lt;= 2)\n            return nums.size();\n        int index = 2;\n        for(int i = 2; i &lt; nums.size(); i++) {\n            if(nums[i] != nums[index - 2])\n                nums[index++] = nums[i];\n        }\n        return index;\n    }\n};\n\n",
        "url": "/2022/06/24/80-Remove-Duplicates-from-Sorted-Array-II/"
      },
    
      {
        "title": "Search in Rotated Sorted Array II",
        "excerpt": "&lt;-M 81&gt; Search in Rotated Sorted Array II\n\nclass Solution {\npublic:\n    bool search(vector&lt;int&gt;&amp; nums, int target) {\n        int first = 0, last = nums.size();\n          while (first != last) {\n            const int mid = first  + (last - first) / 2;\n            if (nums[mid] == target)\n                return true;\n            if (nums[first] &lt; nums[mid]) {\n                if (nums[first] &lt;= target &amp;&amp; target &lt; nums[mid])\n                    last = mid;\n                else\n                    first = mid + 1;\n            } else if (nums[first] &gt; nums[mid]){\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1])\n                    first = mid + 1;\n                else\n                    last = mid;\n            }\n            else {\n                  first++;\n            }\n        }\n        return false;\n    }\n};\n\n",
        "content": "&lt;-M 81&gt; Search in Rotated Sorted Array II\n\nclass Solution {\npublic:\n    bool search(vector&lt;int&gt;&amp; nums, int target) {\n        int first = 0, last = nums.size();\n          while (first != last) {\n            const int mid = first  + (last - first) / 2;\n            if (nums[mid] == target)\n                return true;\n            if (nums[first] &lt; nums[mid]) {\n                if (nums[first] &lt;= target &amp;&amp; target &lt; nums[mid])\n                    last = mid;\n                else\n                    first = mid + 1;\n            } else if (nums[first] &gt; nums[mid]){\n                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1])\n                    first = mid + 1;\n                else\n                    last = mid;\n            }\n            else {\n                  first++;\n            }\n        }\n        return false;\n    }\n};\n\n",
        "url": "/2022/06/24/81-Search-in-Rotated-Sorted-Array-II/"
      },
    
      {
        "title": "Remove Duplicates from Sorted List II",
        "excerpt": "&lt;-M 82&gt; Remove Duplicates from Sorted List II\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n // Method 1\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head || !head-&gt;next)\n            return head;\n        ListNode *p = head-&gt;next;\n        if(head-&gt;val == p-&gt;val) {\n            while(p &amp;&amp; head-&gt;val == p-&gt;val) {\n                ListNode *temp = p;\n                p = p-&gt;next;\n                delete temp;\n            }\n            delete head;\n            return deleteDuplicates(p);\n        } else {\n            head-&gt;next = deleteDuplicates(head-&gt;next);\n            return head;\n        }\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode*prev = new ListNode(0);\n        prev-&gt;next = head;\n        ListNode*dummy = prev;\n        ListNode*curr = head;\n        while(curr != NULL) {\n            if( curr-&gt;next != NULL &amp;&amp;curr-&gt;next-&gt;val == curr-&gt;val) {\n                while( curr-&gt;next != NULL &amp;&amp; curr-&gt;next-&gt;val == curr-&gt;val)\n                    curr = curr-&gt;next;\n                prev-&gt;next = curr-&gt;next;\n            }\n            else {\n                prev = prev-&gt;next;\n            }\n\n            curr = curr-&gt;next;\n        }\n        return dummy-&gt;next;;\n    }\n};\n\n",
        "content": "&lt;-M 82&gt; Remove Duplicates from Sorted List II\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n // Method 1\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head || !head-&gt;next)\n            return head;\n        ListNode *p = head-&gt;next;\n        if(head-&gt;val == p-&gt;val) {\n            while(p &amp;&amp; head-&gt;val == p-&gt;val) {\n                ListNode *temp = p;\n                p = p-&gt;next;\n                delete temp;\n            }\n            delete head;\n            return deleteDuplicates(p);\n        } else {\n            head-&gt;next = deleteDuplicates(head-&gt;next);\n            return head;\n        }\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode*prev = new ListNode(0);\n        prev-&gt;next = head;\n        ListNode*dummy = prev;\n        ListNode*curr = head;\n        while(curr != NULL) {\n            if( curr-&gt;next != NULL &amp;&amp;curr-&gt;next-&gt;val == curr-&gt;val) {\n                while( curr-&gt;next != NULL &amp;&amp; curr-&gt;next-&gt;val == curr-&gt;val)\n                    curr = curr-&gt;next;\n                prev-&gt;next = curr-&gt;next;\n            }\n            else {\n                prev = prev-&gt;next;\n            }\n\n            curr = curr-&gt;next;\n        }\n        return dummy-&gt;next;;\n    }\n};\n\n",
        "url": "/2022/06/24/82-Remove-Duplicates-from-Sorted-List-II/"
      },
    
      {
        "title": "Largest Rectangle in Histogram",
        "excerpt": "&lt;-H 84&gt; Largest Rectangle in Histogram\n\nclass Solution {\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {\n        stack&lt;int&gt; s;\n        heights.push_back(0);\n        int result = 0;\n        for(int i = 0; i != heights.size(); ) {\n            if(s.empty() || heights[i] &gt; heights[s.top()])\n                s.push(i++);\n            else {\n                int temp = s.top();\n                s.pop();\n                result = max(result, heights[temp] * (s.empty() ? i : i - s.top() - 1));\n            }\n        }\n        return result;\n    }\n};\n\n",
        "content": "&lt;-H 84&gt; Largest Rectangle in Histogram\n\nclass Solution {\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {\n        stack&lt;int&gt; s;\n        heights.push_back(0);\n        int result = 0;\n        for(int i = 0; i != heights.size(); ) {\n            if(s.empty() || heights[i] &gt; heights[s.top()])\n                s.push(i++);\n            else {\n                int temp = s.top();\n                s.pop();\n                result = max(result, heights[temp] * (s.empty() ? i : i - s.top() - 1));\n            }\n        }\n        return result;\n    }\n};\n\n",
        "url": "/2022/06/24/84-Largest-Rectangle-in-Histogram/"
      },
    
      {
        "title": "Maximal Rectangle",
        "excerpt": "&lt;-H 85&gt; Maximal Rectangle\n\nclass Solution {\npublic:\n    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {\n        if(matrix.empty())\n            return 0;\n\n        const int m = matrix.size();\n        const int n = matrix[0].size();\n\n        vector&lt;int&gt; H(n, 0);\n        vector&lt;int&gt; L(n, 0);\n        vector&lt;int&gt; R(n, n);\n\n        int ret = 0;\n\n        for(int i = 0; i &lt; m; i++) {\n            int left = 0, right = n;\n            for(int j = 0; j &lt; n; j++) {\n                if(matrix[i][j] == '1') {\n                    H[j]++;\n                    L[j] = max(L[j], left);\n                }\n                else {\n                    left = j + 1;\n                    H[j] = 0;\n                    L[j] = 0;\n                    R[j] = n;\n                }\n            }\n            for(int j = n - 1; j &gt;= 0; j--) {\n                if(matrix[i][j] == '1') {\n                    R[j] = min(R[j], right);\n                    ret = max(ret, H[j] * (R[j] - L[j]));\n                }\n                else{\n                    right = j;\n                }\n            }\n        }\n\n        return ret;\n    }\n};\n\n",
        "content": "&lt;-H 85&gt; Maximal Rectangle\n\nclass Solution {\npublic:\n    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {\n        if(matrix.empty())\n            return 0;\n\n        const int m = matrix.size();\n        const int n = matrix[0].size();\n\n        vector&lt;int&gt; H(n, 0);\n        vector&lt;int&gt; L(n, 0);\n        vector&lt;int&gt; R(n, n);\n\n        int ret = 0;\n\n        for(int i = 0; i &lt; m; i++) {\n            int left = 0, right = n;\n            for(int j = 0; j &lt; n; j++) {\n                if(matrix[i][j] == '1') {\n                    H[j]++;\n                    L[j] = max(L[j], left);\n                }\n                else {\n                    left = j + 1;\n                    H[j] = 0;\n                    L[j] = 0;\n                    R[j] = n;\n                }\n            }\n            for(int j = n - 1; j &gt;= 0; j--) {\n                if(matrix[i][j] == '1') {\n                    R[j] = min(R[j], right);\n                    ret = max(ret, H[j] * (R[j] - L[j]));\n                }\n                else{\n                    right = j;\n                }\n            }\n        }\n\n        return ret;\n    }\n};\n\n",
        "url": "/2022/06/24/85-Maximal-Rectangle/"
      },
    
      {
        "title": "Partition List",
        "excerpt": "&lt;-M 86&gt; Partition List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n// Method 1\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode left_temp(-1);\n        ListNode right_temp(-1);\n\n        ListNode* left_cur = &amp;left_temp;\n        ListNode* right_cur = &amp;right_temp;\n\n        for(ListNode *cur = head; cur; cur = cur-&gt;next) {\n            if(cur-&gt;val &lt; x) {\n                left_cur-&gt;next = cur;\n                left_cur = cur;\n            } else {\n                right_cur-&gt;next = cur;\n                right_cur = cur;\n            }\n        }\n        left_cur-&gt;next = right_temp.next;\n        right_cur-&gt;next = nullptr;\n\n        return left_temp.next;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        queue&lt;int&gt; q1;\n        queue&lt;int&gt; q2;\n        ListNode* curr = head;\n        int count = 0;\n\n        while(curr != NULL) {\n            if(curr-&gt;val &lt; x)\n                q1.push(curr-&gt;val);\n            else\n                q2.push(curr-&gt;val);\n            curr = curr-&gt;next;\n            count++;\n        }\n        curr=head;\n        while(!q1.empty()) {\n            curr-&gt;val = q1.front();\n            q1.pop();\n            curr = curr-&gt;next;\n        }\n\n        while(!q2.empty()) {\n            curr-&gt;val = q2.front();\n            q2.pop();\n            curr = curr-&gt;next;\n        }\n        return head;\n    }\n};\n\n",
        "content": "&lt;-M 86&gt; Partition List\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n// Method 1\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode left_temp(-1);\n        ListNode right_temp(-1);\n\n        ListNode* left_cur = &amp;left_temp;\n        ListNode* right_cur = &amp;right_temp;\n\n        for(ListNode *cur = head; cur; cur = cur-&gt;next) {\n            if(cur-&gt;val &lt; x) {\n                left_cur-&gt;next = cur;\n                left_cur = cur;\n            } else {\n                right_cur-&gt;next = cur;\n                right_cur = cur;\n            }\n        }\n        left_cur-&gt;next = right_temp.next;\n        right_cur-&gt;next = nullptr;\n\n        return left_temp.next;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        queue&lt;int&gt; q1;\n        queue&lt;int&gt; q2;\n        ListNode* curr = head;\n        int count = 0;\n\n        while(curr != NULL) {\n            if(curr-&gt;val &lt; x)\n                q1.push(curr-&gt;val);\n            else\n                q2.push(curr-&gt;val);\n            curr = curr-&gt;next;\n            count++;\n        }\n        curr=head;\n        while(!q1.empty()) {\n            curr-&gt;val = q1.front();\n            q1.pop();\n            curr = curr-&gt;next;\n        }\n\n        while(!q2.empty()) {\n            curr-&gt;val = q2.front();\n            q2.pop();\n            curr = curr-&gt;next;\n        }\n        return head;\n    }\n};\n\n",
        "url": "/2022/06/24/86-Partition-List/"
      },
    
      {
        "title": "Scramble String",
        "excerpt": "&lt;-H 87&gt; Scramble String\n\n// Method 1\nclass Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        const int n = s1.size();\n        if(s1.size() != s2.size())\n            return false;\n\n        bool f[n + 1][n][n];\n        fill_n(&amp;f[0][0][0], (n + 1) * n * n, false);\n\n        for(int i = 0; i &lt; n; i++)\n            for(int j = 0; j &lt; n; j++)\n                f[1][i][j] = s1[i] == s2[j];\n\n        for(int k = 1; k &lt;= n; k++)\n            for(int i = 0; i + k &lt;= n; i++)\n                for(int j = 0; j + k &lt;= n; j++)\n                    for(int h = 1; h &lt; k; h++)\n                        if((f[h][i][j] &amp;&amp; f[k - h][i + h][j + h]) ||\n                            (f[h][i][j + k - h] &amp;&amp; f[k - h][i + h][j])){\n                                f[k][i][j] = true;\n                            break;\n                        }\n        return f[n][0][0];\n\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        int sum1 = 0, sum2 = 0;\n        int n = s1.size();\n        if (n == 1) return s1[0] == s2[0];\n        int p1 = -1, p2 = -1;\n        for (int i = 0; i &lt; n; i++) {\n            sum1 += s1[i] * s1[i] - s2[i] * s2[i];\n            sum2 += s1[i] * s1[i] - s2[n - 1 - i] * s2[n - 1 - i];\n            if (sum1 == 0 &amp;&amp; i != n-1) p1 = i;\n            if (sum2 == 0 &amp;&amp; i != n-1) p2 = i;\n        }\n        int a = 0, b = 0;\n        if (p1 != -1) a = isScramble(s1.substr(0, p1 + 1), s2.substr(0, p1 + 1)) &amp;&amp; isScramble(s1.substr(p1 + 1, n - p1 - 1 ), s2.substr(p1 + 1, n - p1 - 1));\n        if (p2 != -1) b = isScramble(s1.substr(0, p2 + 1), s2.substr(n - p2 - 1, p2 + 1)) &amp;&amp; isScramble(s1.substr(p2 + 1, n - p2 - 1), s2.substr(0, n - p2 - 1));\n        return a || b;\n    }\n};\n\n",
        "content": "&lt;-H 87&gt; Scramble String\n\n// Method 1\nclass Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        const int n = s1.size();\n        if(s1.size() != s2.size())\n            return false;\n\n        bool f[n + 1][n][n];\n        fill_n(&amp;f[0][0][0], (n + 1) * n * n, false);\n\n        for(int i = 0; i &lt; n; i++)\n            for(int j = 0; j &lt; n; j++)\n                f[1][i][j] = s1[i] == s2[j];\n\n        for(int k = 1; k &lt;= n; k++)\n            for(int i = 0; i + k &lt;= n; i++)\n                for(int j = 0; j + k &lt;= n; j++)\n                    for(int h = 1; h &lt; k; h++)\n                        if((f[h][i][j] &amp;&amp; f[k - h][i + h][j + h]) ||\n                            (f[h][i][j + k - h] &amp;&amp; f[k - h][i + h][j])){\n                                f[k][i][j] = true;\n                            break;\n                        }\n        return f[n][0][0];\n\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        int sum1 = 0, sum2 = 0;\n        int n = s1.size();\n        if (n == 1) return s1[0] == s2[0];\n        int p1 = -1, p2 = -1;\n        for (int i = 0; i &lt; n; i++) {\n            sum1 += s1[i] * s1[i] - s2[i] * s2[i];\n            sum2 += s1[i] * s1[i] - s2[n - 1 - i] * s2[n - 1 - i];\n            if (sum1 == 0 &amp;&amp; i != n-1) p1 = i;\n            if (sum2 == 0 &amp;&amp; i != n-1) p2 = i;\n        }\n        int a = 0, b = 0;\n        if (p1 != -1) a = isScramble(s1.substr(0, p1 + 1), s2.substr(0, p1 + 1)) &amp;&amp; isScramble(s1.substr(p1 + 1, n - p1 - 1 ), s2.substr(p1 + 1, n - p1 - 1));\n        if (p2 != -1) b = isScramble(s1.substr(0, p2 + 1), s2.substr(n - p2 - 1, p2 + 1)) &amp;&amp; isScramble(s1.substr(p2 + 1, n - p2 - 1), s2.substr(0, n - p2 - 1));\n        return a || b;\n    }\n};\n\n",
        "url": "/2022/06/24/87-Scramble-String/"
      },
    
      {
        "title": "Construct Binary Tree from Preorder and Postorder Traversal",
        "excerpt": "&lt;-M 889&gt; Construct Binary Tree from Preorder and Postorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post) {\n        vector&lt;int&gt; pos(pre.size()+1);\n        for (int i = 0; i &lt; post.size(); i++) pos[post[i]] = i;\n\n        TreeNode* root = nullptr;\n        int i = 0;\n        root = build(root, pre, pos, i);\n\n        return root;\n    }\n\n    TreeNode* build(TreeNode* root, vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; pos, int&amp; i) {\n        if (i &lt; pre.size()) root = new TreeNode(pre[i]);\n        if (i == pre.size() - 1) {\n            i++;\n            return root;\n        }\n        int local = i;\n        if (i &lt; pre.size() &amp;&amp; pos[pre[local]] &gt; pos[pre[i+1]])\n            root-&gt;left = build(root-&gt;left, pre, pos, ++i);\n        if (i &lt; pre.size() &amp;&amp; pos[pre[local]] &gt; pos[pre[i+1]])\n            root-&gt;right = build(root-&gt;right, pre, pos, ++i);\n\n        return root;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    unordered_map&lt;int, int&gt; m; // value-&gt;index\n    TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post) {\n        int len = post.size();\n        for (int i = 0; i &lt; len; i++) m[post[i]] = i;\n        return construct(pre, post, 0, len - 1, 0, len - 1);\n    }\n\n    TreeNode* construct(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post, int a, int b, int c, int d) {\n        TreeNode* n = new TreeNode(pre[a]);\n        if (a == b) return n;\n        int t = pre[a + 1];\n        int idx = m[t];\n        int len = idx - c + 1;\n        n-&gt;left = construct(pre, post, a + 1, a + len, c, c + len - 1);\n        if (idx + 1 == d) return n;\n        n-&gt;right = construct(pre, post, a + len + 1, b, idx + 1, d - 1);\n        return n;\n    }\n};\n\n",
        "content": "&lt;-M 889&gt; Construct Binary Tree from Preorder and Postorder Traversal\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post) {\n        vector&lt;int&gt; pos(pre.size()+1);\n        for (int i = 0; i &lt; post.size(); i++) pos[post[i]] = i;\n\n        TreeNode* root = nullptr;\n        int i = 0;\n        root = build(root, pre, pos, i);\n\n        return root;\n    }\n\n    TreeNode* build(TreeNode* root, vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; pos, int&amp; i) {\n        if (i &lt; pre.size()) root = new TreeNode(pre[i]);\n        if (i == pre.size() - 1) {\n            i++;\n            return root;\n        }\n        int local = i;\n        if (i &lt; pre.size() &amp;&amp; pos[pre[local]] &gt; pos[pre[i+1]])\n            root-&gt;left = build(root-&gt;left, pre, pos, ++i);\n        if (i &lt; pre.size() &amp;&amp; pos[pre[local]] &gt; pos[pre[i+1]])\n            root-&gt;right = build(root-&gt;right, pre, pos, ++i);\n\n        return root;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    unordered_map&lt;int, int&gt; m; // value-&gt;index\n    TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post) {\n        int len = post.size();\n        for (int i = 0; i &lt; len; i++) m[post[i]] = i;\n        return construct(pre, post, 0, len - 1, 0, len - 1);\n    }\n\n    TreeNode* construct(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post, int a, int b, int c, int d) {\n        TreeNode* n = new TreeNode(pre[a]);\n        if (a == b) return n;\n        int t = pre[a + 1];\n        int idx = m[t];\n        int len = idx - c + 1;\n        n-&gt;left = construct(pre, post, a + 1, a + len, c, c + len - 1);\n        if (idx + 1 == d) return n;\n        n-&gt;right = construct(pre, post, a + len + 1, b, idx + 1, d - 1);\n        return n;\n    }\n};\n\n",
        "url": "/2022/06/24/889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal/"
      },
    
      {
        "title": "Gray Code",
        "excerpt": "&lt;-M 89&gt; Gray Code\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; grayCode(int n) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i &lt; (1 &lt;&lt; n); i++)\n            ans.push_back(i ^ (i &gt;&gt; 1));\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; grayCode(int n) {\n        vector&lt;int&gt; prev;\n        int i, j, b;\n        prev.push_back(0);\n        prev.push_back(1);\n        for(i = 1; i &lt; n; i ++){\n            b = 1 &lt;&lt; i;\n            for(j = b - 1; j &gt;= 0; j --){\n                prev.push_back(b | prev[j]);\n            }\n        }\n        return prev;\n    }\n};\n\n",
        "content": "&lt;-M 89&gt; Gray Code\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;int&gt; grayCode(int n) {\n        vector&lt;int&gt; ans;\n        for(int i = 0; i &lt; (1 &lt;&lt; n); i++)\n            ans.push_back(i ^ (i &gt;&gt; 1));\n        return ans;\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    vector&lt;int&gt; grayCode(int n) {\n        vector&lt;int&gt; prev;\n        int i, j, b;\n        prev.push_back(0);\n        prev.push_back(1);\n        for(i = 1; i &lt; n; i ++){\n            b = 1 &lt;&lt; i;\n            for(j = b - 1; j &gt;= 0; j --){\n                prev.push_back(b | prev[j]);\n            }\n        }\n        return prev;\n    }\n};\n\n",
        "url": "/2022/06/24/89-Gray-Code/"
      },
    
      {
        "title": "Subsets II",
        "excerpt": "&lt;-M 90&gt; Subsets II\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; result(1);\n        int previous_size = 0;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            int size = result.size();\n            for(int j = 0; j &lt; size; j++) {\n                if(i == 0 || nums[i] != nums[i - 1] || j &gt;= previous_size) {\n                    result.push_back(result[j]);\n                    result.back().push_back(nums[i]);\n                }\n            }\n            previous_size = size;\n        }\n        return result;\n    }\n};\n\n// Method 2\nclass Solution {\nprivate:\n    void dfs(const vector&lt;int&gt; &amp;nums, vector&lt;int&gt;::iterator start, vector&lt;int&gt; &amp;path,\n           vector&lt;vector&lt;int&gt;&gt; &amp;result) {\n        result.push_back(path);\n\n        for(auto i = start; i &lt; nums.end(); i++) {\n            if(i != start &amp;&amp; *i == *(i - 1))\n                continue;\n            path.push_back(*i);\n            dfs(nums, i + 1, path, result);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;int&gt; path;\n        dfs(nums, nums.begin(), path, result);\n        return result;\n    }\n};\n\n",
        "content": "&lt;-M 90&gt; Subsets II\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; result(1);\n        int previous_size = 0;\n        for(int i = 0; i &lt; nums.size(); i++) {\n            int size = result.size();\n            for(int j = 0; j &lt; size; j++) {\n                if(i == 0 || nums[i] != nums[i - 1] || j &gt;= previous_size) {\n                    result.push_back(result[j]);\n                    result.back().push_back(nums[i]);\n                }\n            }\n            previous_size = size;\n        }\n        return result;\n    }\n};\n\n// Method 2\nclass Solution {\nprivate:\n    void dfs(const vector&lt;int&gt; &amp;nums, vector&lt;int&gt;::iterator start, vector&lt;int&gt; &amp;path,\n           vector&lt;vector&lt;int&gt;&gt; &amp;result) {\n        result.push_back(path);\n\n        for(auto i = start; i &lt; nums.end(); i++) {\n            if(i != start &amp;&amp; *i == *(i - 1))\n                continue;\n            path.push_back(*i);\n            dfs(nums, i + 1, path, result);\n            path.pop_back();\n        }\n    }\npublic:\n    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {\n        sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;int&gt; path;\n        dfs(nums, nums.begin(), path, result);\n        return result;\n    }\n};\n\n",
        "url": "/2022/06/24/90-Subsets-II/"
      },
    
      {
        "title": "Reverse Linked List II",
        "excerpt": "&lt;-M 92&gt; Reverse Linked List II\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        ListNode temp(-1);\n        temp.next = head;\n\n        ListNode *prev = &amp;temp;\n\n        for(int i = 0; i &lt; left - 1; i++)\n            prev = prev-&gt;next;\n        ListNode *const head_temp = prev;\n\n        prev = head_temp-&gt;next;\n\n        ListNode *cur = prev-&gt;next;\n\n        for(int i = left; i &lt; right; i++) {\n            prev-&gt;next = cur-&gt;next;\n            cur-&gt;next = head_temp-&gt;next;\n            head_temp-&gt;next = cur;\n            cur = prev-&gt;next;\n        }\n        return temp.next;\n    }\n};\n\n",
        "content": "&lt;-M 92&gt; Reverse Linked List II\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        ListNode temp(-1);\n        temp.next = head;\n\n        ListNode *prev = &amp;temp;\n\n        for(int i = 0; i &lt; left - 1; i++)\n            prev = prev-&gt;next;\n        ListNode *const head_temp = prev;\n\n        prev = head_temp-&gt;next;\n\n        ListNode *cur = prev-&gt;next;\n\n        for(int i = left; i &lt; right; i++) {\n            prev-&gt;next = cur-&gt;next;\n            cur-&gt;next = head_temp-&gt;next;\n            head_temp-&gt;next = cur;\n            cur = prev-&gt;next;\n        }\n        return temp.next;\n    }\n};\n\n",
        "url": "/2022/06/24/92-Reverse-Linked-List-II/"
      },
    
      {
        "title": "Restore IP Addresses",
        "excerpt": "&lt;-M 93&gt; Restore IP Addresses\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; restoreIpAddresses(string s) {\n        vector&lt;string&gt; result;\n        string ip;\n        dfs(s,0, 0, ip, result);\n        return result;\n    }\nprivate:\n    void dfs(string &amp;s, int start, int step, string ip, vector&lt;string&gt;&amp; result) {\n        if(start == s.size() &amp;&amp; step == 4) {\n            ip.resize(ip.size() - 1);\n            result.push_back(ip);\n            return;\n        }\n        if(s.size() - start &gt; (4 - step) * 3)\n            return;\n        if(s.size() - start &lt; (4 - step))\n            return;\n\n        int num = 0;\n        for(int i = start; i &lt; start + 3; i++) {\n            num = num * 10 + (s[i] - '0');\n            if(num &lt;= 255) {\n                ip += s[i];\n                dfs(s, i + 1, step + 1, ip + '.', result);\n            }\n            if(num == 0)\n                break;\n        }\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void solve(string &amp;s, vector&lt;string&gt;&amp;ans, int d, int i, string a){\n     if(i == s.size() &amp;&amp; d == 4){\n          ans.push_back(a.substr(0,a.length() - 1));\n          return;\n      }\n      if(d &gt; 4 || (d == 4 &amp;&amp; i &lt; s.size())) {\n          return;\n      }\n      int j = i;\n      string val = \"\";\n      while(j &lt; s.size() &amp;&amp; j &lt; i + 3) {\n          val+=s[j];\n          if(stoi(val) &lt; 256 &amp;&amp; (j == i || s[i] != '0')){\n              solve(s, ans, d + 1, j + 1, a + val + \".\");\n          }\n          j++;\n      }\n  }\n    vector&lt;string&gt; restoreIpAddresses(string s) {\n        int n = s.size();\n        vector&lt;string&gt; ans;\n        if(n &lt; 4) {\n            return ans;\n        }\n        if(n == 4){\n            string a = \"\";\n            for(int i = 0; i &lt; n - 1; i++){\n                a += s[i];\n                a += '.';\n            }\n            a += s[n-1];\n            ans.push_back(a);\n            return ans;\n        }\n        if(s.length() &gt; 12){\n            return ans;\n        }\n        string a = \"\";\n        solve(s, ans, 0, 0, a);\n        return ans;\n    }\n};\n\n",
        "content": "&lt;-M 93&gt; Restore IP Addresses\n\n// Method 1\nclass Solution {\npublic:\n    vector&lt;string&gt; restoreIpAddresses(string s) {\n        vector&lt;string&gt; result;\n        string ip;\n        dfs(s,0, 0, ip, result);\n        return result;\n    }\nprivate:\n    void dfs(string &amp;s, int start, int step, string ip, vector&lt;string&gt;&amp; result) {\n        if(start == s.size() &amp;&amp; step == 4) {\n            ip.resize(ip.size() - 1);\n            result.push_back(ip);\n            return;\n        }\n        if(s.size() - start &gt; (4 - step) * 3)\n            return;\n        if(s.size() - start &lt; (4 - step))\n            return;\n\n        int num = 0;\n        for(int i = start; i &lt; start + 3; i++) {\n            num = num * 10 + (s[i] - '0');\n            if(num &lt;= 255) {\n                ip += s[i];\n                dfs(s, i + 1, step + 1, ip + '.', result);\n            }\n            if(num == 0)\n                break;\n        }\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n    void solve(string &amp;s, vector&lt;string&gt;&amp;ans, int d, int i, string a){\n     if(i == s.size() &amp;&amp; d == 4){\n          ans.push_back(a.substr(0,a.length() - 1));\n          return;\n      }\n      if(d &gt; 4 || (d == 4 &amp;&amp; i &lt; s.size())) {\n          return;\n      }\n      int j = i;\n      string val = \"\";\n      while(j &lt; s.size() &amp;&amp; j &lt; i + 3) {\n          val+=s[j];\n          if(stoi(val) &lt; 256 &amp;&amp; (j == i || s[i] != '0')){\n              solve(s, ans, d + 1, j + 1, a + val + \".\");\n          }\n          j++;\n      }\n  }\n    vector&lt;string&gt; restoreIpAddresses(string s) {\n        int n = s.size();\n        vector&lt;string&gt; ans;\n        if(n &lt; 4) {\n            return ans;\n        }\n        if(n == 4){\n            string a = \"\";\n            for(int i = 0; i &lt; n - 1; i++){\n                a += s[i];\n                a += '.';\n            }\n            a += s[n-1];\n            ans.push_back(a);\n            return ans;\n        }\n        if(s.length() &gt; 12){\n            return ans;\n        }\n        string a = \"\";\n        solve(s, ans, 0, 0, a);\n        return ans;\n    }\n};\n\n",
        "url": "/2022/06/24/93-Restore-IP-Addresses/"
      },
    
      {
        "title": "Unique Binary Search Trees II",
        "excerpt": "&lt;-M 95&gt; Unique Binary Search Trees II\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;TreeNode*&gt; generateTrees(int n) {\n        if(n == 0)\n            return generate(1, 0);\n        return generate(1, n);\n    }\n\n    vector&lt;TreeNode *&gt; generate(int start, int end) {\n        vector&lt;TreeNode *&gt; subTree;\n        if(start &gt; end) {\n            subTree.push_back(nullptr);\n            return subTree;\n        }\n\n        for(int i = start; i &lt;= end; i++) {\n            vector&lt;TreeNode*&gt; leftSubs = generate(start, i - 1);\n            vector&lt;TreeNode*&gt; rightSubs = generate(i + 1, end);\n            for(auto j : leftSubs)\n                for(auto k : rightSubs) {\n                    TreeNode *node = new TreeNode(i);\n                    node-&gt;left = j;\n                    node-&gt;right = k;\n                    subTree.push_back(node);\n                }\n        }\n        return subTree;\n    }\n};\n\n",
        "content": "&lt;-M 95&gt; Unique Binary Search Trees II\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector&lt;TreeNode*&gt; generateTrees(int n) {\n        if(n == 0)\n            return generate(1, 0);\n        return generate(1, n);\n    }\n\n    vector&lt;TreeNode *&gt; generate(int start, int end) {\n        vector&lt;TreeNode *&gt; subTree;\n        if(start &gt; end) {\n            subTree.push_back(nullptr);\n            return subTree;\n        }\n\n        for(int i = start; i &lt;= end; i++) {\n            vector&lt;TreeNode*&gt; leftSubs = generate(start, i - 1);\n            vector&lt;TreeNode*&gt; rightSubs = generate(i + 1, end);\n            for(auto j : leftSubs)\n                for(auto k : rightSubs) {\n                    TreeNode *node = new TreeNode(i);\n                    node-&gt;left = j;\n                    node-&gt;right = k;\n                    subTree.push_back(node);\n                }\n        }\n        return subTree;\n    }\n};\n\n",
        "url": "/2022/06/24/95-Unique-Binary-Search-Trees-II/"
      },
    
      {
        "title": "Unique Binary Search Trees",
        "excerpt": "&lt;-M 96&gt; Unique Binary Search Trees\n\nclass Solution {\npublic:\n    int numTrees(int n) {\n        vector&lt;int&gt; check(n + 1, 0);\n\n        check[0] = 1;\n        check[1] = 1;\n        for(int i = 2; i &lt;= n; i++)\n            for(int k = 1; k &lt;= i; k++)\n                check[i] += check[k - 1] * check[i - k];\n        return check[n];\n    }\n};\n\n",
        "content": "&lt;-M 96&gt; Unique Binary Search Trees\n\nclass Solution {\npublic:\n    int numTrees(int n) {\n        vector&lt;int&gt; check(n + 1, 0);\n\n        check[0] = 1;\n        check[1] = 1;\n        for(int i = 2; i &lt;= n; i++)\n            for(int k = 1; k &lt;= i; k++)\n                check[i] += check[k - 1] * check[i - k];\n        return check[n];\n    }\n};\n\n",
        "url": "/2022/06/24/96-Unique-Binary-Search-Trees/"
      },
    
      {
        "title": "Interleaving String",
        "excerpt": "&lt;-M 97&gt; Interleaving String\n\nclass Solution {\nprivate:\n    vector&lt;vector&lt;bool&gt;&gt; dp;\n\tvector&lt;vector&lt;bool&gt;&gt; vis;\n\n\tbool solve(int i, int j, string &amp;a, string &amp;b, string &amp;c) {\n\t\tif (i == 0 &amp;&amp; j == 0) return true;\n\t\tif (vis[i][j]) return dp[i][j];\n\t\tvis[i][j] = true;\n\t\tif (i == 0) return dp[i][j] = b[j - 1] == c[j - 1] &amp;&amp; solve(i, j - 1, a, b, c);\n\t\tif (j == 0) return dp[i][j] = a[i - 1] == c[i - 1] &amp;&amp; solve(i - 1, j, a, b, c);\n\n\t\tint k = i + j - 1;\n\t\tif (a[i - 1] != c[k] &amp;&amp; b[j - 1] != c[k]) return dp[i][j] = false;\n\t\tif (a[i - 1] == c[k]) dp[i][j] = solve(i - 1, j, a, b, c);\n\t\tif (b[j - 1] == c[k]) dp[i][j] = dp[i][j] || solve(i, j - 1, a, b, c);\n\t\treturn dp[i][j];\n\t}\n\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int n = s1.length(), m = s2.length();\n\t\tdp.resize(n + 1, vector&lt;bool&gt;(m + 1, false));\n\t\tvis.resize(n + 1, vector&lt;bool&gt;(m + 1, false));\n\t\tint k = s3.length();\n\t\tif (k != n + m) return false;\n\t\treturn solve(n, m, s1, s2, s3);\n    }\n};\n\n",
        "content": "&lt;-M 97&gt; Interleaving String\n\nclass Solution {\nprivate:\n    vector&lt;vector&lt;bool&gt;&gt; dp;\n\tvector&lt;vector&lt;bool&gt;&gt; vis;\n\n\tbool solve(int i, int j, string &amp;a, string &amp;b, string &amp;c) {\n\t\tif (i == 0 &amp;&amp; j == 0) return true;\n\t\tif (vis[i][j]) return dp[i][j];\n\t\tvis[i][j] = true;\n\t\tif (i == 0) return dp[i][j] = b[j - 1] == c[j - 1] &amp;&amp; solve(i, j - 1, a, b, c);\n\t\tif (j == 0) return dp[i][j] = a[i - 1] == c[i - 1] &amp;&amp; solve(i - 1, j, a, b, c);\n\n\t\tint k = i + j - 1;\n\t\tif (a[i - 1] != c[k] &amp;&amp; b[j - 1] != c[k]) return dp[i][j] = false;\n\t\tif (a[i - 1] == c[k]) dp[i][j] = solve(i - 1, j, a, b, c);\n\t\tif (b[j - 1] == c[k]) dp[i][j] = dp[i][j] || solve(i, j - 1, a, b, c);\n\t\treturn dp[i][j];\n\t}\n\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int n = s1.length(), m = s2.length();\n\t\tdp.resize(n + 1, vector&lt;bool&gt;(m + 1, false));\n\t\tvis.resize(n + 1, vector&lt;bool&gt;(m + 1, false));\n\t\tint k = s3.length();\n\t\tif (k != n + m) return false;\n\t\treturn solve(n, m, s1, s2, s3);\n    }\n};\n\n",
        "url": "/2022/06/24/97-Interleaving-String/"
      },
    
      {
        "title": "Validate Binary Search Tree",
        "excerpt": "&lt;-M 98&gt; Validate Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        return isValidBST(root, LLONG_MIN, LLONG_MAX);\n    }\nprivate:\n    bool isValidBST(TreeNode* root, long long int lower, long long int upper) {\n        if(root == nullptr)\n            return true;\n        return root-&gt;val &gt; lower &amp;&amp; root-&gt;val &lt; upper\n            &amp;&amp; isValidBST(root-&gt;left, lower, root-&gt;val)\n            &amp;&amp; isValidBST(root-&gt;right, root-&gt;val, upper);\n    }\n};\n\n",
        "content": "&lt;-M 98&gt; Validate Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        return isValidBST(root, LLONG_MIN, LLONG_MAX);\n    }\nprivate:\n    bool isValidBST(TreeNode* root, long long int lower, long long int upper) {\n        if(root == nullptr)\n            return true;\n        return root-&gt;val &gt; lower &amp;&amp; root-&gt;val &lt; upper\n            &amp;&amp; isValidBST(root-&gt;left, lower, root-&gt;val)\n            &amp;&amp; isValidBST(root-&gt;right, root-&gt;val, upper);\n    }\n};\n\n",
        "url": "/2022/06/24/98-Validate-Binary-Search-Tree/"
      },
    
      {
        "title": "Recover Binary Search Tree",
        "excerpt": "&lt;-M 99&gt; Recover Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        pair&lt;TreeNode*, TreeNode*&gt; broken;\n        TreeNode *prev = nullptr;\n        TreeNode *cur = root;\n\n        while(cur != nullptr) {\n            if(cur-&gt;left == nullptr) {\n                detect(broken, prev, cur);\n                prev = cur;\n                cur = cur-&gt;right;\n            }\n            else {\n                TreeNode *node = cur-&gt;left;\n\n                while(node-&gt;right != nullptr &amp;&amp; node-&gt;right != cur)\n                    node = node-&gt;right;\n                if(node-&gt;right == nullptr) {\n                    node-&gt;right = cur;\n                    cur = cur-&gt;left;\n                }\n                else {\n                    detect(broken, prev, cur);\n                    node-&gt;right = nullptr;\n                    prev = cur;\n                    cur = cur-&gt;right;\n                }\n            }\n        }\n        swap(broken.first-&gt;val, broken.second-&gt;val);\n    }\nprivate:\n    void detect(pair&lt;TreeNode*, TreeNode*&gt; &amp;broken, TreeNode* prev, TreeNode* cur) {\n        if(prev != nullptr &amp;&amp; prev-&gt;val &gt; cur-&gt;val) {\n            if(broken.first == nullptr)\n                broken.first = prev;\n            broken.second = cur;\n        }\n\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n\n    void recoverTree(TreeNode* root) {\n\n        TreeNode* parent = nullptr;\n        TreeNode* first = nullptr;\n        TreeNode* second = nullptr;\n\n        stack&lt;TreeNode*&gt; s;\n\n        TreeNode* curr = root;\n\n        while(curr || !s.empty()) {\n            while(curr) {\n                s.push(curr);\n                curr = curr-&gt;left;\n            }\n            curr = s.top();\n            s.pop();\n\n            if(parent &amp;&amp; (parent-&gt;val &gt; curr-&gt;val)) {\n                if(!first) {\n                    first = parent;\n                }\n                second = curr;\n            }\n            parent = curr;\n            curr = curr-&gt;right;\n        }\n        int temp = first-&gt;val;\n        first-&gt;val = second-&gt;val;\n        second-&gt;val = temp;\n\n    }\n};\n\n",
        "content": "&lt;-M 99&gt; Recover Binary Search Tree\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// Method 1\nclass Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        pair&lt;TreeNode*, TreeNode*&gt; broken;\n        TreeNode *prev = nullptr;\n        TreeNode *cur = root;\n\n        while(cur != nullptr) {\n            if(cur-&gt;left == nullptr) {\n                detect(broken, prev, cur);\n                prev = cur;\n                cur = cur-&gt;right;\n            }\n            else {\n                TreeNode *node = cur-&gt;left;\n\n                while(node-&gt;right != nullptr &amp;&amp; node-&gt;right != cur)\n                    node = node-&gt;right;\n                if(node-&gt;right == nullptr) {\n                    node-&gt;right = cur;\n                    cur = cur-&gt;left;\n                }\n                else {\n                    detect(broken, prev, cur);\n                    node-&gt;right = nullptr;\n                    prev = cur;\n                    cur = cur-&gt;right;\n                }\n            }\n        }\n        swap(broken.first-&gt;val, broken.second-&gt;val);\n    }\nprivate:\n    void detect(pair&lt;TreeNode*, TreeNode*&gt; &amp;broken, TreeNode* prev, TreeNode* cur) {\n        if(prev != nullptr &amp;&amp; prev-&gt;val &gt; cur-&gt;val) {\n            if(broken.first == nullptr)\n                broken.first = prev;\n            broken.second = cur;\n        }\n\n    }\n};\n\n// Method 2\nclass Solution {\npublic:\n\n    void recoverTree(TreeNode* root) {\n\n        TreeNode* parent = nullptr;\n        TreeNode* first = nullptr;\n        TreeNode* second = nullptr;\n\n        stack&lt;TreeNode*&gt; s;\n\n        TreeNode* curr = root;\n\n        while(curr || !s.empty()) {\n            while(curr) {\n                s.push(curr);\n                curr = curr-&gt;left;\n            }\n            curr = s.top();\n            s.pop();\n\n            if(parent &amp;&amp; (parent-&gt;val &gt; curr-&gt;val)) {\n                if(!first) {\n                    first = parent;\n                }\n                second = curr;\n            }\n            parent = curr;\n            curr = curr-&gt;right;\n        }\n        int temp = first-&gt;val;\n        first-&gt;val = second-&gt;val;\n        second-&gt;val = temp;\n\n    }\n};\n\n",
        "url": "/2022/06/24/99-Recover-Binary-Search-Tree/"
      },
    
      {
        "title": "Surrounded Regions",
        "excerpt": "&lt;-M 130&gt; Surrounded Regions\n\n// Method 1\nclass Solution {\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty())\n            return;\n\n        const int m = board.size();\n        const int n = board.front().size();\n\n        for(int i = 0; i &lt; n; i++) {\n            bfs(board, 0, i);\n            bfs(board, m - 1, i);\n        }\n\n        for(int i = 1; i &lt; m - 1; i++) {\n            bfs(board, i, 0);\n            bfs(board, i, n - 1);\n        }\n        for(int i = 0; i &lt; m; i++)\n            for(int j = 0; j &lt; n; j++)\n                if(board[i][j] == 'O')\n                    board[i][j] = 'X';\n        else if(board[i][j] == '+')\n            board[i][j] = 'O';\n    }\n\nprivate:\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j) {\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        const int m = board.size();\n        const int n = board.front().size();\n\n        auto is_valid = [&amp;](const pair&lt;int, int&gt; &amp;s) {\n            const int x = s.first;\n            const int y = s.second;\n            if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || board[x][y] != 'O')\n                return false;\n            return true;\n        };\n        auto state_extend = [&amp;](const pair&lt;int, int&gt; &amp;s) {\n            vector&lt;pair&lt;int, int&gt;&gt; result;\n            const int x = s.first;\n            const int y = s.second;\n            const pair&lt;int, int&gt; new_states[4] = {\n                {x - 1, y}, \n                {x + 1, y}, \n                {x, y - 1}, \n                {x, y + 1}\n                };\n\n            for(int k = 0; k &lt; 4; k++) {\n                if(is_valid(new_states[k])) {\n                    board[new_states[k].first][new_states[k].second] = '+';\n                    result.push_back(new_states[k]);\n                }\n            }\n            return result;\n        };\n\n        pair&lt;int, int&gt; start = {i, j};\n        if(is_valid(start)) {\n            board[i][j] = '+';\n            q.push(start);\n        }\n        while(!q.empty()) {\n            auto cur = q.front();\n            q.pop();\n            for(auto s : state_extend(cur))\n                q.push(s);\n        }\n    }\n};\n\n// Method 2\nclass Solution {\nprivate:\n    bool isValid(int i, int j, int n, int m) {\n        if(i &lt; 0 || j &lt; 0 || i &gt;= n || j &gt;= m)\n            return false;\n        return true;\n    }\n\n    vector&lt;int&gt; dx = {1, -1, 0, 0};\n    vector&lt;int&gt; dy = {0, 0, 1, -1};\n\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int i, int j) {\n        int n = board.size();\n        int m = board[0].size();\n\n        if(!isValid(i ,j, n, m))\n            return;\n\n        if(board[i][j] == 'X' || visited[i][j])\n            return;\n\n        visited[i][j] = true;\n\n        for(int k = 0; k &lt; 4; k++){\n            dfs(board, visited, i + dx[k], j + dy[k]);\n        }\n\n    }\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\n        int n = board.size();\n\n        int m = board[0].size();\n\n        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));\n\n        for(int i = 0; i &lt; n; i++) {\n            if(board[i][0] == 'O')\n                dfs(board, visited, i, 0);\n            if(board[i][m-1] == 'O')\n                dfs(board, visited, i, m-1);\n        }\n\n        for(int j = 0; j &lt; m; j++) {\n            if(board[0][j] == 'O')\n                dfs(board, visited, 0, j);\n            if(board[n - 1][j] == 'O')\n                dfs(board, visited, n - 1, j);\n        }\n\n        for(int i = 0; i &lt; n; i++){\n            for(int j = 0; j &lt; m; j++){\n                if(board[i][j] == 'O' &amp;&amp; !visited[i][j])\n                    board[i][j] = 'X';\n            }\n        }\n    }\n};\n\n",
        "content": "&lt;-M 130&gt; Surrounded Regions\n\n// Method 1\nclass Solution {\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n        if(board.empty())\n            return;\n\n        const int m = board.size();\n        const int n = board.front().size();\n\n        for(int i = 0; i &lt; n; i++) {\n            bfs(board, 0, i);\n            bfs(board, m - 1, i);\n        }\n\n        for(int i = 1; i &lt; m - 1; i++) {\n            bfs(board, i, 0);\n            bfs(board, i, n - 1);\n        }\n        for(int i = 0; i &lt; m; i++)\n            for(int j = 0; j &lt; n; j++)\n                if(board[i][j] == 'O')\n                    board[i][j] = 'X';\n        else if(board[i][j] == '+')\n            board[i][j] = 'O';\n    }\n\nprivate:\n    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j) {\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        const int m = board.size();\n        const int n = board.front().size();\n\n        auto is_valid = [&amp;](const pair&lt;int, int&gt; &amp;s) {\n            const int x = s.first;\n            const int y = s.second;\n            if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || board[x][y] != 'O')\n                return false;\n            return true;\n        };\n        auto state_extend = [&amp;](const pair&lt;int, int&gt; &amp;s) {\n            vector&lt;pair&lt;int, int&gt;&gt; result;\n            const int x = s.first;\n            const int y = s.second;\n            const pair&lt;int, int&gt; new_states[4] = {\n                {x - 1, y}, \n                {x + 1, y}, \n                {x, y - 1}, \n                {x, y + 1}\n                };\n\n            for(int k = 0; k &lt; 4; k++) {\n                if(is_valid(new_states[k])) {\n                    board[new_states[k].first][new_states[k].second] = '+';\n                    result.push_back(new_states[k]);\n                }\n            }\n            return result;\n        };\n\n        pair&lt;int, int&gt; start = {i, j};\n        if(is_valid(start)) {\n            board[i][j] = '+';\n            q.push(start);\n        }\n        while(!q.empty()) {\n            auto cur = q.front();\n            q.pop();\n            for(auto s : state_extend(cur))\n                q.push(s);\n        }\n    }\n};\n\n// Method 2\nclass Solution {\nprivate:\n    bool isValid(int i, int j, int n, int m) {\n        if(i &lt; 0 || j &lt; 0 || i &gt;= n || j &gt;= m)\n            return false;\n        return true;\n    }\n\n    vector&lt;int&gt; dx = {1, -1, 0, 0};\n    vector&lt;int&gt; dy = {0, 0, 1, -1};\n\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int i, int j) {\n        int n = board.size();\n        int m = board[0].size();\n\n        if(!isValid(i ,j, n, m))\n            return;\n\n        if(board[i][j] == 'X' || visited[i][j])\n            return;\n\n        visited[i][j] = true;\n\n        for(int k = 0; k &lt; 4; k++){\n            dfs(board, visited, i + dx[k], j + dy[k]);\n        }\n\n    }\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n\n        int n = board.size();\n\n        int m = board[0].size();\n\n        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false));\n\n        for(int i = 0; i &lt; n; i++) {\n            if(board[i][0] == 'O')\n                dfs(board, visited, i, 0);\n            if(board[i][m-1] == 'O')\n                dfs(board, visited, i, m-1);\n        }\n\n        for(int j = 0; j &lt; m; j++) {\n            if(board[0][j] == 'O')\n                dfs(board, visited, 0, j);\n            if(board[n - 1][j] == 'O')\n                dfs(board, visited, n - 1, j);\n        }\n\n        for(int i = 0; i &lt; n; i++){\n            for(int j = 0; j &lt; m; j++){\n                if(board[i][j] == 'O' &amp;&amp; !visited[i][j])\n                    board[i][j] = 'X';\n            }\n        }\n    }\n};\n\n",
        "url": "/2022/07/24/130-Surrounded-Regions/"
      },
    
      {
        "title": "Edit Distance",
        "excerpt": "&lt;-H 72&gt; Edit Distance\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        const int n = word1.size();\n        const int m = word2.size();\n\n        int f[n + 1][m + 1];\n        for(int i = 0; i &lt;= n; i++)\n            f[i][0] = i;\n        for(int i = 0; i &lt;= m; i++)\n            f[0][i] = i;\n\n        for(int i = 1; i &lt;= n; i++)\n            for(int j = 1; j &lt;= m; j++)\n                if(word1[i - 1] == word2[j - 1])\n                    f[i][j] = f[i - 1][j - 1];\n                else\n                    f[i][j] = 1 + min(f[i - 1][j -1], min(f[i - 1][j], f[i][j - 1]));\n\n        return f[n][m];\n    }\n};\n\n",
        "content": "&lt;-H 72&gt; Edit Distance\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        const int n = word1.size();\n        const int m = word2.size();\n\n        int f[n + 1][m + 1];\n        for(int i = 0; i &lt;= n; i++)\n            f[i][0] = i;\n        for(int i = 0; i &lt;= m; i++)\n            f[0][i] = i;\n\n        for(int i = 1; i &lt;= n; i++)\n            for(int j = 1; j &lt;= m; j++)\n                if(word1[i - 1] == word2[j - 1])\n                    f[i][j] = f[i - 1][j - 1];\n                else\n                    f[i][j] = 1 + min(f[i - 1][j -1], min(f[i - 1][j], f[i][j - 1]));\n\n        return f[n][m];\n    }\n};\n\n",
        "url": "/2022/08/06/72-Edit-Distance/"
      },
    
      {
        "title": "Distinct Subsequences",
        "excerpt": "&lt;-H 115&gt; Distinct Subsequences\n\nclass Solution {\npublic:\n    int numDistinct(string s, string t) {\n        vector&lt;unsigned long long&gt; f(t.size() + 1);\n\n        f[0] = 1;\n            for(int i = 0; i &lt; s.size(); i++)\n                for(int j = t.size() - 1; j &gt;= 0; j--)\n                    f[j + 1] += s[i] == t[j] ? f[j] : 0;\n\n        return f[t.size()];\n    }\n};\n\n",
        "content": "&lt;-H 115&gt; Distinct Subsequences\n\nclass Solution {\npublic:\n    int numDistinct(string s, string t) {\n        vector&lt;unsigned long long&gt; f(t.size() + 1);\n\n        f[0] = 1;\n            for(int i = 0; i &lt; s.size(); i++)\n                for(int j = t.size() - 1; j &gt;= 0; j--)\n                    f[j + 1] += s[i] == t[j] ? f[j] : 0;\n\n        return f[t.size()];\n    }\n};\n\n",
        "url": "/2022/08/08/115-Distinct-Subsequences/"
      },
    
      {
        "title": "Word Break",
        "excerpt": "&lt;-H 139&gt; Word Break\n\nclass Solution {\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        vector&lt;bool&gt; res(s.size(),false);\n        res[0]=true;\n        for(int i=0;i&lt;s.size();i++){\n            if(res[i]){\n                for(auto str:wordDict){\n                    if(s.substr(i, str.size()).compare(str)==0){\n                        res[i+str.size()]=true;\n                    }\n                }\n            }\n        }\n        return res[s.size()];\n    }\n};\n\n",
        "content": "&lt;-H 139&gt; Word Break\n\nclass Solution {\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        vector&lt;bool&gt; res(s.size(),false);\n        res[0]=true;\n        for(int i=0;i&lt;s.size();i++){\n            if(res[i]){\n                for(auto str:wordDict){\n                    if(s.substr(i, str.size()).compare(str)==0){\n                        res[i+str.size()]=true;\n                    }\n                }\n            }\n        }\n        return res[s.size()];\n    }\n};\n\n",
        "url": "/2022/08/08/139-Word-Break/"
      },
    
      {
        "title": "Decode Ways",
        "excerpt": "&lt;-M 91&gt; Decode Ways\n\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        if(s.empty() || s[0] == '0')\n            return 0;\n        int prev = 0;\n        int cur = 1;\n\n        for(int i = 1; i &lt;= s.size(); i++) {\n            if(s[i - 1] == '0')\n                cur = 0;\n\n            if(i &lt; 2 || !(s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6')))\n                prev = 0;\n\n            int temp = cur;\n            cur = prev + cur;\n            prev = temp;\n        }\n        return cur;\n    }\n};\n\n",
        "content": "&lt;-M 91&gt; Decode Ways\n\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        if(s.empty() || s[0] == '0')\n            return 0;\n        int prev = 0;\n        int cur = 1;\n\n        for(int i = 1; i &lt;= s.size(); i++) {\n            if(s[i - 1] == '0')\n                cur = 0;\n\n            if(i &lt; 2 || !(s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt;= '6')))\n                prev = 0;\n\n            int temp = cur;\n            cur = prev + cur;\n            prev = temp;\n        }\n        return cur;\n    }\n};\n\n",
        "url": "/2022/08/08/91-Decode-Ways/"
      },
    
  
  
  
  {
    "title": "Categories",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories/"
  },
  
  {
    "title": "Elements",
    "excerpt": "A demo of Markdown and HTML includes\n",
    "content": "Heading 1\n\nHeading 2\n\nHeading 3\n\nHeading 4\n\nHeading 5\n\nHeading 6\n\nA small element\n\nA link\n\nLorem ipsum dolor sit amet, consectetur adip* isicing elit, sed do eiusmod *tempor incididunt ut labore et dolore magna aliqua.\n\nDuis aute irure dolor in A link reprehenderit in voluptate velit esse cillum bold text dolore eu fugiat nulla pariatur. Excepteur span element sint occaecat cupidatat non proident, sunt italicised text in culpa qui officia deserunt mollit anim id some code est laborum.\n\n\n  An item\n  An item\n  An item\n  An item\n  An item\n\n\n\n  Item one\n  Item two\n  Item three\n  Item four\n  Item five\n\n\n\n  A simple blockquote\n\n\nSome HTML…\n\n&lt;blockquote cite=\"http://www.imdb.com/title/tt0284978/quotes/qt1375101\"&gt;\n  &lt;p&gt;You planning a vacation, Mr. Sullivan?&lt;/p&gt;\n  &lt;footer&gt;\n    &lt;a href=\"http://www.imdb.com/title/tt0284978/quotes/qt1375101\"&gt;Sunways Security Guard&lt;/a&gt;\n  &lt;/footer&gt;\n&lt;/blockquote&gt;\n\n\n…CSS…\n\nblockquote {\n  text-align: center;\n  font-weight: bold;\n}\nblockquote footer {\n  font-size: .8rem;\n}\n\n\n…and JavaScript\n\nconst blockquote = document.querySelector(\"blockquote\")\nconst bolden = (keyString, string) =&gt;\n  string.replace(new RegExp(keyString, 'g'), '&lt;strong&gt;'+keyString+'&lt;/strong&gt;')\n\nblockquote.innerHTML = bolden(\"Mr. Sullivan\", blockquote.innerHTML)\n\n\nSingle line of code\n\nHTML Includes\n\nContact form\n\n\n  \n    Contact\n    Name: *\n    \n\n    Email Address: *\n    \n\n    Message: *\n    \n\n    \n    \n    * indicates a required field\n\n    \n      \n      \n      \n    \n  \n\n\n\n\nPlease enable JavaScript to use the form.\n\n{% include site-form.html %}\n\n\nDemo map embed\n\n\n\n{% include map.html id=\"XXXXXX\" title=\"Coffee shop map\" %}\n\n\nButton include\n\nA button\n\nA button with icon  twitter\n\n\n{% include button.html text=\"A button\" link=\"https://david.darn.es\" %}\n{% include button.html text=\"A button with icon\" link=\"https://twitter.com/daviddarnes\" icon=\"twitter\" %}\n\n\nIcon include\n\ntwitter\ntwitter\n\n\n{% include icon.html id=\"twitter\" title=\"twitter\" %}\n[{% include icon.html id=\"linkedin\" title=\"twitter\" %}](https://www.linkedin.com/in/daviddarnes)\n\n\nVideo include\n\n\n  \n\n\n{% include video.html id=\"zrkcGL5H3MU\" title=\"Siteleaf tutorial video\" %}\n\n\nImage includes\n\n\n  \n  Image with caption\n\n\n\n  \n  Right aligned image\n\n\n\n  \n  Left aligned image\n\n\n\n  \n  \n\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Image with caption\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Right aligned image\" position=\"right\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Left aligned image\" position=\"left\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/1600/800?image=894\" alt=\"Image with just alt text\" %}\n\n",
    "url": "/elements/"
  },
  
  {
    "title": "About Alembic",
    "excerpt": "Alembic is a starting point for Jekyll projects. Rather than starting from scratch, this boilerplate is designed to get the ball rolling immediately. Install it, configure it, tweak it, push it.\n",
    "content": "Alembic is a starting point for Jekyll projects. Rather than starting from scratch, this boilerplate is designed to get rolling immediately. Install it, configure it, tweak it, push it.\n\nFork it  github\n\n Buy me a coffee ☕️\n Tweet it  twitter\n\n Install Alembic ⚗️\n\nFeatures\n\n\n  Available as a theme gem and GitHub Pages theme\n  Clear and elegant design that can be used out of the box or as solid starting point\n  Tested in all major browsers, including IE and Edge\n  Built in Service Worker so it can work offline and on slow connections\n  Configurable colours and typography in a single settings file\n  Extensive set of shortcodes to include various elements; such as buttons, icons, figure images and more\n  Solid typographic framework from Sassline\n  Configurable navigation via a single file\n  Modular Jekyll components\n  Post category support in the form of a single post index page grouped by category\n  Built in live search using JavaScript\n  Contact form built in using Formspree\n  Designed with Siteleaf in mind\n  Has 9 of the most popular networks as performant sharing buttons\n  Has documentation\n\n\nExamples\n\nHere are a few examples of Alembic out in the wild being used in a variety of ways:\n\n\n  bawejakunal.github.io\n  case2111.github.io\n  karateca.org\n\n\nInstallation\n\nQuick setup\n\nTo give you a running start I’ve put together some starter kits that you can download, fork or even deploy immediately:\n\n\n  ⚗️🍨 Vanilla Jekyll starter kit\n\n  ⚗️🌲 Forestry starter kit\n\n\n  \n    ⚗️💠 Netlify CMS starter kit\n\n  \n  \n    ⚗️:octocat: GitHub Pages with remote theme kit\nDownload kit\n  \n  ⚗️🚀 Stackbit starter kit\n\n\n\nAs a Jekyll theme\n\n\n  Add gem \"alembic-jekyll-theme\" to your Gemfile to add the theme as a dependancy\n  Run the command bundle install in the root of project to install the theme and its dependancies\n  Add theme: alembic-jekyll-theme to your _config.yml file to set the site theme\n  Run bundle exec jekyll serve to build and serve your site\n  Done! Use the configuration documentation and the example _config.yml file to set things like the navigation, contact form and social sharing buttons\n\n\nAs a GitHub Pages remote theme\n\n\n  Add gem \"jekyll-remote-theme\" to your Gemfile to add the theme as a dependancy\n  Run the command bundle install in the root of project to install the jekyll remote theme gem as a dependancy\n  Add jekyll-remote-theme to the list of plugins in your _config.yml file\n  Add remote_theme: daviddarnes/alembic@main to your _config.yml file to set the site theme\n  Run bundle exec jekyll serve to build and serve your site\n  Done! Use the configuration documentation and the example _config.yml file to set things like the navigation, contact form and social sharing buttons\n\n\nAs a Boilerplate / Fork\n\n(deprecated, not recommended)\n\n\n  Fork the repo\n  Replace the Gemfile with one stating all the gems used in your project\n  Delete the following unnecessary files/folders: .github, LICENSE, screenshot.png, CNAME and alembic-jekyll-theme.gemspec\n  Run the command bundle install in the root of project to install the jekyll remote theme gem as a dependancy\n  Run bundle exec jekyll serve to build and serve your site\n  Done! Use the configuration documentation and the example _config.yml file to set things like the navigation, contact form and social sharing buttons\n\n\nCustomising\n\nWhen using Alembic as a theme means you can take advantage of the file overriding method. This allows you to overwrite any file in this theme with your own custom file, by matching the file name and path. The most common example of this would be if you want to add your own styles or change the core style settings.\n\nTo add your own styles copy the styles.scss into your own project with the same file path (assets/styles.scss). From there you can add your own styles, you can even optionally ignore the theme styles by removing the @import \"alembic\"; line.\n\nIf you’re looking to set your own colours and fonts you can overwrite them by matching the variable names from the _settings.scss file in your own styles.scss, make sure to state them before the @import \"alembic\"; line so they take effect. The settings are a mixture of custom variables and settings from Sassline - follow the link to find out how to configure the typographic settings.\n",
    "url": "/"
  },
  
  {
    "title": "Search",
    "excerpt": "Search for a page or post you’re looking for\n",
    "content": "{% include site-search.html %}\n",
    "url": "/search/"
  }
  
]

