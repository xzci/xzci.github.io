---
title: C++复习笔记
categories:
 - 中文笔记
tags:
 - C++
---

2020年 02 月 19 日更新

# 变量初始化

函数体之外的变量都被初始化为 0
函数体内部的变量都不会被初始化

* 直接初始化  没有等号
* 拷贝初始化 有等号

# 传递引用 

可以阻止函数传递时, 对参数的拷贝

# 类

## 成员函数

```c++
Type A::f() const 
{}
```

若将成员函数声明为const，则不允许通过其修改类的数据成员。 值得注意的是，如果类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象。

设置友元类, 可以访问 私有变量

## 构造函数初始值

在构造函数中,__无法忽略__ 初始化和赋值之间的差异

* 构造函数初始化存在顺序关系
最好让保证于成名声明的顺序一致

```c++
class TestA {
public:
    TestA(int ii);
private:
    int i;
    const int ci;
    int &i;
}
//如使用赋值的话, 会出现错误
/*
TestA::TestA(int ii) {
    i = ii;
    ci = ii; // const 无法被赋值
    ri = i; // ri 没有被初始化
}
*/

// 正确的是 (构造方式)

TestA::TestA(int ii):i(ii), ci(ii), ri(i) {}
```

# 容器 

## swap

除了string外, 指向容器的迭代器,引用, 指针 __不会__ 失效, 仍然指向之前的值.

只有Array 真正交换了他们的元素.

# bind

bind 函数拷贝其参数, 如果提供一个对象但不拷贝他, 需要使用标准库的ref函数

# 函数

## 尾置返回类型

```c++
auto func(int i) -> int(*)[10]
```
用以简化函数的返回值

# 迭代器


## 普通迭代器

```c++
*it;
++it;
it++
```

不会对 __迭代器__ it 做任何事情, 每个操作都会返回it

## iostream 迭代器

### istream_iterator

```c++
istream_iterator<int> int_it(cin); // 从cin 读int
istream_iterator<int> int_eof; // 尾后迭代器 (用来判断读取中止)
```

### ostream_iterator

```c++
    vector<string> test(10, "test");
    // 将类型T写到cout 流中, 并且中间以---隔开
    ostream_iterator<string> out_iter(cout, "---");
    copy(test.begin(), test.end(), out_iter);
    cout << endl;
```
## 算法中使用的迭代器错误, 可能不会被语法检查器检查出来.

# 编程提示

* 如果两个对象共享底层的数据, 当某个对象被销毁的时候, 不能单方面的销毁底层数据
* 

