---
title: CS50 Notes
categories:
 - Notes
tags:
 - AI
---

# AI

## Basic terminology



- initial state

  the state in which the agent begins
  
    - agent 

    entity that perceives its environment and acts upon that environment

  - state

    a configuration of the agent and its environment

- actions

  choices that can be made in a state

  - actions

    __ACTIONS(s)__ returns the set of actions that can be executed in state s

- transition model

  a description of what state results from performing any applicable action in any state

  __RESULT(s, a)__ returns the state resulting from performing action a in state s

  - state space

    the set of all states reachable from the initial state by any sequence of actions

- goal test

  way to determine whether a given state is a goal state

- path cost
  
  numerical cost associated with a given path


- solution

  a sequence of actions that leads from the initial state to a goal state

- optimal solution

a solution that has the lowest path cost among all solutions

### Data structure

1. node (Actually it is not a typical Data structure)

    a data structure that keeps track of
  - a state
  - a parent (node that generated this node)
  - an action (action applied to parent to get node)
  - a path cost (from initial state to node)

2. stack

    last-in first-out data type

3. queue

    first-in first-out data type


## Search problem

- simple approach

Start with a frontier that contains the initial state.

    Repeat:

      If the frontier is empty, then no solution.   
      Remove a node from the frontier.
      If node contains goal state, return the solution.  
      Expand node, add resulting nodes to the frontier.

- Revised Approach (to avoid reverse) __depth-first search__

Start with a frontier that contains the initial state.

Start with an empty explored set.

    Repeat:

      If the frontier is empty, then no solution.
      Remove a node from the frontier.
      If node contains goal state, return the solution.
      Add the node to the explored set.
      Expand node, add resulting nodes to the frontier if they aren't already in the frontier or the explored set.

## uninformed search

Search strategy that uses no problem- specific knowledge.

They both are always work, and not necessarily a optimal solution.

- DFS depth-first search
  
search algorithm that always expands the deepest node in the frontier, using stack.

- BFS breadth-first search

search algorithm that always expands the shallowest node in the frontier, using queue.

## informed search

search strategy that uses problem-specific knowledge to find solutions more efficiently

- greedy best-first search

search algorithm that expands the node that is closest to the goal, as estimated by a heuristic function h(n)

- A* search

search algorithm that expands node with lowest value of g(n) + h(n)

g(n) = cost to reach node h(n) = estimated cost to goal

optimal if

    h(n) is admissible (never overestimates the true cost), and
    h(n) is consistent (for every node n and successor n' with step cost c, h(n) â‰¤ h(n') + c)


![2](Image/1.png)
![3](Image/1.png)

![6](images/1.png)
![7](/images/1.png)



